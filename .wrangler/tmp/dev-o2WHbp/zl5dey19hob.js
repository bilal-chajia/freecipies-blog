var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e2) => e2.name !== markName) : this._entries.filter((e2) => e2.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e2) => e2.name !== measureName) : this._entries.filter((e2) => e2.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e2) => e2.entryType !== "resource" || e2.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e2) => e2.name === name && (!type || e2.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e2) => e2.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir4, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count4, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process2 extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process2.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd3) {
        this.#cwd = cwd3;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2._bec3bf28fac1f7d309e15434c311b95f/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/astro/server_B79ahsw9.mjs
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function normalizeLF(code) {
  return code.replace(/\r\n|\r(?!\n)|\n/g, "\n");
}
function codeFrame(src, loc) {
  if (!loc || loc.line === void 0 || loc.column === void 0) {
    return "";
  }
  const lines = normalizeLF(src).split("\n").map((ln) => ln.replace(/\t/g, "  "));
  const visibleLines = [];
  for (let n2 = -2; n2 <= 2; n2++) {
    if (lines[loc.line + n2]) visibleLines.push(loc.line + n2);
  }
  let gutterWidth = 0;
  for (const lineNo of visibleLines) {
    let w = `> ${lineNo}`;
    if (w.length > gutterWidth) gutterWidth = w.length;
  }
  let output = "";
  for (const lineNo of visibleLines) {
    const isFocusedLine = lineNo === loc.line - 1;
    output += isFocusedLine ? "> " : "  ";
    output += `${lineNo + 1} | ${lines[lineNo]}
`;
    if (isFocusedLine)
      output += `${Array.from({ length: gutterWidth }).join(" ")}  | ${Array.from({
        length: loc.column
      }).join(" ")}^
`;
  }
  return output;
}
function validateArgs(args) {
  if (args.length !== 3) return false;
  if (!args[0] || typeof args[0] !== "object") return false;
  return true;
}
function baseCreateComponent(cb, moduleId, propagation) {
  const name = moduleId?.split("/").pop()?.replace(".astro", "") ?? "";
  const fn = /* @__PURE__ */ __name((...args) => {
    if (!validateArgs(args)) {
      throw new AstroError({
        ...InvalidComponentArgs,
        message: InvalidComponentArgs.message(name)
      });
    }
    return cb(...args);
  }, "fn");
  Object.defineProperty(fn, "name", { value: name, writable: false });
  fn.isAstroComponentFactory = true;
  fn.moduleId = moduleId;
  fn.propagation = propagation;
  return fn;
}
function createComponentWithOptions(opts) {
  const cb = baseCreateComponent(opts.factory, opts.moduleId, opts.propagation);
  return cb;
}
function createComponent(arg1, moduleId, propagation) {
  if (typeof arg1 === "function") {
    return baseCreateComponent(arg1, moduleId, propagation);
  } else {
    return createComponentWithOptions(arg1);
  }
}
function createAstroGlobFn() {
  const globHandler = /* @__PURE__ */ __name((importMetaGlobResult) => {
    console.warn(`Astro.glob is deprecated and will be removed in a future major version of Astro.
Use import.meta.glob instead: https://vitejs.dev/guide/features.html#glob-import`);
    if (typeof importMetaGlobResult === "string") {
      throw new AstroError({
        ...AstroGlobUsedOutside,
        message: AstroGlobUsedOutside.message(JSON.stringify(importMetaGlobResult))
      });
    }
    let allEntries = [...Object.values(importMetaGlobResult)];
    if (allEntries.length === 0) {
      throw new AstroError({
        ...AstroGlobNoMatch,
        message: AstroGlobNoMatch.message(JSON.stringify(importMetaGlobResult))
      });
    }
    return Promise.all(allEntries.map((fn) => fn()));
  }, "globHandler");
  return globHandler;
}
function createAstro(site) {
  return {
    site: new URL(site),
    generator: `Astro v${ASTRO_VERSION}`,
    glob: createAstroGlobFn()
  };
}
async function renderEndpoint(mod, context3, isPrerendered, logger) {
  const { request, url } = context3;
  const method = request.method.toUpperCase();
  let handler = mod[method] ?? mod["ALL"];
  if (!handler && method === "HEAD" && mod["GET"]) {
    handler = mod["GET"];
  }
  if (isPrerendered && !["GET", "HEAD"].includes(method)) {
    logger.warn(
      "router",
      `${url.pathname} ${s.bold(
        method
      )} requests are not available in static endpoints. Mark this page as server-rendered (\`export const prerender = false;\`) or update your config to \`output: 'server'\` to make all your pages server-rendered by default.`
    );
  }
  if (handler === void 0) {
    logger.warn(
      "router",
      `No API Route handler exists for the method "${method}" for the route "${url.pathname}".
Found handlers: ${Object.keys(mod).map((exp) => JSON.stringify(exp)).join(", ")}
` + ("all" in mod ? `One of the exported handlers is "all" (lowercase), did you mean to export 'ALL'?
` : "")
    );
    return new Response(null, { status: 404 });
  }
  if (typeof handler !== "function") {
    logger.error(
      "router",
      `The route "${url.pathname}" exports a value for the method "${method}", but it is of the type ${typeof handler} instead of a function.`
    );
    return new Response(null, { status: 500 });
  }
  let response = await handler.call(mod, context3);
  if (!response || response instanceof Response === false) {
    throw new AstroError(EndpointDidNotReturnAResponse);
  }
  if (REROUTABLE_STATUS_CODES.includes(response.status)) {
    try {
      response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
    } catch (err) {
      if (err.message?.includes("immutable")) {
        response = new Response(response.body, response);
        response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
      } else {
        throw err;
      }
    }
  }
  if (method === "HEAD") {
    return new Response(null, response);
  }
  return response;
}
function isPromise(value) {
  return !!value && typeof value === "object" && "then" in value && typeof value.then === "function";
}
async function* streamAsyncIterator(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) return;
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
function isHTMLString(value) {
  return Object.prototype.toString.call(value) === "[object HTMLString]";
}
function markHTMLBytes(bytes) {
  return new HTMLBytes(bytes);
}
function hasGetReader(obj) {
  return typeof obj.getReader === "function";
}
async function* unescapeChunksAsync(iterable) {
  if (hasGetReader(iterable)) {
    for await (const chunk of streamAsyncIterator(iterable)) {
      yield unescapeHTML(chunk);
    }
  } else {
    for await (const chunk of iterable) {
      yield unescapeHTML(chunk);
    }
  }
}
function* unescapeChunks(iterable) {
  for (const chunk of iterable) {
    yield unescapeHTML(chunk);
  }
}
function unescapeHTML(str) {
  if (!!str && typeof str === "object") {
    if (str instanceof Uint8Array) {
      return markHTMLBytes(str);
    } else if (str instanceof Response && str.body) {
      const body = str.body;
      return unescapeChunksAsync(body);
    } else if (typeof str.then === "function") {
      return Promise.resolve(str).then((value) => {
        return unescapeHTML(value);
      });
    } else if (str[Symbol.for("astro:slot-string")]) {
      return str;
    } else if (Symbol.iterator in str) {
      return unescapeChunks(str);
    } else if (Symbol.asyncIterator in str || hasGetReader(str)) {
      return unescapeChunksAsync(str);
    }
  }
  return markHTMLString(str);
}
function isVNode(vnode) {
  return vnode && typeof vnode === "object" && vnode[AstroJSX];
}
function isAstroComponentFactory(obj) {
  return obj == null ? false : obj.isAstroComponentFactory === true;
}
function isAPropagatingComponent(result, factory) {
  const hint = getPropagationHint(result, factory);
  return hint === "in-tree" || hint === "self";
}
function getPropagationHint(result, factory) {
  let hint = factory.propagation || "none";
  if (factory.moduleId && result.componentMetadata.has(factory.moduleId) && hint === "none") {
    hint = result.componentMetadata.get(factory.moduleId).propagation;
  }
  return hint;
}
function r(e2) {
  var t2, f, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f = r(e2[t2])) && (n2 && (n2 += " "), n2 += f);
  } else for (f in e2) e2[f] && (n2 && (n2 += " "), n2 += f);
  return n2;
}
function clsx() {
  for (var e2, t2, f = 0, n2 = "", o2 = arguments.length; f < o2; f++) (e2 = arguments[f]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function serializeArray(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  if (parents.has(value)) {
    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!

Cyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);
  }
  parents.add(value);
  const serialized = value.map((v) => {
    return convertToSerializedForm(v, metadata, parents);
  });
  parents.delete(value);
  return serialized;
}
function serializeObject(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  if (parents.has(value)) {
    throw new Error(`Cyclic reference detected while serializing props for <${metadata.displayName} client:${metadata.hydrate}>!

Cyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);
  }
  parents.add(value);
  const serialized = Object.fromEntries(
    Object.entries(value).map(([k, v]) => {
      return [k, convertToSerializedForm(v, metadata, parents)];
    })
  );
  parents.delete(value);
  return serialized;
}
function convertToSerializedForm(value, metadata = {}, parents = /* @__PURE__ */ new WeakSet()) {
  const tag2 = Object.prototype.toString.call(value);
  switch (tag2) {
    case "[object Date]": {
      return [PROP_TYPE.Date, value.toISOString()];
    }
    case "[object RegExp]": {
      return [PROP_TYPE.RegExp, value.source];
    }
    case "[object Map]": {
      return [PROP_TYPE.Map, serializeArray(Array.from(value), metadata, parents)];
    }
    case "[object Set]": {
      return [PROP_TYPE.Set, serializeArray(Array.from(value), metadata, parents)];
    }
    case "[object BigInt]": {
      return [PROP_TYPE.BigInt, value.toString()];
    }
    case "[object URL]": {
      return [PROP_TYPE.URL, value.toString()];
    }
    case "[object Array]": {
      return [PROP_TYPE.JSON, serializeArray(value, metadata, parents)];
    }
    case "[object Uint8Array]": {
      return [PROP_TYPE.Uint8Array, Array.from(value)];
    }
    case "[object Uint16Array]": {
      return [PROP_TYPE.Uint16Array, Array.from(value)];
    }
    case "[object Uint32Array]": {
      return [PROP_TYPE.Uint32Array, Array.from(value)];
    }
    default: {
      if (value !== null && typeof value === "object") {
        return [PROP_TYPE.Value, serializeObject(value, metadata, parents)];
      }
      if (value === Infinity) {
        return [PROP_TYPE.Infinity, 1];
      }
      if (value === -Infinity) {
        return [PROP_TYPE.Infinity, -1];
      }
      if (value === void 0) {
        return [PROP_TYPE.Value];
      }
      return [PROP_TYPE.Value, value];
    }
  }
}
function serializeProps(props, metadata) {
  const serialized = JSON.stringify(serializeObject(props, metadata));
  return serialized;
}
function extractDirectives(inputProps, clientDirectives) {
  let extracted = {
    isPage: false,
    hydration: null,
    props: {},
    propsWithoutTransitionAttributes: {}
  };
  for (const [key, value] of Object.entries(inputProps)) {
    if (key.startsWith("server:")) {
      if (key === "server:root") {
        extracted.isPage = true;
      }
    }
    if (key.startsWith("client:")) {
      if (!extracted.hydration) {
        extracted.hydration = {
          directive: "",
          value: "",
          componentUrl: "",
          componentExport: { value: "" }
        };
      }
      switch (key) {
        case "client:component-path": {
          extracted.hydration.componentUrl = value;
          break;
        }
        case "client:component-export": {
          extracted.hydration.componentExport.value = value;
          break;
        }
        // This is a special prop added to prove that the client hydration method
        // was added statically.
        case "client:component-hydration": {
          break;
        }
        case "client:display-name": {
          break;
        }
        default: {
          extracted.hydration.directive = key.split(":")[1];
          extracted.hydration.value = value;
          if (!clientDirectives.has(extracted.hydration.directive)) {
            const hydrationMethods = Array.from(clientDirectives.keys()).map((d) => `client:${d}`).join(", ");
            throw new Error(
              `Error: invalid hydration directive "${key}". Supported hydration methods: ${hydrationMethods}`
            );
          }
          if (extracted.hydration.directive === "media" && typeof extracted.hydration.value !== "string") {
            throw new AstroError(MissingMediaQueryDirective);
          }
          break;
        }
      }
    } else {
      extracted.props[key] = value;
      if (!transitionDirectivesToCopyOnIsland.includes(key)) {
        extracted.propsWithoutTransitionAttributes[key] = value;
      }
    }
  }
  for (const sym of Object.getOwnPropertySymbols(inputProps)) {
    extracted.props[sym] = inputProps[sym];
    extracted.propsWithoutTransitionAttributes[sym] = inputProps[sym];
  }
  return extracted;
}
async function generateHydrateScript(scriptOptions, metadata) {
  const { renderer: renderer2, result, astroId, props, attrs } = scriptOptions;
  const { hydrate, componentUrl, componentExport } = metadata;
  if (!componentExport.value) {
    throw new AstroError({
      ...NoMatchingImport,
      message: NoMatchingImport.message(metadata.displayName)
    });
  }
  const island = {
    children: "",
    props: {
      // This is for HMR, probably can avoid it in prod
      uid: astroId
    }
  };
  if (attrs) {
    for (const [key, value] of Object.entries(attrs)) {
      island.props[key] = escapeHTML(value);
    }
  }
  island.props["component-url"] = await result.resolve(decodeURI(componentUrl));
  if (renderer2.clientEntrypoint) {
    island.props["component-export"] = componentExport.value;
    island.props["renderer-url"] = await result.resolve(
      decodeURI(renderer2.clientEntrypoint.toString())
    );
    island.props["props"] = escapeHTML(serializeProps(props, metadata));
  }
  island.props["ssr"] = "";
  island.props["client"] = hydrate;
  let beforeHydrationUrl = await result.resolve("astro:scripts/before-hydration.js");
  if (beforeHydrationUrl.length) {
    island.props["before-hydration-url"] = beforeHydrationUrl;
  }
  island.props["opts"] = escapeHTML(
    JSON.stringify({
      name: metadata.displayName,
      value: metadata.hydrateArgs || ""
    })
  );
  transitionDirectivesToCopyOnIsland.forEach((name) => {
    if (typeof props[name] !== "undefined") {
      island.props[name] = props[name];
    }
  });
  return island;
}
function bitwise(str) {
  let hash2 = 0;
  if (str.length === 0) return hash2;
  for (let i2 = 0; i2 < str.length; i2++) {
    const ch = str.charCodeAt(i2);
    hash2 = (hash2 << 5) - hash2 + ch;
    hash2 = hash2 & hash2;
  }
  return hash2;
}
function shorthash(text2) {
  let num;
  let result = "";
  let integer2 = bitwise(text2);
  const sign2 = integer2 < 0 ? "Z" : "";
  integer2 = Math.abs(integer2);
  while (integer2 >= binary) {
    num = integer2 % binary;
    integer2 = Math.floor(integer2 / binary);
    result = dictionary[num] + result;
  }
  if (integer2 > 0) {
    result = dictionary[integer2] + result;
  }
  return sign2 + result;
}
function isHeadAndContent(obj) {
  return typeof obj === "object" && obj !== null && !!obj[headAndContentSym];
}
function createThinHead() {
  return {
    [headAndContentSym]: true
  };
}
function determineIfNeedsHydrationScript(result) {
  if (result._metadata.hasHydrationScript) {
    return false;
  }
  return result._metadata.hasHydrationScript = true;
}
function determinesIfNeedsDirectiveScript(result, directive) {
  if (result._metadata.hasDirectives.has(directive)) {
    return false;
  }
  result._metadata.hasDirectives.add(directive);
  return true;
}
function getDirectiveScriptText(result, directive) {
  const clientDirectives = result.clientDirectives;
  const clientDirective = clientDirectives.get(directive);
  if (!clientDirective) {
    throw new Error(`Unknown directive: ${directive}`);
  }
  return clientDirective;
}
function getPrescripts(result, type, directive) {
  switch (type) {
    case "both":
      return `<style>${ISLAND_STYLES}</style><script>${getDirectiveScriptText(result, directive)}<\/script><script>${astro_island_prebuilt_default}<\/script>`;
    case "directive":
      return `<script>${getDirectiveScriptText(result, directive)}<\/script>`;
  }
}
function renderCspContent(result) {
  const finalScriptHashes = /* @__PURE__ */ new Set();
  const finalStyleHashes = /* @__PURE__ */ new Set();
  for (const scriptHash of result.scriptHashes) {
    finalScriptHashes.add(`'${scriptHash}'`);
  }
  for (const styleHash of result.styleHashes) {
    finalStyleHashes.add(`'${styleHash}'`);
  }
  for (const styleHash of result._metadata.extraStyleHashes) {
    finalStyleHashes.add(`'${styleHash}'`);
  }
  for (const scriptHash of result._metadata.extraScriptHashes) {
    finalScriptHashes.add(`'${scriptHash}'`);
  }
  let directives;
  if (result.directives.length > 0) {
    directives = result.directives.join(";") + ";";
  }
  let scriptResources = "'self'";
  if (result.scriptResources.length > 0) {
    scriptResources = result.scriptResources.map((r2) => `${r2}`).join(" ");
  }
  let styleResources = "'self'";
  if (result.styleResources.length > 0) {
    styleResources = result.styleResources.map((r2) => `${r2}`).join(" ");
  }
  const strictDynamic = result.isStrictDynamic ? ` 'strict-dynamic'` : "";
  const scriptSrc = `script-src ${scriptResources} ${Array.from(finalScriptHashes).join(" ")}${strictDynamic};`;
  const styleSrc = `style-src ${styleResources} ${Array.from(finalStyleHashes).join(" ")};`;
  return [directives, scriptSrc, styleSrc].filter(Boolean).join(" ");
}
function createRenderInstruction(instruction) {
  return Object.defineProperty(instruction, RenderInstructionSymbol, {
    value: true
  });
}
function isRenderInstruction(chunk) {
  return chunk && typeof chunk === "object" && chunk[RenderInstructionSymbol];
}
function defineScriptVars(vars) {
  let output = "";
  for (const [key, value] of Object.entries(vars)) {
    output += `const ${toIdent(key)} = ${JSON.stringify(value)?.replace(
      /<\/script>/g,
      "\\x3C/script>"
    )};
`;
  }
  return markHTMLString(output);
}
function formatList(values) {
  if (values.length === 1) {
    return values[0];
  }
  return `${values.slice(0, -1).join(", ")} or ${values[values.length - 1]}`;
}
function isCustomElement(tagName) {
  return tagName.includes("-");
}
function handleBooleanAttribute(key, value, shouldEscape, tagName) {
  if (tagName && isCustomElement(tagName)) {
    return markHTMLString(` ${key}="${toAttributeString(value, shouldEscape)}"`);
  }
  return markHTMLString(value ? ` ${key}` : "");
}
function addAttribute(value, key, shouldEscape = true, tagName = "") {
  if (value == null) {
    return "";
  }
  if (STATIC_DIRECTIVES.has(key)) {
    console.warn(`[astro] The "${key}" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.

Make sure to use the static attribute syntax (\`${key}={value}\`) instead of the dynamic spread syntax (\`{...{ "${key}": value }}\`).`);
    return "";
  }
  if (key === "class:list") {
    const listValue = toAttributeString(clsx(value), shouldEscape);
    if (listValue === "") {
      return "";
    }
    return markHTMLString(` ${key.slice(0, -5)}="${listValue}"`);
  }
  if (key === "style" && !(value instanceof HTMLString)) {
    if (Array.isArray(value) && value.length === 2) {
      return markHTMLString(
        ` ${key}="${toAttributeString(`${toStyleString(value[0])};${value[1]}`, shouldEscape)}"`
      );
    }
    if (typeof value === "object") {
      return markHTMLString(` ${key}="${toAttributeString(toStyleString(value), shouldEscape)}"`);
    }
  }
  if (key === "className") {
    return markHTMLString(` class="${toAttributeString(value, shouldEscape)}"`);
  }
  if (typeof value === "string" && value.includes("&") && isHttpUrl(value)) {
    return markHTMLString(` ${key}="${toAttributeString(value, false)}"`);
  }
  if (htmlBooleanAttributes.test(key)) {
    return handleBooleanAttribute(key, value, shouldEscape, tagName);
  }
  if (value === "") {
    return markHTMLString(` ${key}`);
  }
  if (key === "popover" && typeof value === "boolean") {
    return handleBooleanAttribute(key, value, shouldEscape, tagName);
  }
  if (key === "download" && typeof value === "boolean") {
    return handleBooleanAttribute(key, value, shouldEscape, tagName);
  }
  return markHTMLString(` ${key}="${toAttributeString(value, shouldEscape)}"`);
}
function internalSpreadAttributes(values, shouldEscape = true, tagName) {
  let output = "";
  for (const [key, value] of Object.entries(values)) {
    output += addAttribute(value, key, shouldEscape, tagName);
  }
  return markHTMLString(output);
}
function renderElement$1(name, { props: _props, children = "" }, shouldEscape = true) {
  const { lang: _, "data-astro-id": astroId, "define:vars": defineVars, ...props } = _props;
  if (defineVars) {
    if (name === "style") {
      delete props["is:global"];
      delete props["is:scoped"];
    }
    if (name === "script") {
      delete props.hoist;
      children = defineScriptVars(defineVars) + "\n" + children;
    }
  }
  if ((children == null || children == "") && voidElementNames.test(name)) {
    return `<${name}${internalSpreadAttributes(props, shouldEscape, name)}>`;
  }
  return `<${name}${internalSpreadAttributes(props, shouldEscape, name)}>${children}</${name}>`;
}
function createBufferedRenderer(destination, renderFunction) {
  return new BufferedRenderer(destination, renderFunction);
}
function promiseWithResolvers() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return {
    promise,
    resolve,
    reject
  };
}
function isHttpUrl(url) {
  try {
    const parsedUrl = new URL(url);
    return VALID_PROTOCOLS.includes(parsedUrl.protocol);
  } catch {
    return false;
  }
}
function renderAllHeadContent(result) {
  result._metadata.hasRenderedHead = true;
  let content = "";
  if (result.shouldInjectCspMetaTags && result.cspDestination === "meta") {
    content += renderElement$1(
      "meta",
      {
        props: {
          "http-equiv": "content-security-policy",
          content: renderCspContent(result)
        },
        children: ""
      },
      false
    );
  }
  const styles = Array.from(result.styles).filter(uniqueElements).map(
    (style) => style.props.rel === "stylesheet" ? renderElement$1("link", style) : renderElement$1("style", style)
  );
  result.styles.clear();
  const scripts = Array.from(result.scripts).filter(uniqueElements).map((script) => {
    if (result.userAssetsBase) {
      script.props.src = (result.base === "/" ? "" : result.base) + result.userAssetsBase + script.props.src;
    }
    return renderElement$1("script", script, false);
  });
  const links = Array.from(result.links).filter(uniqueElements).map((link2) => renderElement$1("link", link2, false));
  content += styles.join("\n") + links.join("\n") + scripts.join("\n");
  if (result._metadata.extraHead.length > 0) {
    for (const part of result._metadata.extraHead) {
      content += part;
    }
  }
  return markHTMLString(content);
}
function renderHead() {
  return createRenderInstruction({ type: "head" });
}
function maybeRenderHead() {
  return createRenderInstruction({ type: "maybe-head" });
}
function encodeHexUpperCase(data) {
  let result = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    result += alphabetUpperCase[data[i2] >> 4];
    result += alphabetUpperCase[data[i2] & 15];
  }
  return result;
}
function decodeHex(data) {
  if (data.length % 2 !== 0) {
    throw new Error("Invalid hex string");
  }
  const result = new Uint8Array(data.length / 2);
  for (let i2 = 0; i2 < data.length; i2 += 2) {
    if (!(data[i2] in decodeMap)) {
      throw new Error("Invalid character");
    }
    if (!(data[i2 + 1] in decodeMap)) {
      throw new Error("Invalid character");
    }
    result[i2 / 2] |= decodeMap[data[i2]] << 4;
    result[i2 / 2] |= decodeMap[data[i2 + 1]];
  }
  return result;
}
function encodeBase64(bytes) {
  return encodeBase64_internal(bytes, base64Alphabet, EncodingPadding.Include);
}
function encodeBase64_internal(bytes, alphabet, padding) {
  let result = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2 += 3) {
    let buffer = 0;
    let bufferBitSize = 0;
    for (let j = 0; j < 3 && i2 + j < bytes.byteLength; j++) {
      buffer = buffer << 8 | bytes[i2 + j];
      bufferBitSize += 8;
    }
    for (let j = 0; j < 4; j++) {
      if (bufferBitSize >= 6) {
        result += alphabet[buffer >> bufferBitSize - 6 & 63];
        bufferBitSize -= 6;
      } else if (bufferBitSize > 0) {
        result += alphabet[buffer << 6 - bufferBitSize & 63];
        bufferBitSize = 0;
      } else if (padding === EncodingPadding.Include) {
        result += "=";
      }
    }
  }
  return result;
}
function decodeBase64(encoded) {
  return decodeBase64_internal(encoded, base64DecodeMap, DecodingPadding.Required);
}
function decodeBase64_internal(encoded, decodeMap2, padding) {
  const result = new Uint8Array(Math.ceil(encoded.length / 4) * 3);
  let totalBytes = 0;
  for (let i2 = 0; i2 < encoded.length; i2 += 4) {
    let chunk = 0;
    let bitsRead = 0;
    for (let j = 0; j < 4; j++) {
      if (padding === DecodingPadding.Required && encoded[i2 + j] === "=") {
        continue;
      }
      if (padding === DecodingPadding.Ignore && (i2 + j >= encoded.length || encoded[i2 + j] === "=")) {
        continue;
      }
      if (j > 0 && encoded[i2 + j - 1] === "=") {
        throw new Error("Invalid padding");
      }
      if (!(encoded[i2 + j] in decodeMap2)) {
        throw new Error("Invalid character");
      }
      chunk |= decodeMap2[encoded[i2 + j]] << (3 - j) * 6;
      bitsRead += 6;
    }
    if (bitsRead < 24) {
      let unused;
      if (bitsRead === 12) {
        unused = chunk & 65535;
      } else if (bitsRead === 18) {
        unused = chunk & 255;
      } else {
        throw new Error("Invalid padding");
      }
      if (unused !== 0) {
        throw new Error("Invalid padding");
      }
    }
    const byteLength = Math.floor(bitsRead / 8);
    for (let i3 = 0; i3 < byteLength; i3++) {
      result[totalBytes] = chunk >> 16 - i3 * 8 & 255;
      totalBytes++;
    }
  }
  return result.slice(0, totalBytes);
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message2 ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message2 ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
function mergeValues(a2, b) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b);
  if (a2 === b) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r2 = check2(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
async function decodeKey(encoded) {
  const bytes = decodeBase64(encoded);
  return crypto.subtle.importKey("raw", bytes.buffer, ALGORITHM, true, [
    "encrypt",
    "decrypt"
  ]);
}
async function encryptString(key, raw) {
  const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH / 2));
  const data = encoder$1.encode(raw);
  const buffer = await crypto.subtle.encrypt(
    {
      name: ALGORITHM,
      iv
    },
    key,
    data
  );
  return encodeHexUpperCase(iv) + encodeBase64(new Uint8Array(buffer));
}
async function decryptString(key, encoded) {
  const iv = decodeHex(encoded.slice(0, IV_LENGTH));
  const dataArray = decodeBase64(encoded.slice(IV_LENGTH));
  const decryptedBuffer = await crypto.subtle.decrypt(
    {
      name: ALGORITHM,
      iv
    },
    key,
    dataArray
  );
  const decryptedString = decoder$1.decode(decryptedBuffer);
  return decryptedString;
}
async function generateCspDigest(data, algorithm) {
  const hashBuffer = await crypto.subtle.digest(algorithm, encoder$1.encode(data));
  const hash2 = encodeBase64(new Uint8Array(hashBuffer));
  return `${ALGORITHMS[algorithm]}${hash2}`;
}
function isRenderTemplateResult(obj) {
  return typeof obj === "object" && obj !== null && !!obj[renderTemplateResultSym];
}
function renderTemplate(htmlParts, ...expressions) {
  return new RenderTemplateResult(htmlParts, expressions);
}
function isSlotString(str) {
  return !!str[slotString];
}
function renderSlot(result, slotted, fallback) {
  if (!slotted && fallback) {
    return renderSlot(result, fallback);
  }
  return {
    async render(destination) {
      await renderChild(destination, typeof slotted === "function" ? slotted(result) : slotted);
    }
  };
}
async function renderSlotToString(result, slotted, fallback) {
  let content = "";
  let instructions = null;
  const temporaryDestination = {
    write(chunk) {
      if (chunk instanceof SlotString) {
        content += chunk;
        if (chunk.instructions) {
          instructions ??= [];
          instructions.push(...chunk.instructions);
        }
      } else if (chunk instanceof Response) return;
      else if (typeof chunk === "object" && "type" in chunk && typeof chunk.type === "string") {
        if (instructions === null) {
          instructions = [];
        }
        instructions.push(chunk);
      } else {
        content += chunkToString(result, chunk);
      }
    }
  };
  const renderInstance = renderSlot(result, slotted, fallback);
  await renderInstance.render(temporaryDestination);
  return markHTMLString(new SlotString(content, instructions));
}
async function renderSlots(result, slots = {}) {
  let slotInstructions = null;
  let children = {};
  if (slots) {
    await Promise.all(
      Object.entries(slots).map(
        ([key, value]) => renderSlotToString(result, value).then((output) => {
          if (output.instructions) {
            if (slotInstructions === null) {
              slotInstructions = [];
            }
            slotInstructions.push(...output.instructions);
          }
          children[key] = output;
        })
      )
    );
  }
  return { slotInstructions, children };
}
function createSlotValueFromString(content) {
  return function() {
    return renderTemplate`${unescapeHTML(content)}`;
  };
}
function containsServerDirective(props) {
  return "server:component-directive" in props;
}
function safeJsonStringify(obj) {
  return JSON.stringify(obj).replace(SCRIPT_RE, SCRIPT_REPLACER).replace(COMMENT_RE, COMMENT_REPLACER);
}
function createSearchParams(componentExport, encryptedProps, slots) {
  const params = new URLSearchParams();
  params.set("e", componentExport);
  params.set("p", encryptedProps);
  params.set("s", slots);
  return params;
}
function isWithinURLLimit(pathname, params) {
  const url = pathname + "?" + params.toString();
  const chars = url.length;
  return chars < 2048;
}
function stringifyChunk(result, chunk) {
  if (isRenderInstruction(chunk)) {
    const instruction = chunk;
    switch (instruction.type) {
      case "directive": {
        const { hydration } = instruction;
        let needsHydrationScript = hydration && determineIfNeedsHydrationScript(result);
        let needsDirectiveScript = hydration && determinesIfNeedsDirectiveScript(result, hydration.directive);
        if (needsHydrationScript) {
          let prescripts = getPrescripts(result, "both", hydration.directive);
          return markHTMLString(prescripts);
        } else if (needsDirectiveScript) {
          let prescripts = getPrescripts(result, "directive", hydration.directive);
          return markHTMLString(prescripts);
        } else {
          return "";
        }
      }
      case "head": {
        if (result._metadata.hasRenderedHead || result.partial) {
          return "";
        }
        return renderAllHeadContent(result);
      }
      case "maybe-head": {
        if (result._metadata.hasRenderedHead || result._metadata.headInTree || result.partial) {
          return "";
        }
        return renderAllHeadContent(result);
      }
      case "renderer-hydration-script": {
        const { rendererSpecificHydrationScripts } = result._metadata;
        const { rendererName } = instruction;
        if (!rendererSpecificHydrationScripts.has(rendererName)) {
          rendererSpecificHydrationScripts.add(rendererName);
          return instruction.render();
        }
        return "";
      }
      case "server-island-runtime": {
        if (result._metadata.hasRenderedServerIslandRuntime) {
          return "";
        }
        result._metadata.hasRenderedServerIslandRuntime = true;
        return renderServerIslandRuntime();
      }
      default: {
        throw new Error(`Unknown chunk type: ${chunk.type}`);
      }
    }
  } else if (chunk instanceof Response) {
    return "";
  } else if (isSlotString(chunk)) {
    let out = "";
    const c = chunk;
    if (c.instructions) {
      for (const instr of c.instructions) {
        out += stringifyChunk(result, instr);
      }
    }
    out += chunk.toString();
    return out;
  }
  return chunk.toString();
}
function chunkToString(result, chunk) {
  if (ArrayBuffer.isView(chunk)) {
    return decoder.decode(chunk);
  } else {
    return stringifyChunk(result, chunk);
  }
}
function chunkToByteArray(result, chunk) {
  if (ArrayBuffer.isView(chunk)) {
    return chunk;
  } else {
    const stringified = stringifyChunk(result, chunk);
    return encoder.encode(stringified.toString());
  }
}
function isRenderInstance(obj) {
  return !!obj && typeof obj === "object" && "render" in obj && typeof obj.render === "function";
}
function renderChild(destination, child) {
  if (isPromise(child)) {
    return child.then((x) => renderChild(destination, x));
  }
  if (child instanceof SlotString) {
    destination.write(child);
    return;
  }
  if (isHTMLString(child)) {
    destination.write(child);
    return;
  }
  if (Array.isArray(child)) {
    return renderArray(destination, child);
  }
  if (typeof child === "function") {
    return renderChild(destination, child());
  }
  if (!child && child !== 0) {
    return;
  }
  if (typeof child === "string") {
    destination.write(markHTMLString(escapeHTML(child)));
    return;
  }
  if (isRenderInstance(child)) {
    return child.render(destination);
  }
  if (isRenderTemplateResult(child)) {
    return child.render(destination);
  }
  if (isAstroComponentInstance(child)) {
    return child.render(destination);
  }
  if (ArrayBuffer.isView(child)) {
    destination.write(child);
    return;
  }
  if (typeof child === "object" && (Symbol.asyncIterator in child || Symbol.iterator in child)) {
    if (Symbol.asyncIterator in child) {
      return renderAsyncIterable(destination, child);
    }
    return renderIterable(destination, child);
  }
  destination.write(child);
}
function renderArray(destination, children) {
  const flushers = children.map((c) => {
    return createBufferedRenderer(destination, (bufferDestination) => {
      return renderChild(bufferDestination, c);
    });
  });
  const iterator = flushers[Symbol.iterator]();
  const iterate = /* @__PURE__ */ __name(() => {
    for (; ; ) {
      const { value: flusher, done } = iterator.next();
      if (done) {
        break;
      }
      const result = flusher.flush();
      if (isPromise(result)) {
        return result.then(iterate);
      }
    }
  }, "iterate");
  return iterate();
}
function renderIterable(destination, children) {
  const iterator = children[Symbol.iterator]();
  const iterate = /* @__PURE__ */ __name(() => {
    for (; ; ) {
      const { value, done } = iterator.next();
      if (done) {
        break;
      }
      const result = renderChild(destination, value);
      if (isPromise(result)) {
        return result.then(iterate);
      }
    }
  }, "iterate");
  return iterate();
}
async function renderAsyncIterable(destination, children) {
  for await (const value of children) {
    await renderChild(destination, value);
  }
}
function validateComponentProps(props, clientDirectives, displayName) {
  if (props != null) {
    const directives = [...clientDirectives.keys()].map((directive) => `client:${directive}`);
    for (const prop of Object.keys(props)) {
      if (directives.includes(prop)) {
        console.warn(
          `You are attempting to render <${displayName} ${prop} />, but ${displayName} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`
        );
      }
    }
  }
}
function createAstroComponentInstance(result, displayName, factory, props, slots = {}) {
  validateComponentProps(props, result.clientDirectives, displayName);
  const instance = new AstroComponentInstance(result, props, slots, factory);
  if (isAPropagatingComponent(result, factory)) {
    result._metadata.propagators.add(instance);
  }
  return instance;
}
function isAstroComponentInstance(obj) {
  return typeof obj === "object" && obj !== null && !!obj[astroComponentInstanceSym];
}
async function renderToString(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response) return templateResult;
  let str = "";
  let renderedFirstPageChunk = false;
  if (isPage) {
    await bufferHeadContent(result);
  }
  const destination = {
    write(chunk) {
      if (isPage && !renderedFirstPageChunk) {
        renderedFirstPageChunk = true;
        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
          const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
          str += doctype;
        }
      }
      if (chunk instanceof Response) return;
      str += chunkToString(result, chunk);
    }
  };
  await templateResult.render(destination);
  return str;
}
async function renderToReadableStream(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response) return templateResult;
  let renderedFirstPageChunk = false;
  if (isPage) {
    await bufferHeadContent(result);
  }
  return new ReadableStream({
    start(controller) {
      const destination = {
        write(chunk) {
          if (isPage && !renderedFirstPageChunk) {
            renderedFirstPageChunk = true;
            if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
              const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
              controller.enqueue(encoder.encode(doctype));
            }
          }
          if (chunk instanceof Response) {
            throw new AstroError({
              ...ResponseSentError
            });
          }
          const bytes = chunkToByteArray(result, chunk);
          controller.enqueue(bytes);
        }
      };
      (async () => {
        try {
          await templateResult.render(destination);
          controller.close();
        } catch (e2) {
          if (AstroError.is(e2) && !e2.loc) {
            e2.setLocation({
              file: route?.component
            });
          }
          setTimeout(() => controller.error(e2), 0);
        }
      })();
    },
    cancel() {
      result.cancelled = true;
    }
  });
}
async function callComponentAsTemplateResultOrResponse(result, componentFactory, props, children, route) {
  const factoryResult = await componentFactory(result, props, children);
  if (factoryResult instanceof Response) {
    return factoryResult;
  } else if (isHeadAndContent(factoryResult)) {
    if (!isRenderTemplateResult(factoryResult.content)) {
      throw new AstroError({
        ...OnlyResponseCanBeReturned,
        message: OnlyResponseCanBeReturned.message(
          route?.route,
          typeof factoryResult
        ),
        location: {
          file: route?.component
        }
      });
    }
    return factoryResult.content;
  } else if (!isRenderTemplateResult(factoryResult)) {
    throw new AstroError({
      ...OnlyResponseCanBeReturned,
      message: OnlyResponseCanBeReturned.message(route?.route, typeof factoryResult),
      location: {
        file: route?.component
      }
    });
  }
  return factoryResult;
}
async function bufferHeadContent(result) {
  const iterator = result._metadata.propagators.values();
  while (true) {
    const { value, done } = iterator.next();
    if (done) {
      break;
    }
    const returnValue = await value.init(result);
    if (isHeadAndContent(returnValue) && returnValue.head) {
      result._metadata.extraHead.push(returnValue.head);
    }
  }
}
async function renderToAsyncIterable(result, componentFactory, props, children, isPage = false, route) {
  const templateResult = await callComponentAsTemplateResultOrResponse(
    result,
    componentFactory,
    props,
    children,
    route
  );
  if (templateResult instanceof Response) return templateResult;
  let renderedFirstPageChunk = false;
  if (isPage) {
    await bufferHeadContent(result);
  }
  let error5 = null;
  let next = null;
  const buffer = [];
  let renderingComplete = false;
  const iterator = {
    async next() {
      if (result.cancelled) return { done: true, value: void 0 };
      if (next !== null) {
        await next.promise;
      } else if (!renderingComplete && !buffer.length) {
        next = promiseWithResolvers();
        await next.promise;
      }
      if (!renderingComplete) {
        next = promiseWithResolvers();
      }
      if (error5) {
        throw error5;
      }
      let length = 0;
      for (let i2 = 0, len = buffer.length; i2 < len; i2++) {
        length += buffer[i2].length;
      }
      let mergedArray = new Uint8Array(length);
      let offset = 0;
      for (let i2 = 0, len = buffer.length; i2 < len; i2++) {
        const item = buffer[i2];
        mergedArray.set(item, offset);
        offset += item.length;
      }
      buffer.length = 0;
      const returnValue = {
        // The iterator is done when rendering has finished
        // and there are no more chunks to return.
        done: length === 0 && renderingComplete,
        value: mergedArray
      };
      return returnValue;
    },
    async return() {
      result.cancelled = true;
      return { done: true, value: void 0 };
    }
  };
  const destination = {
    write(chunk) {
      if (isPage && !renderedFirstPageChunk) {
        renderedFirstPageChunk = true;
        if (!result.partial && !DOCTYPE_EXP.test(String(chunk))) {
          const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
          buffer.push(encoder.encode(doctype));
        }
      }
      if (chunk instanceof Response) {
        throw new AstroError(ResponseSentError);
      }
      const bytes = chunkToByteArray(result, chunk);
      if (bytes.length > 0) {
        buffer.push(bytes);
        next?.resolve();
      } else if (buffer.length > 0) {
        next?.resolve();
      }
    }
  };
  const renderResult = toPromise(() => templateResult.render(destination));
  renderResult.catch((err) => {
    error5 = err;
  }).finally(() => {
    renderingComplete = true;
    next?.resolve();
  });
  return {
    [Symbol.asyncIterator]() {
      return iterator;
    }
  };
}
function toPromise(fn) {
  try {
    const result = fn();
    return isPromise(result) ? result : Promise.resolve(result);
  } catch (err) {
    return Promise.reject(err);
  }
}
function componentIsHTMLElement(Component) {
  return typeof HTMLElement !== "undefined" && HTMLElement.isPrototypeOf(Component);
}
async function renderHTMLElement(result, constructor, props, slots) {
  const name = getHTMLElementName(constructor);
  let attrHTML = "";
  for (const attr in props) {
    attrHTML += ` ${attr}="${toAttributeString(await props[attr])}"`;
  }
  return markHTMLString(
    `<${name}${attrHTML}>${await renderSlotToString(result, slots?.default)}</${name}>`
  );
}
function getHTMLElementName(constructor) {
  const definedName = customElements.getName(constructor);
  if (definedName) return definedName;
  const assignedName = constructor.name.replace(/^HTML|Element$/g, "").replace(/[A-Z]/g, "-$&").toLowerCase().replace(/^-/, "html-");
  return assignedName;
}
function guessRenderers(componentUrl) {
  const extname = componentUrl?.split(".").pop();
  switch (extname) {
    case "svelte":
      return ["@astrojs/svelte"];
    case "vue":
      return ["@astrojs/vue"];
    case "jsx":
    case "tsx":
      return ["@astrojs/react", "@astrojs/preact", "@astrojs/solid-js", "@astrojs/vue (jsx)"];
    case void 0:
    default:
      return [
        "@astrojs/react",
        "@astrojs/preact",
        "@astrojs/solid-js",
        "@astrojs/vue",
        "@astrojs/svelte"
      ];
  }
}
function isFragmentComponent(Component) {
  return Component === Fragment;
}
function isHTMLComponent(Component) {
  return Component && Component["astro:html"] === true;
}
function removeStaticAstroSlot(html, supportsAstroStaticSlot = true) {
  const exp = supportsAstroStaticSlot ? ASTRO_STATIC_SLOT_EXP : ASTRO_SLOT_EXP;
  return html.replace(exp, "");
}
async function renderFrameworkComponent(result, displayName, Component, _props, slots = {}) {
  if (!Component && "client:only" in _props === false) {
    throw new Error(
      `Unable to render ${displayName} because it is ${Component}!
Did you forget to import the component or is it possible there is a typo?`
    );
  }
  const { renderers: renderers2, clientDirectives } = result;
  const metadata = {
    astroStaticSlot: true,
    displayName
  };
  const { hydration, isPage, props, propsWithoutTransitionAttributes } = extractDirectives(
    _props,
    clientDirectives
  );
  let html = "";
  let attrs = void 0;
  if (hydration) {
    metadata.hydrate = hydration.directive;
    metadata.hydrateArgs = hydration.value;
    metadata.componentExport = hydration.componentExport;
    metadata.componentUrl = hydration.componentUrl;
  }
  const probableRendererNames = guessRenderers(metadata.componentUrl);
  const validRenderers = renderers2.filter((r2) => r2.name !== "astro:jsx");
  const { children, slotInstructions } = await renderSlots(result, slots);
  let renderer2;
  if (metadata.hydrate !== "only") {
    let isTagged = false;
    try {
      isTagged = Component && Component[Renderer];
    } catch {
    }
    if (isTagged) {
      const rendererName = Component[Renderer];
      renderer2 = renderers2.find(({ name }) => name === rendererName);
    }
    if (!renderer2) {
      let error5;
      for (const r2 of renderers2) {
        try {
          if (await r2.ssr.check.call({ result }, Component, props, children)) {
            renderer2 = r2;
            break;
          }
        } catch (e2) {
          error5 ??= e2;
        }
      }
      if (!renderer2 && error5) {
        throw error5;
      }
    }
    if (!renderer2 && typeof HTMLElement === "function" && componentIsHTMLElement(Component)) {
      const output = await renderHTMLElement(
        result,
        Component,
        _props,
        slots
      );
      return {
        render(destination) {
          destination.write(output);
        }
      };
    }
  } else {
    if (metadata.hydrateArgs) {
      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;
      if (clientOnlyValues.has(rendererName)) {
        renderer2 = renderers2.find(
          ({ name }) => name === `@astrojs/${rendererName}` || name === rendererName
        );
      }
    }
    if (!renderer2 && validRenderers.length === 1) {
      renderer2 = validRenderers[0];
    }
    if (!renderer2) {
      const extname = metadata.componentUrl?.split(".").pop();
      renderer2 = renderers2.find(({ name }) => name === `@astrojs/${extname}` || name === extname);
    }
  }
  if (!renderer2) {
    if (metadata.hydrate === "only") {
      const rendererName = rendererAliases.has(metadata.hydrateArgs) ? rendererAliases.get(metadata.hydrateArgs) : metadata.hydrateArgs;
      if (clientOnlyValues.has(rendererName)) {
        const plural = validRenderers.length > 1;
        throw new AstroError({
          ...NoMatchingRenderer,
          message: NoMatchingRenderer.message(
            metadata.displayName,
            metadata?.componentUrl?.split(".").pop(),
            plural,
            validRenderers.length
          ),
          hint: NoMatchingRenderer.hint(
            formatList(probableRendererNames.map((r2) => "`" + r2 + "`"))
          )
        });
      } else {
        throw new AstroError({
          ...NoClientOnlyHint,
          message: NoClientOnlyHint.message(metadata.displayName),
          hint: NoClientOnlyHint.hint(
            probableRendererNames.map((r2) => r2.replace("@astrojs/", "")).join("|")
          )
        });
      }
    } else if (typeof Component !== "string") {
      const matchingRenderers = validRenderers.filter(
        (r2) => probableRendererNames.includes(r2.name)
      );
      const plural = validRenderers.length > 1;
      if (matchingRenderers.length === 0) {
        throw new AstroError({
          ...NoMatchingRenderer,
          message: NoMatchingRenderer.message(
            metadata.displayName,
            metadata?.componentUrl?.split(".").pop(),
            plural,
            validRenderers.length
          ),
          hint: NoMatchingRenderer.hint(
            formatList(probableRendererNames.map((r2) => "`" + r2 + "`"))
          )
        });
      } else if (matchingRenderers.length === 1) {
        renderer2 = matchingRenderers[0];
        ({ html, attrs } = await renderer2.ssr.renderToStaticMarkup.call(
          { result },
          Component,
          propsWithoutTransitionAttributes,
          children,
          metadata
        ));
      } else {
        throw new Error(`Unable to render ${metadata.displayName}!

This component likely uses ${formatList(probableRendererNames)},
but Astro encountered an error during server-side rendering.

Please ensure that ${metadata.displayName}:
1. Does not unconditionally access browser-specific globals like \`window\` or \`document\`.
   If this is unavoidable, use the \`client:only\` hydration directive.
2. Does not conditionally return \`null\` or \`undefined\` when rendered on the server.

If you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);
      }
    }
  } else {
    if (metadata.hydrate === "only") {
      html = await renderSlotToString(result, slots?.fallback);
    } else {
      performance.now();
      ({ html, attrs } = await renderer2.ssr.renderToStaticMarkup.call(
        { result },
        Component,
        propsWithoutTransitionAttributes,
        children,
        metadata
      ));
    }
  }
  if (!html && typeof Component === "string") {
    const Tag = sanitizeElementName(Component);
    const childSlots = Object.values(children).join("");
    const renderTemplateResult = renderTemplate`<${Tag}${internalSpreadAttributes(
      props,
      true,
      Tag
    )}${markHTMLString(
      childSlots === "" && voidElementNames.test(Tag) ? `/>` : `>${childSlots}</${Tag}>`
    )}`;
    html = "";
    const destination = {
      write(chunk) {
        if (chunk instanceof Response) return;
        html += chunkToString(result, chunk);
      }
    };
    await renderTemplateResult.render(destination);
  }
  if (!hydration) {
    return {
      render(destination) {
        if (slotInstructions) {
          for (const instruction of slotInstructions) {
            destination.write(instruction);
          }
        }
        if (isPage || renderer2?.name === "astro:jsx") {
          destination.write(html);
        } else if (html && html.length > 0) {
          destination.write(
            markHTMLString(removeStaticAstroSlot(html, renderer2?.ssr?.supportsAstroStaticSlot))
          );
        }
      }
    };
  }
  const astroId = shorthash(
    `<!--${metadata.componentExport.value}:${metadata.componentUrl}-->
${html}
${serializeProps(
      props,
      metadata
    )}`
  );
  const island = await generateHydrateScript(
    { renderer: renderer2, result, astroId, props, attrs },
    metadata
  );
  let unrenderedSlots = [];
  if (html) {
    if (Object.keys(children).length > 0) {
      for (const key of Object.keys(children)) {
        let tagName = renderer2?.ssr?.supportsAstroStaticSlot ? !!metadata.hydrate ? "astro-slot" : "astro-static-slot" : "astro-slot";
        let expectedHTML = key === "default" ? `<${tagName}>` : `<${tagName} name="${key}">`;
        if (!html.includes(expectedHTML)) {
          unrenderedSlots.push(key);
        }
      }
    }
  } else {
    unrenderedSlots = Object.keys(children);
  }
  const template2 = unrenderedSlots.length > 0 ? unrenderedSlots.map(
    (key) => `<template data-astro-template${key !== "default" ? `="${key}"` : ""}>${children[key]}</template>`
  ).join("") : "";
  island.children = `${html ?? ""}${template2}`;
  if (island.children) {
    island.props["await-children"] = "";
    island.children += `<!--astro:end-->`;
  }
  return {
    render(destination) {
      if (slotInstructions) {
        for (const instruction of slotInstructions) {
          destination.write(instruction);
        }
      }
      destination.write(createRenderInstruction({ type: "directive", hydration }));
      if (hydration.directive !== "only" && renderer2?.ssr.renderHydrationScript) {
        destination.write(
          createRenderInstruction({
            type: "renderer-hydration-script",
            rendererName: renderer2.name,
            render: renderer2.ssr.renderHydrationScript
          })
        );
      }
      const renderedElement = renderElement$1("astro-island", island, false);
      destination.write(markHTMLString(renderedElement));
    }
  };
}
function sanitizeElementName(tag2) {
  const unsafe = /[&<>'"\s]+/;
  if (!unsafe.test(tag2)) return tag2;
  return tag2.trim().split(unsafe)[0].trim();
}
async function renderFragmentComponent(result, slots = {}) {
  const children = await renderSlotToString(result, slots?.default);
  return {
    render(destination) {
      if (children == null) return;
      destination.write(children);
    }
  };
}
async function renderHTMLComponent(result, Component, _props, slots = {}) {
  const { slotInstructions, children } = await renderSlots(result, slots);
  const html = Component({ slots: children });
  const hydrationHtml = slotInstructions ? slotInstructions.map((instr) => chunkToString(result, instr)).join("") : "";
  return {
    render(destination) {
      destination.write(markHTMLString(hydrationHtml + html));
    }
  };
}
function renderAstroComponent(result, displayName, Component, props, slots = {}) {
  if (containsServerDirective(props)) {
    const serverIslandComponent = new ServerIslandComponent(result, props, slots, displayName);
    result._metadata.propagators.add(serverIslandComponent);
    return serverIslandComponent;
  }
  const instance = createAstroComponentInstance(result, displayName, Component, props, slots);
  return {
    render(destination) {
      return instance.render(destination);
    }
  };
}
function renderComponent(result, displayName, Component, props, slots = {}) {
  if (isPromise(Component)) {
    return Component.catch(handleCancellation).then((x) => {
      return renderComponent(result, displayName, x, props, slots);
    });
  }
  if (isFragmentComponent(Component)) {
    return renderFragmentComponent(result, slots).catch(handleCancellation);
  }
  props = normalizeProps(props);
  if (isHTMLComponent(Component)) {
    return renderHTMLComponent(result, Component, props, slots).catch(handleCancellation);
  }
  if (isAstroComponentFactory(Component)) {
    return renderAstroComponent(result, displayName, Component, props, slots);
  }
  return renderFrameworkComponent(result, displayName, Component, props, slots).catch(
    handleCancellation
  );
  function handleCancellation(e2) {
    if (result.cancelled)
      return {
        render() {
        }
      };
    throw e2;
  }
  __name(handleCancellation, "handleCancellation");
}
function normalizeProps(props) {
  if (props["class:list"] !== void 0) {
    const value = props["class:list"];
    delete props["class:list"];
    props["class"] = clsx(props["class"], value);
    if (props["class"] === "") {
      delete props["class"];
    }
  }
  return props;
}
async function renderComponentToString(result, displayName, Component, props, slots = {}, isPage = false, route) {
  let str = "";
  let renderedFirstPageChunk = false;
  let head = "";
  if (isPage && !result.partial && nonAstroPageNeedsHeadInjection(Component)) {
    head += chunkToString(result, maybeRenderHead());
  }
  try {
    const destination = {
      write(chunk) {
        if (isPage && !result.partial && !renderedFirstPageChunk) {
          renderedFirstPageChunk = true;
          if (!/<!doctype html/i.test(String(chunk))) {
            const doctype = result.compressHTML ? "<!DOCTYPE html>" : "<!DOCTYPE html>\n";
            str += doctype + head;
          }
        }
        if (chunk instanceof Response) return;
        str += chunkToString(result, chunk);
      }
    };
    const renderInstance = await renderComponent(result, displayName, Component, props, slots);
    if (containsServerDirective(props)) {
      await bufferHeadContent(result);
    }
    await renderInstance.render(destination);
  } catch (e2) {
    if (AstroError.is(e2) && !e2.loc) {
      e2.setLocation({
        file: route?.component
      });
    }
    throw e2;
  }
  return str;
}
function nonAstroPageNeedsHeadInjection(pageComponent) {
  return !!pageComponent?.[needsHeadRenderingSymbol];
}
async function renderJSX(result, vnode) {
  switch (true) {
    case vnode instanceof HTMLString:
      if (vnode.toString().trim() === "") {
        return "";
      }
      return vnode;
    case typeof vnode === "string":
      return markHTMLString(escapeHTML(vnode));
    case typeof vnode === "function":
      return vnode;
    case (!vnode && vnode !== 0):
      return "";
    case Array.isArray(vnode):
      return markHTMLString(
        (await Promise.all(vnode.map((v) => renderJSX(result, v)))).join("")
      );
  }
  return renderJSXVNode(result, vnode);
}
async function renderJSXVNode(result, vnode) {
  if (isVNode(vnode)) {
    switch (true) {
      case !vnode.type: {
        throw new Error(`Unable to render ${result.pathname} because it contains an undefined Component!
Did you forget to import the component or is it possible there is a typo?`);
      }
      case vnode.type === Symbol.for("astro:fragment"):
        return renderJSX(result, vnode.props.children);
      case isAstroComponentFactory(vnode.type): {
        let props = {};
        let slots = {};
        for (const [key, value] of Object.entries(vnode.props ?? {})) {
          if (key === "children" || value && typeof value === "object" && value["$$slot"]) {
            slots[key === "children" ? "default" : key] = () => renderJSX(result, value);
          } else {
            props[key] = value;
          }
        }
        const str = await renderComponentToString(
          result,
          vnode.type.name,
          vnode.type,
          props,
          slots
        );
        const html = markHTMLString(str);
        return html;
      }
      case (!vnode.type && vnode.type !== 0):
        return "";
      case (typeof vnode.type === "string" && vnode.type !== ClientOnlyPlaceholder):
        return markHTMLString(await renderElement(result, vnode.type, vnode.props ?? {}));
    }
    if (vnode.type) {
      let extractSlots2 = /* @__PURE__ */ __name(function(child) {
        if (Array.isArray(child)) {
          return child.map((c) => extractSlots2(c));
        }
        if (!isVNode(child)) {
          _slots.default.push(child);
          return;
        }
        if ("slot" in child.props) {
          _slots[child.props.slot] = [..._slots[child.props.slot] ?? [], child];
          delete child.props.slot;
          return;
        }
        _slots.default.push(child);
      }, "extractSlots2");
      if (typeof vnode.type === "function" && vnode.props["server:root"]) {
        const output2 = await vnode.type(vnode.props ?? {});
        return await renderJSX(result, output2);
      }
      if (typeof vnode.type === "function") {
        if (vnode.props[hasTriedRenderComponentSymbol]) {
          delete vnode.props[hasTriedRenderComponentSymbol];
          const output2 = await vnode.type(vnode.props ?? {});
          if (output2?.[AstroJSX] || !output2) {
            return await renderJSXVNode(result, output2);
          } else {
            return;
          }
        } else {
          vnode.props[hasTriedRenderComponentSymbol] = true;
        }
      }
      const { children = null, ...props } = vnode.props ?? {};
      const _slots = {
        default: []
      };
      extractSlots2(children);
      for (const [key, value] of Object.entries(props)) {
        if (value?.["$$slot"]) {
          _slots[key] = value;
          delete props[key];
        }
      }
      const slotPromises = [];
      const slots = {};
      for (const [key, value] of Object.entries(_slots)) {
        slotPromises.push(
          renderJSX(result, value).then((output2) => {
            if (output2.toString().trim().length === 0) return;
            slots[key] = () => output2;
          })
        );
      }
      await Promise.all(slotPromises);
      let output;
      if (vnode.type === ClientOnlyPlaceholder && vnode.props["client:only"]) {
        output = await renderComponentToString(
          result,
          vnode.props["client:display-name"] ?? "",
          null,
          props,
          slots
        );
      } else {
        output = await renderComponentToString(
          result,
          typeof vnode.type === "function" ? vnode.type.name : vnode.type,
          vnode.type,
          props,
          slots
        );
      }
      return markHTMLString(output);
    }
  }
  return markHTMLString(`${vnode}`);
}
async function renderElement(result, tag2, { children, ...props }) {
  return markHTMLString(
    `<${tag2}${spreadAttributes(props)}${markHTMLString(
      (children == null || children == "") && voidElementNames.test(tag2) ? `/>` : `>${children == null ? "" : await renderJSX(result, prerenderElementChildren(tag2, children))}</${tag2}>`
    )}`
  );
}
function prerenderElementChildren(tag2, children) {
  if (typeof children === "string" && (tag2 === "style" || tag2 === "script")) {
    return markHTMLString(children);
  } else {
    return children;
  }
}
async function renderPage(result, componentFactory, props, children, streaming, route) {
  if (!isAstroComponentFactory(componentFactory)) {
    result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;
    const pageProps = { ...props ?? {}, "server:root": true };
    const str = await renderComponentToString(
      result,
      componentFactory.name,
      componentFactory,
      pageProps,
      {},
      true,
      route
    );
    const bytes = encoder.encode(str);
    const headers2 = new Headers([
      ["Content-Type", "text/html"],
      ["Content-Length", bytes.byteLength.toString()]
    ]);
    if (result.shouldInjectCspMetaTags && (result.cspDestination === "header" || result.cspDestination === "adapter")) {
      headers2.set("content-security-policy", renderCspContent(result));
    }
    return new Response(bytes, {
      headers: headers2
    });
  }
  result._metadata.headInTree = result.componentMetadata.get(componentFactory.moduleId)?.containsHead ?? false;
  let body;
  if (streaming) {
    if (isNode && !isDeno) {
      const nodeBody = await renderToAsyncIterable(
        result,
        componentFactory,
        props,
        children,
        true,
        route
      );
      body = nodeBody;
    } else {
      body = await renderToReadableStream(result, componentFactory, props, children, true, route);
    }
  } else {
    body = await renderToString(result, componentFactory, props, children, true, route);
  }
  if (body instanceof Response) return body;
  const init = result.response;
  const headers = new Headers(init.headers);
  if (result.shouldInjectCspMetaTags && result.cspDestination === "header" || result.cspDestination === "adapter") {
    headers.set("content-security-policy", renderCspContent(result));
  }
  if (!streaming && typeof body === "string") {
    body = encoder.encode(body);
    headers.set("Content-Length", body.byteLength.toString());
  }
  let status = init.status;
  let statusText = init.statusText;
  if (route?.route === "/404") {
    status = 404;
    if (statusText === "OK") {
      statusText = "Not Found";
    }
  } else if (route?.route === "/500") {
    status = 500;
    if (statusText === "OK") {
      statusText = "Internal Server Error";
    }
  }
  if (status) {
    return new Response(body, { ...init, headers, status, statusText });
  } else {
    return new Response(body, { ...init, headers });
  }
}
async function renderScript(result, id) {
  if (result._metadata.renderedScripts.has(id)) return;
  result._metadata.renderedScripts.add(id);
  const inlined = result.inlinedScripts.get(id);
  if (inlined != null) {
    if (inlined) {
      return markHTMLString(`<script type="module">${inlined}<\/script>`);
    } else {
      return "";
    }
  }
  const resolved = await result.resolve(id);
  return markHTMLString(
    `<script type="module" src="${result.userAssetsBase ? (result.base === "/" ? "" : result.base) + result.userAssetsBase : ""}${resolved}"><\/script>`
  );
}
function requireCssesc() {
  if (hasRequiredCssesc) return cssesc_1;
  hasRequiredCssesc = 1;
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var merge = /* @__PURE__ */ __name(function merge2(options, defaults) {
    if (!options) {
      return defaults;
    }
    var result = {};
    for (var key in defaults) {
      result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
    }
    return result;
  }, "merge");
  var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
  var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
  var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
  var cssesc = /* @__PURE__ */ __name(function cssesc2(string, options) {
    options = merge(options, cssesc2.options);
    if (options.quotes != "single" && options.quotes != "double") {
      options.quotes = "single";
    }
    var quote = options.quotes == "double" ? '"' : "'";
    var isIdentifier = options.isIdentifier;
    var firstChar = string.charAt(0);
    var output = "";
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var character = string.charAt(counter++);
      var codePoint = character.charCodeAt();
      var value = void 0;
      if (codePoint < 32 || codePoint > 126) {
        if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
          } else {
            counter--;
          }
        }
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else {
        if (options.escapeEverything) {
          if (regexAnySingleEscape.test(character)) {
            value = "\\" + character;
          } else {
            value = "\\" + codePoint.toString(16).toUpperCase() + " ";
          }
        } else if (/[\t\n\f\r\x0B]/.test(character)) {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = character;
        }
      }
      output += value;
    }
    if (isIdentifier) {
      if (/^-[-\d]/.test(output)) {
        output = "\\-" + output.slice(1);
      } else if (/\d/.test(firstChar)) {
        output = "\\3" + firstChar + " " + output.slice(1);
      }
    }
    output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
      if ($1 && $1.length % 2) {
        return $0;
      }
      return ($1 || "") + $2;
    });
    if (!isIdentifier && options.wrap) {
      return quote + output + quote;
    }
    return output;
  }, "cssesc");
  cssesc.options = {
    "escapeEverything": false,
    "isIdentifier": false,
    "quotes": "single",
    "wrap": false
  };
  cssesc.version = "3.0.0";
  cssesc_1 = cssesc;
  return cssesc_1;
}
function spreadAttributes(values = {}, _name, { class: scopedClassName } = {}) {
  let output = "";
  if (scopedClassName) {
    if (typeof values.class !== "undefined") {
      values.class += ` ${scopedClassName}`;
    } else if (typeof values["class:list"] !== "undefined") {
      values["class:list"] = [values["class:list"], scopedClassName];
    } else {
      values.class = scopedClassName;
    }
  }
  for (const [key, value] of Object.entries(values)) {
    output += addAttribute(value, key, true, _name);
  }
  return markHTMLString(output);
}
var MessagePort4, MessageChannelPolyfill3, ASTRO_VERSION, REROUTE_DIRECTIVE_HEADER, REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE, NOOP_MIDDLEWARE_HEADER, ROUTE_TYPE_HEADER, DEFAULT_404_COMPONENT, REDIRECT_STATUS_CODES, REROUTABLE_STATUS_CODES, clientAddressSymbol, originPathnameSymbol, responseSentSymbol, AstroError, ClientAddressNotAvailable, PrerenderClientAddressNotAvailable, StaticClientAddressNotAvailable, NoMatchingStaticPathFound, OnlyResponseCanBeReturned, MissingMediaQueryDirective, NoMatchingRenderer, NoClientOnlyHint, InvalidGetStaticPathsEntry, InvalidGetStaticPathsReturn, GetStaticPathsExpectedParams, GetStaticPathsInvalidRouteParam, GetStaticPathsRequired, ReservedSlotName, NoMatchingImport, InvalidComponentArgs, PageNumberParamNotFound, ImageMissingAlt, InvalidImageService, MissingImageDimension, FailedToFetchRemoteImageDimensions, UnsupportedImageFormat, UnsupportedImageConversion, PrerenderDynamicEndpointPathCollide, ExpectedImage, ExpectedImageOptions, ExpectedNotESMImage, IncompatibleDescriptorOptions, NoImageMetadata, ResponseSentError, MiddlewareNoDataOrNextCalled, MiddlewareNotAResponse, EndpointDidNotReturnAResponse, LocalsNotAnObject, LocalsReassigned, AstroResponseHeadersReassigned, LocalImageUsedWrongly, AstroGlobUsedOutside, AstroGlobNoMatch, MissingSharp, i18nNoLocaleFoundInPath, RewriteWithBodyUsed, ForbiddenRewrite, ExperimentalFontsNotEnabled, FontFamilyNotFound, CspNotEnabled, ActionsReturnedInvalidDataError, ActionNotFoundError, SessionStorageInitError, SessionStorageSaveError, e, t, n, r$1, i, a, o, s, replace, ca, esca, pe, escape, escapeHTML, HTMLBytes, HTMLString, markHTMLString, AstroJSX, PROP_TYPE, transitionDirectivesToCopyOnIsland, dictionary, binary, headAndContentSym, astro_island_prebuilt_default, ISLAND_STYLES, RenderInstructionSymbol, voidElementNames, htmlBooleanAttributes, AMPERSAND_REGEX, DOUBLE_QUOTE_REGEX, STATIC_DIRECTIVES, toIdent, toAttributeString, kebab, toStyleString, noop, BufferedRenderer, isNode, isDeno, VALID_PROTOCOLS, uniqueElements, alphabetUpperCase, decodeMap, EncodingPadding$1, DecodingPadding$1, base64Alphabet, EncodingPadding, DecodingPadding, base64DecodeMap, util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, ZodError, errorMap, overrideErrorMap, makeIssue, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, ZodIntersection, ZodTuple, ZodMap, ZodSet, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, ZodBranded, ZodPipeline, ZodReadonly, ZodFirstPartyTypeKind, enumType, ALGORITHMS, ALGORITHM_VALUES, ALLOWED_DIRECTIVES, ALGORITHM, encoder$1, decoder$1, IV_LENGTH, renderTemplateResultSym, RenderTemplateResult, slotString, SlotString, internalProps, SCRIPT_RE, COMMENT_RE, SCRIPT_REPLACER, COMMENT_REPLACER, ServerIslandComponent, renderServerIslandRuntime, SERVER_ISLAND_REPLACER, Fragment, Renderer, encoder, decoder, astroComponentInstanceSym, AstroComponentInstance, DOCTYPE_EXP, needsHeadRenderingSymbol, rendererAliases, clientOnlyValues, ASTRO_SLOT_EXP, ASTRO_STATIC_SLOT_EXP, ClientOnlyPlaceholder, hasTriedRenderComponentSymbol, cssesc_1, hasRequiredCssesc;
var init_server_B79ahsw9 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/astro/server_B79ahsw9.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
    ASTRO_VERSION = "5.16.6";
    REROUTE_DIRECTIVE_HEADER = "X-Astro-Reroute";
    REWRITE_DIRECTIVE_HEADER_KEY = "X-Astro-Rewrite";
    REWRITE_DIRECTIVE_HEADER_VALUE = "yes";
    NOOP_MIDDLEWARE_HEADER = "X-Astro-Noop";
    ROUTE_TYPE_HEADER = "X-Astro-Route-Type";
    DEFAULT_404_COMPONENT = "astro-default-404.astro";
    REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308, 300, 304];
    REROUTABLE_STATUS_CODES = [404, 500];
    clientAddressSymbol = Symbol.for("astro.clientAddress");
    originPathnameSymbol = Symbol.for("astro.originPathname");
    responseSentSymbol = Symbol.for("astro.responseSent");
    __name(normalizeLF, "normalizeLF");
    __name(codeFrame, "codeFrame");
    AstroError = class extends Error {
      static {
        __name(this, "AstroError");
      }
      loc;
      title;
      hint;
      frame;
      type = "AstroError";
      constructor(props, options) {
        const { name, title: title3, message: message2, stack, location, hint, frame } = props;
        super(message2, options);
        this.title = title3;
        this.name = name;
        if (message2) this.message = message2;
        this.stack = stack ? stack : this.stack;
        this.loc = location;
        this.hint = hint;
        this.frame = frame;
      }
      setLocation(location) {
        this.loc = location;
      }
      setName(name) {
        this.name = name;
      }
      setMessage(message2) {
        this.message = message2;
      }
      setHint(hint) {
        this.hint = hint;
      }
      setFrame(source, location) {
        this.frame = codeFrame(source, location);
      }
      static is(err) {
        return err?.type === "AstroError";
      }
    };
    ClientAddressNotAvailable = {
      name: "ClientAddressNotAvailable",
      title: "`Astro.clientAddress` is not available in current adapter.",
      message: /* @__PURE__ */ __name((adapterName) => `\`Astro.clientAddress\` is not available in the \`${adapterName}\` adapter. File an issue with the adapter to add support.`, "message")
    };
    PrerenderClientAddressNotAvailable = {
      name: "PrerenderClientAddressNotAvailable",
      title: "`Astro.clientAddress` cannot be used inside prerendered routes.",
      message: /* @__PURE__ */ __name((name) => `\`Astro.clientAddress\` cannot be used inside prerendered route ${name}`, "message")
    };
    StaticClientAddressNotAvailable = {
      name: "StaticClientAddressNotAvailable",
      title: "`Astro.clientAddress` is not available in prerendered pages.",
      message: "`Astro.clientAddress` is only available on pages that are server-rendered.",
      hint: "See https://docs.astro.build/en/guides/on-demand-rendering/ for more information on how to enable SSR."
    };
    NoMatchingStaticPathFound = {
      name: "NoMatchingStaticPathFound",
      title: "No static path found for requested path.",
      message: /* @__PURE__ */ __name((pathName) => `A \`getStaticPaths()\` route pattern was matched, but no matching static path was found for requested path \`${pathName}\`.`, "message"),
      hint: /* @__PURE__ */ __name((possibleRoutes) => `Possible dynamic routes being matched: ${possibleRoutes.join(", ")}.`, "hint")
    };
    OnlyResponseCanBeReturned = {
      name: "OnlyResponseCanBeReturned",
      title: "Invalid type returned by Astro page.",
      message: /* @__PURE__ */ __name((route, returnedValue) => `Route \`${route ? route : ""}\` returned a \`${returnedValue}\`. Only a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) can be returned from Astro files.`, "message"),
      hint: "See https://docs.astro.build/en/guides/on-demand-rendering/#response for more information."
    };
    MissingMediaQueryDirective = {
      name: "MissingMediaQueryDirective",
      title: "Missing value for `client:media` directive.",
      message: 'Media query not provided for `client:media` directive. A media query similar to `client:media="(max-width: 600px)"` must be provided'
    };
    NoMatchingRenderer = {
      name: "NoMatchingRenderer",
      title: "No matching renderer found.",
      message: /* @__PURE__ */ __name((componentName, componentExtension, plural, validRenderersCount) => `Unable to render \`${componentName}\`.

${validRenderersCount > 0 ? `There ${plural ? "are" : "is"} ${validRenderersCount} renderer${plural ? "s" : ""} configured in your \`astro.config.mjs\` file,
but ${plural ? "none were" : "it was not"} able to server-side render \`${componentName}\`.` : `No valid renderer was found ${componentExtension ? `for the \`.${componentExtension}\` file extension.` : `for this file extension.`}`}`, "message"),
      hint: /* @__PURE__ */ __name((probableRenderers) => `Did you mean to enable the ${probableRenderers} integration?

See https://docs.astro.build/en/guides/framework-components/ for more information on how to install and configure integrations.`, "hint")
    };
    NoClientOnlyHint = {
      name: "NoClientOnlyHint",
      title: "Missing hint on client:only directive.",
      message: /* @__PURE__ */ __name((componentName) => `Unable to render \`${componentName}\`. When using the \`client:only\` hydration strategy, Astro needs a hint to use the correct renderer.`, "message"),
      hint: /* @__PURE__ */ __name((probableRenderers) => `Did you mean to pass \`client:only="${probableRenderers}"\`? See https://docs.astro.build/en/reference/directives-reference/#clientonly for more information on client:only`, "hint")
    };
    InvalidGetStaticPathsEntry = {
      name: "InvalidGetStaticPathsEntry",
      title: "Invalid entry inside getStaticPath's return value",
      message: /* @__PURE__ */ __name((entryType) => `Invalid entry returned by getStaticPaths. Expected an object, got \`${entryType}\``, "message"),
      hint: "If you're using a `.map` call, you might be looking for `.flatMap()` instead. See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths."
    };
    InvalidGetStaticPathsReturn = {
      name: "InvalidGetStaticPathsReturn",
      title: "Invalid value returned by getStaticPaths.",
      message: /* @__PURE__ */ __name((returnType) => `Invalid type returned by \`getStaticPaths\`. Expected an \`array\`, got \`${returnType}\``, "message"),
      hint: "See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsExpectedParams = {
      name: "GetStaticPathsExpectedParams",
      title: "Missing params property on `getStaticPaths` route.",
      message: "Missing or empty required `params` property on `getStaticPaths` route.",
      hint: "See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsInvalidRouteParam = {
      name: "GetStaticPathsInvalidRouteParam",
      title: "Invalid value for `getStaticPaths` route parameter.",
      message: /* @__PURE__ */ __name((key, value, valueType) => `Invalid getStaticPaths route parameter for \`${key}\`. Expected undefined, a string or a number, received \`${valueType}\` (\`${value}\`)`, "message"),
      hint: "See https://docs.astro.build/en/reference/routing-reference/#getstaticpaths for more information on getStaticPaths."
    };
    GetStaticPathsRequired = {
      name: "GetStaticPathsRequired",
      title: "`getStaticPaths()` function required for dynamic routes.",
      message: "`getStaticPaths()` function is required for dynamic routes. Make sure that you `export` a `getStaticPaths` function from your dynamic route.",
      hint: `See https://docs.astro.build/en/guides/routing/#dynamic-routes for more information on dynamic routes.

	If you meant for this route to be server-rendered, set \`export const prerender = false;\` in the page.`
    };
    ReservedSlotName = {
      name: "ReservedSlotName",
      title: "Invalid slot name.",
      message: /* @__PURE__ */ __name((slotName2) => `Unable to create a slot named \`${slotName2}\`. \`${slotName2}\` is a reserved slot name. Please update the name of this slot.`, "message")
    };
    NoMatchingImport = {
      name: "NoMatchingImport",
      title: "No import found for component.",
      message: /* @__PURE__ */ __name((componentName) => `Could not render \`${componentName}\`. No matching import has been found for \`${componentName}\`.`, "message"),
      hint: "Please make sure the component is properly imported."
    };
    InvalidComponentArgs = {
      name: "InvalidComponentArgs",
      title: "Invalid component arguments.",
      message: /* @__PURE__ */ __name((name) => `Invalid arguments passed to${name ? ` <${name}>` : ""} component.`, "message"),
      hint: "Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."
    };
    PageNumberParamNotFound = {
      name: "PageNumberParamNotFound",
      title: "Page number param not found.",
      message: /* @__PURE__ */ __name((paramName) => `[paginate()] page number param \`${paramName}\` not found in your filepath.`, "message"),
      hint: "Rename your file to `[page].astro` or `[...page].astro`."
    };
    ImageMissingAlt = {
      name: "ImageMissingAlt",
      title: 'Image missing required "alt" property.',
      message: 'Image missing "alt" property. "alt" text is required to describe important images on the page.',
      hint: 'Use an empty string ("") for decorative images.'
    };
    InvalidImageService = {
      name: "InvalidImageService",
      title: "Error while loading image service.",
      message: "There was an error loading the configured image service. Please see the stack trace for more information."
    };
    MissingImageDimension = {
      name: "MissingImageDimension",
      title: "Missing image dimensions",
      message: /* @__PURE__ */ __name((missingDimension, imageURL) => `Missing ${missingDimension === "both" ? "width and height attributes" : `${missingDimension} attribute`} for ${imageURL}. When using remote images, both dimensions are required in order to avoid CLS.`, "message"),
      hint: "If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets). You can also use `inferSize={true}` for remote images to get the original dimensions."
    };
    FailedToFetchRemoteImageDimensions = {
      name: "FailedToFetchRemoteImageDimensions",
      title: "Failed to retrieve remote image dimensions",
      message: /* @__PURE__ */ __name((imageURL) => `Failed to get the dimensions for ${imageURL}.`, "message"),
      hint: "Verify your remote image URL is accurate, and that you are not using `inferSize` with a file located in your `public/` folder."
    };
    UnsupportedImageFormat = {
      name: "UnsupportedImageFormat",
      title: "Unsupported image format",
      message: /* @__PURE__ */ __name((format, imagePath, supportedFormats) => `Received unsupported format \`${format}\` from \`${imagePath}\`. Currently only ${supportedFormats.join(
        ", "
      )} are supported by our image services.`, "message"),
      hint: "Using an `img` tag directly instead of the `Image` component might be what you're looking for."
    };
    UnsupportedImageConversion = {
      name: "UnsupportedImageConversion",
      title: "Unsupported image conversion",
      message: "Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."
    };
    PrerenderDynamicEndpointPathCollide = {
      name: "PrerenderDynamicEndpointPathCollide",
      title: "Prerendered dynamic endpoint has path collision.",
      message: /* @__PURE__ */ __name((pathname) => `Could not render \`${pathname}\` with an \`undefined\` param as the generated path will collide during prerendering. Prevent passing \`undefined\` as \`params\` for the endpoint's \`getStaticPaths()\` function, or add an additional extension to the endpoint's filename.`, "message"),
      hint: /* @__PURE__ */ __name((filename) => `Rename \`${filename}\` to \`${filename.replace(/\.(?:js|ts)/, (m) => `.json` + m)}\``, "hint")
    };
    ExpectedImage = {
      name: "ExpectedImage",
      title: "Expected src to be an image.",
      message: /* @__PURE__ */ __name((src, typeofOptions, fullOptions) => `Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${src}\` (type: \`${typeofOptions}\`).

Full serialized options received: \`${fullOptions}\`.`, "message"),
      hint: "This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."
    };
    ExpectedImageOptions = {
      name: "ExpectedImageOptions",
      title: "Expected image options.",
      message: /* @__PURE__ */ __name((options) => `Expected getImage() parameter to be an object. Received \`${options}\`.`, "message")
    };
    ExpectedNotESMImage = {
      name: "ExpectedNotESMImage",
      title: "Expected image options, not an ESM-imported image.",
      message: "An ESM-imported image cannot be passed directly to `getImage()`. Instead, pass an object with the image in the `src` property.",
      hint: "Try changing `getImage(myImage)` to `getImage({ src: myImage })`"
    };
    IncompatibleDescriptorOptions = {
      name: "IncompatibleDescriptorOptions",
      title: "Cannot set both `densities` and `widths`",
      message: "Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",
      hint: "Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."
    };
    NoImageMetadata = {
      name: "NoImageMetadata",
      title: "Could not process image metadata.",
      message: /* @__PURE__ */ __name((imagePath) => `Could not process image metadata${imagePath ? ` for \`${imagePath}\`` : ""}.`, "message"),
      hint: "This is often caused by a corrupted or malformed image. Re-exporting the image from your image editor may fix this issue."
    };
    ResponseSentError = {
      name: "ResponseSentError",
      title: "Unable to set response.",
      message: "The response has already been sent to the browser and cannot be altered."
    };
    MiddlewareNoDataOrNextCalled = {
      name: "MiddlewareNoDataOrNextCalled",
      title: "The middleware didn't return a `Response`.",
      message: "Make sure your middleware returns a `Response` object, either directly or by returning the `Response` from calling the `next` function."
    };
    MiddlewareNotAResponse = {
      name: "MiddlewareNotAResponse",
      title: "The middleware returned something that is not a `Response` object.",
      message: "Any data returned from middleware must be a valid `Response` object."
    };
    EndpointDidNotReturnAResponse = {
      name: "EndpointDidNotReturnAResponse",
      title: "The endpoint did not return a `Response`.",
      message: "An endpoint must return either a `Response`, or a `Promise` that resolves with a `Response`."
    };
    LocalsNotAnObject = {
      name: "LocalsNotAnObject",
      title: "Value assigned to `locals` is not accepted.",
      message: "`locals` can only be assigned to an object. Other values like numbers, strings, etc. are not accepted.",
      hint: "If you tried to remove some information from the `locals` object, try to use `delete` or set the property to `undefined`."
    };
    LocalsReassigned = {
      name: "LocalsReassigned",
      title: "`locals` must not be reassigned.",
      message: "`locals` can not be assigned directly.",
      hint: "Set a `locals` property instead."
    };
    AstroResponseHeadersReassigned = {
      name: "AstroResponseHeadersReassigned",
      title: "`Astro.response.headers` must not be reassigned.",
      message: "Individual headers can be added to and removed from `Astro.response.headers`, but it must not be replaced with another instance of `Headers` altogether.",
      hint: "Consider using `Astro.response.headers.add()`, and `Astro.response.headers.delete()`."
    };
    LocalImageUsedWrongly = {
      name: "LocalImageUsedWrongly",
      title: "Local images must be imported.",
      message: /* @__PURE__ */ __name((imageFilePath) => `\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${imageFilePath}\`.`, "message"),
      hint: "If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections). See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."
    };
    AstroGlobUsedOutside = {
      name: "AstroGlobUsedOutside",
      title: "Astro.glob() used outside of an Astro file.",
      message: /* @__PURE__ */ __name((globStr) => `\`Astro.glob(${globStr})\` can only be used in \`.astro\` files. \`import.meta.glob(${globStr})\` can be used instead to achieve a similar result.`, "message"),
      hint: "See Vite's documentation on `import.meta.glob` for more information: https://vite.dev/guide/features.html#glob-import"
    };
    AstroGlobNoMatch = {
      name: "AstroGlobNoMatch",
      title: "Astro.glob() did not match any files.",
      message: /* @__PURE__ */ __name((globStr) => `\`Astro.glob(${globStr})\` did not return any matching files.`, "message"),
      hint: "Check the pattern for typos."
    };
    MissingSharp = {
      name: "MissingSharp",
      title: "Could not find Sharp.",
      message: "Could not find Sharp. Please install Sharp (`sharp`) manually into your project or migrate to another image service.",
      hint: "See Sharp's installation instructions for more information: https://sharp.pixelplumbing.com/install. If you are not relying on `astro:assets` to optimize, transform, or process any images, you can configure a passthrough image service instead of installing Sharp. See https://docs.astro.build/en/reference/errors/missing-sharp for more information.\n\nSee https://docs.astro.build/en/guides/images/#default-image-service for more information on how to migrate to another image service."
    };
    i18nNoLocaleFoundInPath = {
      name: "i18nNoLocaleFoundInPath",
      title: "The path doesn't contain any locale",
      message: "You tried to use an i18n utility on a path that doesn't contain any locale. You can use `pathHasLocale` first to determine if the path has a locale."
    };
    RewriteWithBodyUsed = {
      name: "RewriteWithBodyUsed",
      title: "Cannot use Astro.rewrite after the request body has been read",
      message: "Astro.rewrite() cannot be used if the request body has already been read. If you need to read the body, first clone the request."
    };
    ForbiddenRewrite = {
      name: "ForbiddenRewrite",
      title: "Forbidden rewrite to a static route.",
      message: /* @__PURE__ */ __name((from, to, component) => `You tried to rewrite the on-demand route '${from}' with the static route '${to}', when using the 'server' output. 

The static route '${to}' is rendered by the component
'${component}', which is marked as prerendered. This is a forbidden operation because during the build the component '${component}' is compiled to an
HTML file, which can't be retrieved at runtime by Astro.`, "message"),
      hint: /* @__PURE__ */ __name((component) => `Add \`export const prerender = false\` to the component '${component}', or use a Astro.redirect().`, "hint")
    };
    ExperimentalFontsNotEnabled = {
      name: "ExperimentalFontsNotEnabled",
      title: "Experimental fonts are not enabled",
      message: "The Font component is used but experimental fonts have not been registered in the config.",
      hint: "Check that you have enabled experimental fonts and also configured your preferred fonts."
    };
    FontFamilyNotFound = {
      name: "FontFamilyNotFound",
      title: "Font family not found",
      message: /* @__PURE__ */ __name((family) => `No data was found for the \`"${family}"\` family passed to the \`<Font>\` component.`, "message"),
      hint: "This is often caused by a typo. Check that the `<Font />` component or `getFontData()` function are using a `cssVariable` specified in your config."
    };
    CspNotEnabled = {
      name: "CspNotEnabled",
      title: "CSP feature isn't enabled",
      message: "The `experimental.csp` configuration isn't enabled."
    };
    ActionsReturnedInvalidDataError = {
      name: "ActionsReturnedInvalidDataError",
      title: "Action handler returned invalid data.",
      message: /* @__PURE__ */ __name((error5) => `Action handler returned invalid data. Handlers should return serializable data types like objects, arrays, strings, and numbers. Parse error: ${error5}`, "message"),
      hint: "See the devalue library for all supported types: https://github.com/rich-harris/devalue"
    };
    ActionNotFoundError = {
      name: "ActionNotFoundError",
      title: "Action not found.",
      message: /* @__PURE__ */ __name((actionName) => `The server received a request for an action named \`${actionName}\` but could not find a match. If you renamed an action, check that you've updated your \`actions/index\` file and your calling code to match.`, "message"),
      hint: "You can run `astro check` to detect type errors caused by mismatched action names."
    };
    SessionStorageInitError = {
      name: "SessionStorageInitError",
      title: "Session storage could not be initialized.",
      message: /* @__PURE__ */ __name((error5, driver) => `Error when initializing session storage${driver ? ` with driver \`${driver}\`` : ""}. \`${error5 ?? ""}\``, "message"),
      hint: "For more information, see https://docs.astro.build/en/guides/sessions/"
    };
    SessionStorageSaveError = {
      name: "SessionStorageSaveError",
      title: "Session data could not be saved.",
      message: /* @__PURE__ */ __name((error5, driver) => `Error when saving session data${driver ? ` with driver \`${driver}\`` : ""}. \`${error5 ?? ""}\``, "message"),
      hint: "For more information, see https://docs.astro.build/en/guides/sessions/"
    };
    __name(validateArgs, "validateArgs");
    __name(baseCreateComponent, "baseCreateComponent");
    __name(createComponentWithOptions, "createComponentWithOptions");
    __name(createComponent, "createComponent");
    __name(createAstroGlobFn, "createAstroGlobFn");
    __name(createAstro, "createAstro");
    e = globalThis.process || {};
    t = e.argv || [];
    n = e.env || {};
    r$1 = !(n.NO_COLOR || t.includes(`--no-color`)) && (!!n.FORCE_COLOR || t.includes(`--color`) || e.platform === `win32` || (e.stdout || {}).isTTY && n.TERM !== `dumb` || !!n.CI);
    i = /* @__PURE__ */ __name((e2, t2, n2 = e2) => (r2) => {
      let i2 = `` + r2, o2 = i2.indexOf(t2, e2.length);
      return ~o2 ? e2 + a(i2, t2, n2, o2) + t2 : e2 + i2 + t2;
    }, "i");
    a = /* @__PURE__ */ __name((e2, t2, n2, r2) => {
      let i2 = ``, a2 = 0;
      do
        i2 += e2.substring(a2, r2) + n2, a2 = r2 + t2.length, r2 = e2.indexOf(t2, a2);
      while (~r2);
      return i2 + e2.substring(a2);
    }, "a");
    o = /* @__PURE__ */ __name((e2 = r$1) => {
      let t2 = e2 ? i : () => String;
      return { isColorSupported: e2, reset: t2(`\x1B[0m`, `\x1B[0m`), bold: t2(`\x1B[1m`, `\x1B[22m`, `\x1B[22m\x1B[1m`), dim: t2(`\x1B[2m`, `\x1B[22m`, `\x1B[22m\x1B[2m`), italic: t2(`\x1B[3m`, `\x1B[23m`), underline: t2(`\x1B[4m`, `\x1B[24m`), inverse: t2(`\x1B[7m`, `\x1B[27m`), hidden: t2(`\x1B[8m`, `\x1B[28m`), strikethrough: t2(`\x1B[9m`, `\x1B[29m`), black: t2(`\x1B[30m`, `\x1B[39m`), red: t2(`\x1B[31m`, `\x1B[39m`), green: t2(`\x1B[32m`, `\x1B[39m`), yellow: t2(`\x1B[33m`, `\x1B[39m`), blue: t2(`\x1B[34m`, `\x1B[39m`), magenta: t2(`\x1B[35m`, `\x1B[39m`), cyan: t2(`\x1B[36m`, `\x1B[39m`), white: t2(`\x1B[37m`, `\x1B[39m`), gray: t2(`\x1B[90m`, `\x1B[39m`), bgBlack: t2(`\x1B[40m`, `\x1B[49m`), bgRed: t2(`\x1B[41m`, `\x1B[49m`), bgGreen: t2(`\x1B[42m`, `\x1B[49m`), bgYellow: t2(`\x1B[43m`, `\x1B[49m`), bgBlue: t2(`\x1B[44m`, `\x1B[49m`), bgMagenta: t2(`\x1B[45m`, `\x1B[49m`), bgCyan: t2(`\x1B[46m`, `\x1B[49m`), bgWhite: t2(`\x1B[47m`, `\x1B[49m`), blackBright: t2(`\x1B[90m`, `\x1B[39m`), redBright: t2(`\x1B[91m`, `\x1B[39m`), greenBright: t2(`\x1B[92m`, `\x1B[39m`), yellowBright: t2(`\x1B[93m`, `\x1B[39m`), blueBright: t2(`\x1B[94m`, `\x1B[39m`), magentaBright: t2(`\x1B[95m`, `\x1B[39m`), cyanBright: t2(`\x1B[96m`, `\x1B[39m`), whiteBright: t2(`\x1B[97m`, `\x1B[39m`), bgBlackBright: t2(`\x1B[100m`, `\x1B[49m`), bgRedBright: t2(`\x1B[101m`, `\x1B[49m`), bgGreenBright: t2(`\x1B[102m`, `\x1B[49m`), bgYellowBright: t2(`\x1B[103m`, `\x1B[49m`), bgBlueBright: t2(`\x1B[104m`, `\x1B[49m`), bgMagentaBright: t2(`\x1B[105m`, `\x1B[49m`), bgCyanBright: t2(`\x1B[106m`, `\x1B[49m`), bgWhiteBright: t2(`\x1B[107m`, `\x1B[49m`) };
    }, "o");
    s = o();
    __name(renderEndpoint, "renderEndpoint");
    ({ replace } = "");
    ca = /[&<>'"]/g;
    esca = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "'": "&#39;",
      '"': "&quot;"
    };
    pe = /* @__PURE__ */ __name((m) => esca[m], "pe");
    escape = /* @__PURE__ */ __name((es) => replace.call(es, ca, pe), "escape");
    __name(isPromise, "isPromise");
    __name(streamAsyncIterator, "streamAsyncIterator");
    escapeHTML = escape;
    HTMLBytes = class extends Uint8Array {
      static {
        __name(this, "HTMLBytes");
      }
    };
    Object.defineProperty(HTMLBytes.prototype, Symbol.toStringTag, {
      get() {
        return "HTMLBytes";
      }
    });
    HTMLString = class extends String {
      static {
        __name(this, "HTMLString");
      }
      get [Symbol.toStringTag]() {
        return "HTMLString";
      }
    };
    markHTMLString = /* @__PURE__ */ __name((value) => {
      if (value instanceof HTMLString) {
        return value;
      }
      if (typeof value === "string") {
        return new HTMLString(value);
      }
      return value;
    }, "markHTMLString");
    __name(isHTMLString, "isHTMLString");
    __name(markHTMLBytes, "markHTMLBytes");
    __name(hasGetReader, "hasGetReader");
    __name(unescapeChunksAsync, "unescapeChunksAsync");
    __name(unescapeChunks, "unescapeChunks");
    __name(unescapeHTML, "unescapeHTML");
    AstroJSX = "astro:jsx";
    __name(isVNode, "isVNode");
    __name(isAstroComponentFactory, "isAstroComponentFactory");
    __name(isAPropagatingComponent, "isAPropagatingComponent");
    __name(getPropagationHint, "getPropagationHint");
    __name(r, "r");
    __name(clsx, "clsx");
    PROP_TYPE = {
      Value: 0,
      JSON: 1,
      // Actually means Array
      RegExp: 2,
      Date: 3,
      Map: 4,
      Set: 5,
      BigInt: 6,
      URL: 7,
      Uint8Array: 8,
      Uint16Array: 9,
      Uint32Array: 10,
      Infinity: 11
    };
    __name(serializeArray, "serializeArray");
    __name(serializeObject, "serializeObject");
    __name(convertToSerializedForm, "convertToSerializedForm");
    __name(serializeProps, "serializeProps");
    transitionDirectivesToCopyOnIsland = Object.freeze([
      "data-astro-transition-scope",
      "data-astro-transition-persist",
      "data-astro-transition-persist-props"
    ]);
    __name(extractDirectives, "extractDirectives");
    __name(generateHydrateScript, "generateHydrateScript");
    dictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY";
    binary = dictionary.length;
    __name(bitwise, "bitwise");
    __name(shorthash, "shorthash");
    headAndContentSym = Symbol.for("astro.headAndContent");
    __name(isHeadAndContent, "isHeadAndContent");
    __name(createThinHead, "createThinHead");
    astro_island_prebuilt_default = `(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=\` (export \${v})\`),console.error(\`[hydrate] Error parsing props for component \${s}\`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(\`astro:\${c}\`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(\`[astro-island] Error hydrating \${this.getAttribute("component-url")}\`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();`;
    ISLAND_STYLES = "astro-island,astro-slot,astro-static-slot{display:contents}";
    __name(determineIfNeedsHydrationScript, "determineIfNeedsHydrationScript");
    __name(determinesIfNeedsDirectiveScript, "determinesIfNeedsDirectiveScript");
    __name(getDirectiveScriptText, "getDirectiveScriptText");
    __name(getPrescripts, "getPrescripts");
    __name(renderCspContent, "renderCspContent");
    RenderInstructionSymbol = Symbol.for("astro:render");
    __name(createRenderInstruction, "createRenderInstruction");
    __name(isRenderInstruction, "isRenderInstruction");
    voidElementNames = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
    htmlBooleanAttributes = /^(?:allowfullscreen|async|autofocus|autoplay|checked|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|inert|loop|muted|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|selected|itemscope)$/i;
    AMPERSAND_REGEX = /&/g;
    DOUBLE_QUOTE_REGEX = /"/g;
    STATIC_DIRECTIVES = /* @__PURE__ */ new Set(["set:html", "set:text"]);
    toIdent = /* @__PURE__ */ __name((k) => k.trim().replace(/(?!^)\b\w|\s+|\W+/g, (match, index2) => {
      if (/\W/.test(match)) return "";
      return index2 === 0 ? match : match.toUpperCase();
    }), "toIdent");
    toAttributeString = /* @__PURE__ */ __name((value, shouldEscape = true) => shouldEscape ? String(value).replace(AMPERSAND_REGEX, "&#38;").replace(DOUBLE_QUOTE_REGEX, "&#34;") : value, "toAttributeString");
    kebab = /* @__PURE__ */ __name((k) => k.toLowerCase() === k ? k : k.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`), "kebab");
    toStyleString = /* @__PURE__ */ __name((obj) => Object.entries(obj).filter(([_, v]) => typeof v === "string" && v.trim() || typeof v === "number").map(([k, v]) => {
      if (k[0] !== "-" && k[1] !== "-") return `${kebab(k)}:${v}`;
      return `${k}:${v}`;
    }).join(";"), "toStyleString");
    __name(defineScriptVars, "defineScriptVars");
    __name(formatList, "formatList");
    __name(isCustomElement, "isCustomElement");
    __name(handleBooleanAttribute, "handleBooleanAttribute");
    __name(addAttribute, "addAttribute");
    __name(internalSpreadAttributes, "internalSpreadAttributes");
    __name(renderElement$1, "renderElement$1");
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    BufferedRenderer = class {
      static {
        __name(this, "BufferedRenderer");
      }
      chunks = [];
      renderPromise;
      destination;
      /**
       * Determines whether buffer has been flushed
       * to the final destination.
       */
      flushed = false;
      constructor(destination, renderFunction) {
        this.destination = destination;
        this.renderPromise = renderFunction(this);
        if (isPromise(this.renderPromise)) {
          Promise.resolve(this.renderPromise).catch(noop);
        }
      }
      write(chunk) {
        if (this.flushed) {
          this.destination.write(chunk);
        } else {
          this.chunks.push(chunk);
        }
      }
      flush() {
        if (this.flushed) {
          throw new Error("The render buffer has already been flushed.");
        }
        this.flushed = true;
        for (const chunk of this.chunks) {
          this.destination.write(chunk);
        }
        return this.renderPromise;
      }
    };
    __name(createBufferedRenderer, "createBufferedRenderer");
    isNode = typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]";
    isDeno = typeof Deno !== "undefined";
    __name(promiseWithResolvers, "promiseWithResolvers");
    VALID_PROTOCOLS = ["http:", "https:"];
    __name(isHttpUrl, "isHttpUrl");
    uniqueElements = /* @__PURE__ */ __name((item, index2, all) => {
      const props = JSON.stringify(item.props);
      const children = item.children;
      return index2 === all.findIndex((i2) => JSON.stringify(i2.props) === props && i2.children == children);
    }, "uniqueElements");
    __name(renderAllHeadContent, "renderAllHeadContent");
    __name(renderHead, "renderHead");
    __name(maybeRenderHead, "maybeRenderHead");
    __name(encodeHexUpperCase, "encodeHexUpperCase");
    __name(decodeHex, "decodeHex");
    alphabetUpperCase = "0123456789ABCDEF";
    decodeMap = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    (function(EncodingPadding2) {
      EncodingPadding2[EncodingPadding2["Include"] = 0] = "Include";
      EncodingPadding2[EncodingPadding2["None"] = 1] = "None";
    })(EncodingPadding$1 || (EncodingPadding$1 = {}));
    (function(DecodingPadding2) {
      DecodingPadding2[DecodingPadding2["Required"] = 0] = "Required";
      DecodingPadding2[DecodingPadding2["Ignore"] = 1] = "Ignore";
    })(DecodingPadding$1 || (DecodingPadding$1 = {}));
    __name(encodeBase64, "encodeBase64");
    __name(encodeBase64_internal, "encodeBase64_internal");
    base64Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    __name(decodeBase64, "decodeBase64");
    __name(decodeBase64_internal, "decodeBase64_internal");
    (function(EncodingPadding2) {
      EncodingPadding2[EncodingPadding2["Include"] = 0] = "Include";
      EncodingPadding2[EncodingPadding2["None"] = 1] = "None";
    })(EncodingPadding || (EncodingPadding = {}));
    (function(DecodingPadding2) {
      DecodingPadding2[DecodingPadding2["Required"] = 0] = "Required";
      DecodingPadding2[DecodingPadding2["Ignore"] = 1] = "Ignore";
    })(DecodingPadding || (DecodingPadding = {}));
    base64DecodeMap = {
      "0": 52,
      "1": 53,
      "2": 54,
      "3": 55,
      "4": 56,
      "5": 57,
      "6": 58,
      "7": 59,
      "8": 60,
      "9": 61,
      A: 0,
      B: 1,
      C: 2,
      D: 3,
      E: 4,
      F: 5,
      G: 6,
      H: 7,
      I: 8,
      J: 9,
      K: 10,
      L: 11,
      M: 12,
      N: 13,
      O: 14,
      P: 15,
      Q: 16,
      R: 17,
      S: 18,
      T: 19,
      U: 20,
      V: 21,
      W: 22,
      X: 23,
      Y: 24,
      Z: 25,
      a: 26,
      b: 27,
      c: 28,
      d: 29,
      e: 30,
      f: 31,
      g: 32,
      h: 33,
      i: 34,
      j: 35,
      k: 36,
      l: 37,
      m: 38,
      n: 39,
      o: 40,
      p: 41,
      q: 42,
      r: 43,
      s: 44,
      t: 45,
      u: 46,
      v: 47,
      w: 48,
      x: 49,
      y: 50,
      z: 51,
      "+": 62,
      "/": 63
    };
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e2) {
          return obj[e2];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error5) => {
          for (const issue of error5.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i2 = 0;
              while (i2 < issue.path.length) {
                const el = issue.path[i2];
                const terminal = i2 === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i2++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error5 = new ZodError(issues);
      return error5;
    };
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message2;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message2 = "Required";
          } else {
            message2 = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message2 = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message2 = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message2 = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message2 = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message2 = `Invalid ${issue.validation}`;
          } else {
            message2 = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "bigint")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message2 = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message2 = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message2 = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message2 = "Number must be finite";
          break;
        default:
          message2 = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message: message2 };
    }, "errorMap");
    overrideErrorMap = errorMap;
    __name(getErrorMap, "getErrorMap");
    makeIssue = /* @__PURE__ */ __name((params) => {
      const { data, path: path3, errorMaps, issueData } = params;
      const fullPath = [...path3, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s2 of results) {
          if (s2.status === "aborted")
            return INVALID;
          if (s2.status === "dirty")
            status.dirty();
          arrayValue.push(s2.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value) => ({ status: "dirty", value }), "DIRTY");
    OK = /* @__PURE__ */ __name((value) => ({ status: "valid", value }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
    (function(errorUtil2) {
      errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
      errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2?.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value, path3, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path3;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error5 = new ZodError(ctx.common.issues);
            this._error = error5;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message2) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message2 === "string" || typeof message2 === "undefined") {
            return { message: message2 };
          } else if (typeof message2 === "function") {
            return message2(val);
          } else {
            return message2;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex = timeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message2) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message2)
        });
      }
      _addCheck(check2) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message2) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
      }
      url(message2) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
      }
      emoji(message2) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
      }
      uuid(message2) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
      }
      nanoid(message2) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
      }
      cuid(message2) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
      }
      cuid2(message2) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
      }
      ulid(message2) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
      }
      base64(message2) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
      }
      base64url(message2) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message2)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message2) {
        return this._addCheck({ kind: "date", message: message2 });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message2) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
      }
      regex(regex, message2) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message2)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message2) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      endsWith(value, message2) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message2)
        });
      }
      min(minLength, message2) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message2)
        });
      }
      max(maxLength, message2) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message2)
        });
      }
      length(len, message2) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message2)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message2) {
        return this.min(1, errorUtil.errToObj(message2));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message2) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message2)
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      finite(message2) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message2)
        });
      }
      safe(message2) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message2) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      max(maxDate, message2) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message2)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i2) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i2) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message2) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message2) }
        });
      }
      max(maxLength, message2) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message2) }
        });
      }
      length(len, message2) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message2) }
        });
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodArray.create = (schema2, params) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message2) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message2 !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message2).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index2) {
        return new _ZodObject({
          ...this._def,
          catchall: index2
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message2) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message2) }
        });
      }
      max(maxSize, message2) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message2) }
        });
      }
      size(size, message2) {
        return this.min(size, message2).max(size, message2);
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema2, params) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema2, effect, params) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a2, b) {
        return new _ZodPipeline({
          in: a2,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom, "custom");
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    ZodAny.create;
    ZodNever.create;
    ZodArray.create;
    ZodUnion.create;
    ZodIntersection.create;
    ZodTuple.create;
    enumType = ZodEnum.create;
    ZodPromise.create;
    ZodOptional.create;
    ZodNullable.create;
    ALGORITHMS = {
      "SHA-256": "sha256-",
      "SHA-384": "sha384-",
      "SHA-512": "sha512-"
    };
    ALGORITHM_VALUES = Object.values(ALGORITHMS);
    enumType(Object.keys(ALGORITHMS)).optional().default("SHA-256");
    custom((value) => {
      if (typeof value !== "string") {
        return false;
      }
      return ALGORITHM_VALUES.some((allowedValue) => {
        return value.startsWith(allowedValue);
      });
    });
    ALLOWED_DIRECTIVES = [
      "base-uri",
      "child-src",
      "connect-src",
      "default-src",
      "fenced-frame-src",
      "font-src",
      "form-action",
      "frame-ancestors",
      "frame-src",
      "img-src",
      "manifest-src",
      "media-src",
      "object-src",
      "referrer",
      "report-to",
      "report-uri",
      "require-trusted-types-for",
      "sandbox",
      "trusted-types",
      "upgrade-insecure-requests",
      "worker-src"
    ];
    custom((value) => {
      if (typeof value !== "string") {
        return false;
      }
      return ALLOWED_DIRECTIVES.some((allowedValue) => {
        return value.startsWith(allowedValue);
      });
    });
    ALGORITHM = "AES-GCM";
    __name(decodeKey, "decodeKey");
    encoder$1 = new TextEncoder();
    decoder$1 = new TextDecoder();
    IV_LENGTH = 24;
    __name(encryptString, "encryptString");
    __name(decryptString, "decryptString");
    __name(generateCspDigest, "generateCspDigest");
    renderTemplateResultSym = Symbol.for("astro.renderTemplateResult");
    RenderTemplateResult = class {
      static {
        __name(this, "RenderTemplateResult");
      }
      [renderTemplateResultSym] = true;
      htmlParts;
      expressions;
      error;
      constructor(htmlParts, expressions) {
        this.htmlParts = htmlParts;
        this.error = void 0;
        this.expressions = expressions.map((expression) => {
          if (isPromise(expression)) {
            return Promise.resolve(expression).catch((err) => {
              if (!this.error) {
                this.error = err;
                throw err;
              }
            });
          }
          return expression;
        });
      }
      render(destination) {
        const flushers = this.expressions.map((exp) => {
          return createBufferedRenderer(destination, (bufferDestination) => {
            if (exp || exp === 0) {
              return renderChild(bufferDestination, exp);
            }
          });
        });
        let i2 = 0;
        const iterate = /* @__PURE__ */ __name(() => {
          while (i2 < this.htmlParts.length) {
            const html = this.htmlParts[i2];
            const flusher = flushers[i2];
            i2++;
            if (html) {
              destination.write(markHTMLString(html));
            }
            if (flusher) {
              const result = flusher.flush();
              if (isPromise(result)) {
                return result.then(iterate);
              }
            }
          }
        }, "iterate");
        return iterate();
      }
    };
    __name(isRenderTemplateResult, "isRenderTemplateResult");
    __name(renderTemplate, "renderTemplate");
    slotString = Symbol.for("astro:slot-string");
    SlotString = class extends HTMLString {
      static {
        __name(this, "SlotString");
      }
      instructions;
      [slotString];
      constructor(content, instructions) {
        super(content);
        this.instructions = instructions;
        this[slotString] = true;
      }
    };
    __name(isSlotString, "isSlotString");
    __name(renderSlot, "renderSlot");
    __name(renderSlotToString, "renderSlotToString");
    __name(renderSlots, "renderSlots");
    __name(createSlotValueFromString, "createSlotValueFromString");
    internalProps = /* @__PURE__ */ new Set([
      "server:component-path",
      "server:component-export",
      "server:component-directive",
      "server:defer"
    ]);
    __name(containsServerDirective, "containsServerDirective");
    SCRIPT_RE = /<\/script/giu;
    COMMENT_RE = /<!--/gu;
    SCRIPT_REPLACER = "<\\/script";
    COMMENT_REPLACER = "\\u003C!--";
    __name(safeJsonStringify, "safeJsonStringify");
    __name(createSearchParams, "createSearchParams");
    __name(isWithinURLLimit, "isWithinURLLimit");
    ServerIslandComponent = class {
      static {
        __name(this, "ServerIslandComponent");
      }
      result;
      props;
      slots;
      displayName;
      hostId;
      islandContent;
      componentPath;
      componentExport;
      componentId;
      constructor(result, props, slots, displayName) {
        this.result = result;
        this.props = props;
        this.slots = slots;
        this.displayName = displayName;
      }
      async init() {
        const content = await this.getIslandContent();
        if (this.result.cspDestination) {
          this.result._metadata.extraScriptHashes.push(
            await generateCspDigest(SERVER_ISLAND_REPLACER, this.result.cspAlgorithm)
          );
          const contentDigest = await generateCspDigest(content, this.result.cspAlgorithm);
          this.result._metadata.extraScriptHashes.push(contentDigest);
        }
        return createThinHead();
      }
      async render(destination) {
        const hostId = await this.getHostId();
        const islandContent = await this.getIslandContent();
        destination.write(createRenderInstruction({ type: "server-island-runtime" }));
        destination.write("<!--[if astro]>server-island-start<![endif]-->");
        for (const name in this.slots) {
          if (name === "fallback") {
            await renderChild(destination, this.slots.fallback(this.result));
          }
        }
        destination.write(
          `<script type="module" data-astro-rerun data-island-id="${hostId}">${islandContent}<\/script>`
        );
      }
      getComponentPath() {
        if (this.componentPath) {
          return this.componentPath;
        }
        const componentPath = this.props["server:component-path"];
        if (!componentPath) {
          throw new Error(`Could not find server component path`);
        }
        this.componentPath = componentPath;
        return componentPath;
      }
      getComponentExport() {
        if (this.componentExport) {
          return this.componentExport;
        }
        const componentExport = this.props["server:component-export"];
        if (!componentExport) {
          throw new Error(`Could not find server component export`);
        }
        this.componentExport = componentExport;
        return componentExport;
      }
      async getHostId() {
        if (!this.hostId) {
          this.hostId = await crypto.randomUUID();
        }
        return this.hostId;
      }
      async getIslandContent() {
        if (this.islandContent) {
          return this.islandContent;
        }
        const componentPath = this.getComponentPath();
        const componentExport = this.getComponentExport();
        const componentId = this.result.serverIslandNameMap.get(componentPath);
        if (!componentId) {
          throw new Error(`Could not find server component name`);
        }
        for (const key2 of Object.keys(this.props)) {
          if (internalProps.has(key2)) {
            delete this.props[key2];
          }
        }
        const renderedSlots = {};
        for (const name in this.slots) {
          if (name !== "fallback") {
            const content = await renderSlotToString(this.result, this.slots[name]);
            renderedSlots[name] = content.toString();
          }
        }
        const key = await this.result.key;
        const propsEncrypted = Object.keys(this.props).length === 0 ? "" : await encryptString(key, JSON.stringify(this.props));
        const slotsEncrypted = Object.keys(renderedSlots).length === 0 ? "" : await encryptString(key, JSON.stringify(renderedSlots));
        const hostId = await this.getHostId();
        const slash2 = this.result.base.endsWith("/") ? "" : "/";
        let serverIslandUrl = `${this.result.base}${slash2}_server-islands/${componentId}${this.result.trailingSlash === "always" ? "/" : ""}`;
        const potentialSearchParams = createSearchParams(
          componentExport,
          propsEncrypted,
          slotsEncrypted
        );
        const useGETRequest = isWithinURLLimit(serverIslandUrl, potentialSearchParams);
        if (useGETRequest) {
          serverIslandUrl += "?" + potentialSearchParams.toString();
          this.result._metadata.extraHead.push(
            markHTMLString(
              `<link rel="preload" as="fetch" href="${serverIslandUrl}" crossorigin="anonymous">`
            )
          );
        }
        const adapterHeaders = this.result.internalFetchHeaders || {};
        const headersJson = safeJsonStringify(adapterHeaders);
        const method = useGETRequest ? (
          // GET request
          `const headers = new Headers(${headersJson});
let response = await fetch('${serverIslandUrl}', { headers });`
        ) : (
          // POST request
          `let data = {
	componentExport: ${safeJsonStringify(componentExport)},
	encryptedProps: ${safeJsonStringify(propsEncrypted)},
	encryptedSlots: ${safeJsonStringify(slotsEncrypted)},
};
const headers = new Headers({ 'Content-Type': 'application/json', ...${headersJson} });
let response = await fetch('${serverIslandUrl}', {
	method: 'POST',
	body: JSON.stringify(data),
	headers,
});`
        );
        this.islandContent = `${method}replaceServerIsland('${hostId}', response);`;
        return this.islandContent;
      }
    };
    renderServerIslandRuntime = /* @__PURE__ */ __name(() => {
      return `<script>${SERVER_ISLAND_REPLACER}<\/script>`;
    }, "renderServerIslandRuntime");
    SERVER_ISLAND_REPLACER = markHTMLString(
      `async function replaceServerIsland(id, r) {
	let s = document.querySelector(\`script[data-island-id="\${id}"]\`);
	// If there's no matching script, or the request fails then return
	if (!s || r.status !== 200 || r.headers.get('content-type')?.split(';')[0].trim() !== 'text/html') return;
	// Load the HTML before modifying the DOM in case of errors
	let html = await r.text();
	// Remove any placeholder content before the island script
	while (s.previousSibling && s.previousSibling.nodeType !== 8 && s.previousSibling.data !== '[if astro]>server-island-start<![endif]')
		s.previousSibling.remove();
	s.previousSibling?.remove();
	// Insert the new HTML
	s.before(document.createRange().createContextualFragment(html));
	// Remove the script. Prior to v5.4.2, this was the trick to force rerun of scripts.  Keeping it to minimize change to the existing behavior.
	s.remove();
}`.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("//")).join(" ")
    );
    Fragment = Symbol.for("astro:fragment");
    Renderer = Symbol.for("astro:renderer");
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    __name(stringifyChunk, "stringifyChunk");
    __name(chunkToString, "chunkToString");
    __name(chunkToByteArray, "chunkToByteArray");
    __name(isRenderInstance, "isRenderInstance");
    __name(renderChild, "renderChild");
    __name(renderArray, "renderArray");
    __name(renderIterable, "renderIterable");
    __name(renderAsyncIterable, "renderAsyncIterable");
    astroComponentInstanceSym = Symbol.for("astro.componentInstance");
    AstroComponentInstance = class {
      static {
        __name(this, "AstroComponentInstance");
      }
      [astroComponentInstanceSym] = true;
      result;
      props;
      slotValues;
      factory;
      returnValue;
      constructor(result, props, slots, factory) {
        this.result = result;
        this.props = props;
        this.factory = factory;
        this.slotValues = {};
        for (const name in slots) {
          let didRender = false;
          let value = slots[name](result);
          this.slotValues[name] = () => {
            if (!didRender) {
              didRender = true;
              return value;
            }
            return slots[name](result);
          };
        }
      }
      init(result) {
        if (this.returnValue !== void 0) {
          return this.returnValue;
        }
        this.returnValue = this.factory(result, this.props, this.slotValues);
        if (isPromise(this.returnValue)) {
          this.returnValue.then((resolved) => {
            this.returnValue = resolved;
          }).catch(() => {
          });
        }
        return this.returnValue;
      }
      render(destination) {
        const returnValue = this.init(this.result);
        if (isPromise(returnValue)) {
          return returnValue.then((x) => this.renderImpl(destination, x));
        }
        return this.renderImpl(destination, returnValue);
      }
      renderImpl(destination, returnValue) {
        if (isHeadAndContent(returnValue)) {
          return returnValue.content.render(destination);
        } else {
          return renderChild(destination, returnValue);
        }
      }
    };
    __name(validateComponentProps, "validateComponentProps");
    __name(createAstroComponentInstance, "createAstroComponentInstance");
    __name(isAstroComponentInstance, "isAstroComponentInstance");
    DOCTYPE_EXP = /<!doctype html/i;
    __name(renderToString, "renderToString");
    __name(renderToReadableStream, "renderToReadableStream");
    __name(callComponentAsTemplateResultOrResponse, "callComponentAsTemplateResultOrResponse");
    __name(bufferHeadContent, "bufferHeadContent");
    __name(renderToAsyncIterable, "renderToAsyncIterable");
    __name(toPromise, "toPromise");
    __name(componentIsHTMLElement, "componentIsHTMLElement");
    __name(renderHTMLElement, "renderHTMLElement");
    __name(getHTMLElementName, "getHTMLElementName");
    needsHeadRenderingSymbol = Symbol.for("astro.needsHeadRendering");
    rendererAliases = /* @__PURE__ */ new Map([["solid", "solid-js"]]);
    clientOnlyValues = /* @__PURE__ */ new Set(["solid-js", "react", "preact", "vue", "svelte"]);
    __name(guessRenderers, "guessRenderers");
    __name(isFragmentComponent, "isFragmentComponent");
    __name(isHTMLComponent, "isHTMLComponent");
    ASTRO_SLOT_EXP = /<\/?astro-slot\b[^>]*>/g;
    ASTRO_STATIC_SLOT_EXP = /<\/?astro-static-slot\b[^>]*>/g;
    __name(removeStaticAstroSlot, "removeStaticAstroSlot");
    __name(renderFrameworkComponent, "renderFrameworkComponent");
    __name(sanitizeElementName, "sanitizeElementName");
    __name(renderFragmentComponent, "renderFragmentComponent");
    __name(renderHTMLComponent, "renderHTMLComponent");
    __name(renderAstroComponent, "renderAstroComponent");
    __name(renderComponent, "renderComponent");
    __name(normalizeProps, "normalizeProps");
    __name(renderComponentToString, "renderComponentToString");
    __name(nonAstroPageNeedsHeadInjection, "nonAstroPageNeedsHeadInjection");
    ClientOnlyPlaceholder = "astro-client-only";
    hasTriedRenderComponentSymbol = Symbol("hasTriedRenderComponent");
    __name(renderJSX, "renderJSX");
    __name(renderJSXVNode, "renderJSXVNode");
    __name(renderElement, "renderElement");
    __name(prerenderElementChildren, "prerenderElementChildren");
    __name(renderPage, "renderPage");
    __name(renderScript, "renderScript");
    __name(requireCssesc, "requireCssesc");
    requireCssesc();
    "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_".split("").reduce((v, c) => (v[c.charCodeAt(0)] = c, v), []);
    "-0123456789_".split("").reduce((v, c) => (v[c.charCodeAt(0)] = c, v), []);
    __name(spreadAttributes, "spreadAttributes");
  }
});

// .wrangler/tmp/pages-AQW1MV/renderers.mjs
function requireReact_production() {
  if (hasRequiredReact_production) return react_production;
  hasRequiredReact_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  __name(getIteratorFn, "getIteratorFn");
  var ReactNoopUpdateQueue = {
    isMounted: /* @__PURE__ */ __name(function() {
      return false;
    }, "isMounted"),
    enqueueForceUpdate: /* @__PURE__ */ __name(function() {
    }, "enqueueForceUpdate"),
    enqueueReplaceState: /* @__PURE__ */ __name(function() {
    }, "enqueueReplaceState"),
    enqueueSetState: /* @__PURE__ */ __name(function() {
    }, "enqueueSetState")
  }, assign = Object.assign, emptyObject = {};
  function Component(props, context3, updater) {
    this.props = props;
    this.context = context3;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  __name(Component, "Component");
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  function ComponentDummy() {
  }
  __name(ComponentDummy, "ComponentDummy");
  ComponentDummy.prototype = Component.prototype;
  function PureComponent(props, context3, updater) {
    this.props = props;
    this.context = context3;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  __name(PureComponent, "PureComponent");
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  var isArrayImpl = Array.isArray;
  function noop2() {
  }
  __name(noop2, "noop");
  var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
  function ReactElement(type, key, props) {
    var refProp = props.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== refProp ? refProp : null,
      props
    };
  }
  __name(ReactElement, "ReactElement");
  function cloneAndReplaceKey(oldElement, newKey) {
    return ReactElement(oldElement.type, newKey, oldElement.props);
  }
  __name(cloneAndReplaceKey, "cloneAndReplaceKey");
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  __name(isValidElement, "isValidElement");
  function escape2(key) {
    var escaperLookup = { "=": "=0", ":": "=2" };
    return "$" + key.replace(/[=:]/g, function(match) {
      return escaperLookup[match];
    });
  }
  __name(escape2, "escape");
  var userProvidedKeyEscapeRegex = /\/+/g;
  function getElementKey(element, index2) {
    return "object" === typeof element && null !== element && null != element.key ? escape2("" + element.key) : index2.toString(36);
  }
  __name(getElementKey, "getElementKey");
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
          function(fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          },
          function(error5) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error5);
          }
        )), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  __name(resolveThenable, "resolveThenable");
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = false;
    if (null === children) invokeCallback = true;
    else
      switch (type) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = true;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
          }
      }
    if (invokeCallback)
      return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
        return c;
      })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
        callback,
        escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
          userProvidedKeyEscapeRegex,
          "$&/"
        ) + "/") + invokeCallback
      )), array.push(callback)), 1;
    invokeCallback = 0;
    var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children))
      for (var i2 = 0; i2 < children.length; i2++)
        nameSoFar = children[i2], type = nextNamePrefix + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if (i2 = getIteratorFn(children), "function" === typeof i2)
      for (children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
        nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if ("object" === type) {
      if ("function" === typeof children.then)
        return mapIntoArray(
          resolveThenable(children),
          array,
          escapedPrefix,
          nameSoFar,
          callback
        );
      array = String(children);
      throw Error(
        "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return invokeCallback;
  }
  __name(mapIntoArray, "mapIntoArray");
  function mapChildren(children, func, context3) {
    if (null == children) return children;
    var result = [], count4 = 0;
    mapIntoArray(children, result, "", "", function(child) {
      return func.call(context3, child, count4++);
    });
    return result;
  }
  __name(mapChildren, "mapChildren");
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(
        function(moduleObject) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 1, payload._result = moduleObject;
        },
        function(error5) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 2, payload._result = error5;
        }
      );
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return payload._result.default;
    throw payload._result;
  }
  __name(lazyInitializer, "lazyInitializer");
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error5) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error5 && null !== error5 && "string" === typeof error5.message ? String(error5.message) : String(error5),
        error: error5
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error5);
      return;
    }
    console.error(error5);
  }, Children = {
    map: mapChildren,
    forEach: /* @__PURE__ */ __name(function(children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function() {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    }, "forEach"),
    count: /* @__PURE__ */ __name(function(children) {
      var n2 = 0;
      mapChildren(children, function() {
        n2++;
      });
      return n2;
    }, "count"),
    toArray: /* @__PURE__ */ __name(function(children) {
      return mapChildren(children, function(child) {
        return child;
      }) || [];
    }, "toArray"),
    only: /* @__PURE__ */ __name(function(children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }, "only")
  };
  react_production.Activity = REACT_ACTIVITY_TYPE;
  react_production.Children = Children;
  react_production.Component = Component;
  react_production.Fragment = REACT_FRAGMENT_TYPE;
  react_production.Profiler = REACT_PROFILER_TYPE;
  react_production.PureComponent = PureComponent;
  react_production.StrictMode = REACT_STRICT_MODE_TYPE;
  react_production.Suspense = REACT_SUSPENSE_TYPE;
  react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  react_production.__COMPILER_RUNTIME = {
    __proto__: null,
    c: /* @__PURE__ */ __name(function(size) {
      return ReactSharedInternals.H.useMemoCache(size);
    }, "c")
  };
  react_production.cache = function(fn) {
    return function() {
      return fn.apply(null, arguments);
    };
  };
  react_production.cacheSignal = function() {
    return null;
  };
  react_production.cloneElement = function(element, config3, children) {
    if (null === element || void 0 === element)
      throw Error(
        "The argument must be a React element, but you passed " + element + "."
      );
    var props = assign({}, element.props), key = element.key;
    if (null != config3)
      for (propName in void 0 !== config3.key && (key = "" + config3.key), config3)
        !hasOwnProperty.call(config3, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config3.ref || (props[propName] = config3[propName]);
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;
    else if (1 < propName) {
      for (var childArray = Array(propName), i2 = 0; i2 < propName; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    return ReactElement(element.type, key, props);
  };
  react_production.createContext = function(defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    return defaultValue;
  };
  react_production.createElement = function(type, config3, children) {
    var propName, props = {}, key = null;
    if (null != config3)
      for (propName in void 0 !== config3.key && (key = "" + config3.key), config3)
        hasOwnProperty.call(config3, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config3[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;
    else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), i2 = 0; i2 < childrenLength; i2++)
        childArray[i2] = arguments[i2 + 2];
      props.children = childArray;
    }
    if (type && type.defaultProps)
      for (propName in childrenLength = type.defaultProps, childrenLength)
        void 0 === props[propName] && (props[propName] = childrenLength[propName]);
    return ReactElement(type, key, props);
  };
  react_production.createRef = function() {
    return { current: null };
  };
  react_production.forwardRef = function(render) {
    return { $$typeof: REACT_FORWARD_REF_TYPE, render };
  };
  react_production.isValidElement = isValidElement;
  react_production.lazy = function(ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: { _status: -1, _result: ctor },
      _init: lazyInitializer
    };
  };
  react_production.memo = function(type, compare) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type,
      compare: void 0 === compare ? null : compare
    };
  };
  react_production.startTransition = function(scope) {
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
    } catch (error5) {
      reportGlobalError(error5);
    } finally {
      null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  };
  react_production.unstable_useCacheRefresh = function() {
    return ReactSharedInternals.H.useCacheRefresh();
  };
  react_production.use = function(usable) {
    return ReactSharedInternals.H.use(usable);
  };
  react_production.useActionState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useActionState(action, initialState, permalink);
  };
  react_production.useCallback = function(callback, deps) {
    return ReactSharedInternals.H.useCallback(callback, deps);
  };
  react_production.useContext = function(Context) {
    return ReactSharedInternals.H.useContext(Context);
  };
  react_production.useDebugValue = function() {
  };
  react_production.useDeferredValue = function(value, initialValue) {
    return ReactSharedInternals.H.useDeferredValue(value, initialValue);
  };
  react_production.useEffect = function(create, deps) {
    return ReactSharedInternals.H.useEffect(create, deps);
  };
  react_production.useEffectEvent = function(callback) {
    return ReactSharedInternals.H.useEffectEvent(callback);
  };
  react_production.useId = function() {
    return ReactSharedInternals.H.useId();
  };
  react_production.useImperativeHandle = function(ref3, create, deps) {
    return ReactSharedInternals.H.useImperativeHandle(ref3, create, deps);
  };
  react_production.useInsertionEffect = function(create, deps) {
    return ReactSharedInternals.H.useInsertionEffect(create, deps);
  };
  react_production.useLayoutEffect = function(create, deps) {
    return ReactSharedInternals.H.useLayoutEffect(create, deps);
  };
  react_production.useMemo = function(create, deps) {
    return ReactSharedInternals.H.useMemo(create, deps);
  };
  react_production.useOptimistic = function(passthrough, reducer) {
    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
  };
  react_production.useReducer = function(reducer, initialArg, init) {
    return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
  };
  react_production.useRef = function(initialValue) {
    return ReactSharedInternals.H.useRef(initialValue);
  };
  react_production.useState = function(initialState) {
    return ReactSharedInternals.H.useState(initialState);
  };
  react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
    return ReactSharedInternals.H.useSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    );
  };
  react_production.useTransition = function() {
    return ReactSharedInternals.H.useTransition();
  };
  react_production.version = "19.2.3";
  return react_production;
}
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production();
  }
  return react.exports;
}
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React2 = requireReact();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(formatProdErrorMessage, "formatProdErrorMessage");
  function noop2() {
  }
  __name(noop2, "noop");
  var Internals = {
    d: {
      f: noop2,
      r: /* @__PURE__ */ __name(function() {
        throw Error(formatProdErrorMessage(522));
      }, "r"),
      D: noop2,
      C: noop2,
      L: noop2,
      m: noop2,
      X: noop2,
      S: noop2,
      M: noop2
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  __name(createPortal$1, "createPortal$1");
  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  __name(getCrossOriginStringAs, "getCrossOriginStringAs");
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn, a2) {
    return fn(a2);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.2.3";
  return reactDom_production;
}
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  __name(checkDCE, "checkDCE");
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
function requireReactDomServerLegacy_browser_production() {
  if (hasRequiredReactDomServerLegacy_browser_production) return reactDomServerLegacy_browser_production;
  hasRequiredReactDomServerLegacy_browser_production = 1;
  var React2 = requireReact(), ReactDOM2 = requireReactDom();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(formatProdErrorMessage, "formatProdErrorMessage");
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  __name(getIteratorFn, "getIteratorFn");
  var isArrayImpl = Array.isArray;
  function murmurhash3_32_gc(key, seed) {
    var remainder = key.length & 3;
    var bytes = key.length - remainder;
    var h1 = seed;
    for (seed = 0; seed < bytes; ) {
      var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
      ++seed;
      k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      h1 ^= k1;
      h1 = h1 << 13 | h1 >>> 19;
      h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
    }
    k1 = 0;
    switch (remainder) {
      case 3:
        k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
      case 2:
        k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
      case 1:
        k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
    }
    h1 ^= key.length;
    h1 ^= h1 >>> 16;
    h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
    h1 ^= h1 >>> 13;
    h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
    return (h1 ^ h1 >>> 16) >>> 0;
  }
  __name(murmurhash3_32_gc, "murmurhash3_32_gc");
  var assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
      return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  __name(isAttributeNameSafe, "isAttributeNameSafe");
  var unitlessNumbers = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  ), aliases = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), matchHtmlRegExp = /["'&<>]/;
  function escapeTextForBrowser(text2) {
    if ("boolean" === typeof text2 || "number" === typeof text2 || "bigint" === typeof text2)
      return "" + text2;
    text2 = "" + text2;
    var match = matchHtmlRegExp.exec(text2);
    if (match) {
      var html = "", index2, lastIndex = 0;
      for (index2 = match.index; index2 < text2.length; index2++) {
        switch (text2.charCodeAt(index2)) {
          case 34:
            match = "&quot;";
            break;
          case 38:
            match = "&amp;";
            break;
          case 39:
            match = "&#x27;";
            break;
          case 60:
            match = "&lt;";
            break;
          case 62:
            match = "&gt;";
            break;
          default:
            continue;
        }
        lastIndex !== index2 && (html += text2.slice(lastIndex, index2));
        lastIndex = index2 + 1;
        html += match;
      }
      text2 = lastIndex !== index2 ? html + text2.slice(lastIndex, index2) : html;
    }
    return text2;
  }
  __name(escapeTextForBrowser, "escapeTextForBrowser");
  var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  __name(sanitizeURL, "sanitizeURL");
  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  }, previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: previousDispatcher.f,
    r: previousDispatcher.r,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  var PRELOAD_NO_CREDS = [], currentlyFlushingRenderState = null, scriptRegex = /(<\/|<)(s)(cript)/gi;
  function scriptReplacer(match, prefix2, s2, suffix2) {
    return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
  }
  __name(scriptReplacer, "scriptReplacer");
  function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
    return {
      idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
      nextFormID: 0,
      streamingFormat: 0,
      bootstrapScriptContent,
      bootstrapScripts,
      bootstrapModules,
      instructions: 0,
      hasBody: false,
      hasHtml: false,
      unknownResources: {},
      dnsResources: {},
      connectResources: { default: {}, anonymous: {}, credentials: {} },
      imageResources: {},
      styleResources: {},
      scriptResources: {},
      moduleUnknownResources: {},
      moduleScriptResources: {}
    };
  }
  __name(createResumableState, "createResumableState");
  function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
    return {
      insertionMode,
      selectedValue,
      tagScope,
      viewTransition
    };
  }
  __name(createFormatContext, "createFormatContext");
  function getChildFormatContext(parentContext, type, props) {
    var subtreeScope = parentContext.tagScope & -25;
    switch (type) {
      case "noscript":
        return createFormatContext(2, null, subtreeScope | 1, null);
      case "select":
        return createFormatContext(
          2,
          null != props.value ? props.value : props.defaultValue,
          subtreeScope,
          null
        );
      case "svg":
        return createFormatContext(4, null, subtreeScope, null);
      case "picture":
        return createFormatContext(2, null, subtreeScope | 2, null);
      case "math":
        return createFormatContext(5, null, subtreeScope, null);
      case "foreignObject":
        return createFormatContext(2, null, subtreeScope, null);
      case "table":
        return createFormatContext(6, null, subtreeScope, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return createFormatContext(7, null, subtreeScope, null);
      case "colgroup":
        return createFormatContext(9, null, subtreeScope, null);
      case "tr":
        return createFormatContext(8, null, subtreeScope, null);
      case "head":
        if (2 > parentContext.insertionMode)
          return createFormatContext(3, null, subtreeScope, null);
        break;
      case "html":
        if (0 === parentContext.insertionMode)
          return createFormatContext(1, null, subtreeScope, null);
    }
    return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      subtreeScope,
      null
    ) : parentContext;
  }
  __name(getChildFormatContext, "getChildFormatContext");
  function getSuspenseViewTransition(parentViewTransition) {
    return null === parentViewTransition ? null : {
      update: parentViewTransition.update,
      enter: "none",
      exit: "none",
      share: parentViewTransition.update,
      name: parentViewTransition.autoName,
      autoName: parentViewTransition.autoName,
      nameIdx: 0
    };
  }
  __name(getSuspenseViewTransition, "getSuspenseViewTransition");
  function getSuspenseFallbackFormatContext(resumableState, parentContext) {
    parentContext.tagScope & 32 && (resumableState.instructions |= 128);
    return createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      parentContext.tagScope | 12,
      getSuspenseViewTransition(parentContext.viewTransition)
    );
  }
  __name(getSuspenseFallbackFormatContext, "getSuspenseFallbackFormatContext");
  function getSuspenseContentFormatContext(resumableState, parentContext) {
    resumableState = getSuspenseViewTransition(parentContext.viewTransition);
    var subtreeScope = parentContext.tagScope | 16;
    null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
    return createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      subtreeScope,
      resumableState
    );
  }
  __name(getSuspenseContentFormatContext, "getSuspenseContentFormatContext");
  var styleNameCache = /* @__PURE__ */ new Map();
  function pushStyleAttribute(target, style) {
    if ("object" !== typeof style) throw Error(formatProdErrorMessage(62));
    var isFirst = true, styleName;
    for (styleName in style)
      if (hasOwnProperty.call(style, styleName)) {
        var styleValue = style[styleName];
        if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
          if (0 === styleName.indexOf("--")) {
            var nameChunk = escapeTextForBrowser(styleName);
            styleValue = escapeTextForBrowser(("" + styleValue).trim());
          } else
            nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = escapeTextForBrowser(
              styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
            ), styleNameCache.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : escapeTextForBrowser(("" + styleValue).trim());
          isFirst ? (isFirst = false, target.push(' style="', nameChunk, ":", styleValue)) : target.push(";", nameChunk, ":", styleValue);
        }
      }
    isFirst || target.push('"');
  }
  __name(pushStyleAttribute, "pushStyleAttribute");
  function pushBooleanAttribute(target, name, value) {
    value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, '=""');
  }
  __name(pushBooleanAttribute, "pushBooleanAttribute");
  function pushStringAttribute(target, name, value) {
    "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(" ", name, '="', escapeTextForBrowser(value), '"');
  }
  __name(pushStringAttribute, "pushStringAttribute");
  var actionJavaScriptURL = escapeTextForBrowser(
    "javascript:throw new Error('React form unexpectedly submitted.')"
  );
  function pushAdditionalFormField(value, key) {
    this.push('<input type="hidden"');
    validateAdditionalFormField(value);
    pushStringAttribute(this, "name", key);
    pushStringAttribute(this, "value", value);
    this.push("/>");
  }
  __name(pushAdditionalFormField, "pushAdditionalFormField");
  function validateAdditionalFormField(value) {
    if ("string" !== typeof value) throw Error(formatProdErrorMessage(480));
  }
  __name(validateAdditionalFormField, "validateAdditionalFormField");
  function getCustomFormFields(resumableState, formAction) {
    if ("function" === typeof formAction.$$FORM_ACTION) {
      var id = resumableState.nextFormID++;
      resumableState = resumableState.idPrefix + id;
      try {
        var customFields = formAction.$$FORM_ACTION(resumableState);
        if (customFields) {
          var formData = customFields.data;
          null != formData && formData.forEach(validateAdditionalFormField);
        }
        return customFields;
      } catch (x) {
        if ("object" === typeof x && null !== x && "function" === typeof x.then)
          throw x;
      }
    }
    return null;
  }
  __name(getCustomFormFields, "getCustomFormFields");
  function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
    var formData = null;
    if ("function" === typeof formAction) {
      var customFields = getCustomFormFields(resumableState, formAction);
      null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(" ", "formAction", '="', actionJavaScriptURL, '"'), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
    }
    null != name && pushAttribute(target, "name", name);
    null != formAction && pushAttribute(target, "formAction", formAction);
    null != formEncType && pushAttribute(target, "formEncType", formEncType);
    null != formMethod && pushAttribute(target, "formMethod", formMethod);
    null != formTarget && pushAttribute(target, "formTarget", formTarget);
    return formData;
  }
  __name(pushFormActionAttribute, "pushFormActionAttribute");
  function pushAttribute(target, name, value) {
    switch (name) {
      case "className":
        pushStringAttribute(target, "class", value);
        break;
      case "tabIndex":
        pushStringAttribute(target, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        pushStringAttribute(target, name, value);
        break;
      case "style":
        pushStyleAttribute(target, value);
        break;
      case "src":
      case "href":
        if ("" === value) break;
      case "action":
      case "formAction":
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
          break;
        value = sanitizeURL("" + value);
        target.push(" ", name, '="', escapeTextForBrowser(value), '"');
        break;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "ref":
        break;
      case "autoFocus":
      case "multiple":
      case "muted":
        pushBooleanAttribute(target, name.toLowerCase(), value);
        break;
      case "xlinkHref":
        if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
          break;
        value = sanitizeURL("" + value);
        target.push(" ", "xlink:href", '="', escapeTextForBrowser(value), '"');
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, '="', escapeTextForBrowser(value), '"');
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, '=""');
        break;
      case "capture":
      case "download":
        true === value ? target.push(" ", name, '=""') : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(" ", name, '="', escapeTextForBrowser(value), '"');
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(" ", name, '="', escapeTextForBrowser(value), '"');
        break;
      case "rowSpan":
      case "start":
        "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(" ", name, '="', escapeTextForBrowser(value), '"');
        break;
      case "xlinkActuate":
        pushStringAttribute(target, "xlink:actuate", value);
        break;
      case "xlinkArcrole":
        pushStringAttribute(target, "xlink:arcrole", value);
        break;
      case "xlinkRole":
        pushStringAttribute(target, "xlink:role", value);
        break;
      case "xlinkShow":
        pushStringAttribute(target, "xlink:show", value);
        break;
      case "xlinkTitle":
        pushStringAttribute(target, "xlink:title", value);
        break;
      case "xlinkType":
        pushStringAttribute(target, "xlink:type", value);
        break;
      case "xmlBase":
        pushStringAttribute(target, "xml:base", value);
        break;
      case "xmlLang":
        pushStringAttribute(target, "xml:lang", value);
        break;
      case "xmlSpace":
        pushStringAttribute(target, "xml:space", value);
        break;
      default:
        if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
          if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
            }
            target.push(" ", name, '="', escapeTextForBrowser(value), '"');
          }
        }
    }
  }
  __name(pushAttribute, "pushAttribute");
  function pushInnerHTML(target, innerHTML, children) {
    if (null != innerHTML) {
      if (null != children) throw Error(formatProdErrorMessage(60));
      if ("object" !== typeof innerHTML || !("__html" in innerHTML))
        throw Error(formatProdErrorMessage(61));
      innerHTML = innerHTML.__html;
      null !== innerHTML && void 0 !== innerHTML && target.push("" + innerHTML);
    }
  }
  __name(pushInnerHTML, "pushInnerHTML");
  function flattenOptionChildren(children) {
    var content = "";
    React2.Children.forEach(children, function(child) {
      null != child && (content += child);
    });
    return content;
  }
  __name(flattenOptionChildren, "flattenOptionChildren");
  function injectFormReplayingRuntime(resumableState, renderState) {
    if (0 === (resumableState.instructions & 16)) {
      resumableState.instructions |= 16;
      var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
      (preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
        ">",
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`,
        "<\/script>"
      )) : bootstrapChunks.unshift(
        renderState.startInlineScript,
        ">",
        `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`,
        "<\/script>"
      );
    }
  }
  __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
  function pushLinkImpl(target, props) {
    target.push(startChunkForTag("link"));
    for (var propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(399, "link"));
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push("/>");
    return null;
  }
  __name(pushLinkImpl, "pushLinkImpl");
  var styleRegex = /(<\/|<)(s)(tyle)/gi;
  function styleReplacer(match, prefix2, s2, suffix2) {
    return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
  }
  __name(styleReplacer, "styleReplacer");
  function pushSelfClosing(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    for (var propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(399, tag2));
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push("/>");
    return null;
  }
  __name(pushSelfClosing, "pushSelfClosing");
  function pushTitleImpl(target, props) {
    target.push(startChunkForTag("title"));
    var children = null, innerHTML = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              children = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(">");
    props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
    "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(escapeTextForBrowser("" + props));
    pushInnerHTML(target, innerHTML, children);
    target.push(endChunkForTag("title"));
    return null;
  }
  __name(pushTitleImpl, "pushTitleImpl");
  function pushScriptImpl(target, props) {
    target.push(startChunkForTag("script"));
    var children = null, innerHTML = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              children = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(">");
    pushInnerHTML(target, innerHTML, children);
    "string" === typeof children && target.push(("" + children).replace(scriptRegex, scriptReplacer));
    target.push(endChunkForTag("script"));
    return null;
  }
  __name(pushScriptImpl, "pushScriptImpl");
  function pushStartSingletonElement(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    var innerHTML = tag2 = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              tag2 = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(">");
    pushInnerHTML(target, innerHTML, tag2);
    return tag2;
  }
  __name(pushStartSingletonElement, "pushStartSingletonElement");
  function pushStartGenericElement(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    var innerHTML = tag2 = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              tag2 = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(">");
    pushInnerHTML(target, innerHTML, tag2);
    return "string" === typeof tag2 ? (target.push(escapeTextForBrowser(tag2)), null) : tag2;
  }
  __name(pushStartGenericElement, "pushStartGenericElement");
  var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
  function startChunkForTag(tag2) {
    var tagStartChunk = validatedTagCache.get(tag2);
    if (void 0 === tagStartChunk) {
      if (!VALID_TAG_REGEX.test(tag2))
        throw Error(formatProdErrorMessage(65, tag2));
      tagStartChunk = "<" + tag2;
      validatedTagCache.set(tag2, tagStartChunk);
    }
    return tagStartChunk;
  }
  __name(startChunkForTag, "startChunkForTag");
  function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
    switch (type) {
      case "div":
      case "span":
      case "svg":
      case "path":
        break;
      case "a":
        target$jscomp$0.push(startChunkForTag("a"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "href":
                  "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                  break;
                default:
                  pushAttribute(target$jscomp$0, propKey, propValue);
              }
          }
        target$jscomp$0.push(">");
        pushInnerHTML(target$jscomp$0, innerHTML, children);
        if ("string" === typeof children) {
          target$jscomp$0.push(escapeTextForBrowser(children));
          var JSCompiler_inline_result = null;
        } else JSCompiler_inline_result = children;
        return JSCompiler_inline_result;
      case "g":
      case "p":
      case "li":
        break;
      case "select":
        target$jscomp$0.push(startChunkForTag("select"));
        var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
        for (propKey$jscomp$0 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$0)) {
            var propValue$jscomp$0 = props[propKey$jscomp$0];
            if (null != propValue$jscomp$0)
              switch (propKey$jscomp$0) {
                case "children":
                  children$jscomp$0 = propValue$jscomp$0;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$0 = propValue$jscomp$0;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$0,
                    propValue$jscomp$0
                  );
              }
          }
        target$jscomp$0.push(">");
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
        return children$jscomp$0;
      case "option":
        var selectedValue = formatContext.selectedValue;
        target$jscomp$0.push(startChunkForTag("option"));
        var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
        for (propKey$jscomp$1 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$1)) {
            var propValue$jscomp$1 = props[propKey$jscomp$1];
            if (null != propValue$jscomp$1)
              switch (propKey$jscomp$1) {
                case "children":
                  children$jscomp$1 = propValue$jscomp$1;
                  break;
                case "selected":
                  selected = propValue$jscomp$1;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$1 = propValue$jscomp$1;
                  break;
                case "value":
                  value = propValue$jscomp$1;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$1,
                    propValue$jscomp$1
                  );
              }
          }
        if (null != selectedValue) {
          var stringValue = null !== value ? "" + value : flattenOptionChildren(children$jscomp$1);
          if (isArrayImpl(selectedValue))
            for (var i2 = 0; i2 < selectedValue.length; i2++) {
              if ("" + selectedValue[i2] === stringValue) {
                target$jscomp$0.push(' selected=""');
                break;
              }
            }
          else
            "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
        } else selected && target$jscomp$0.push(' selected=""');
        target$jscomp$0.push(">");
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
        return children$jscomp$1;
      case "textarea":
        target$jscomp$0.push(startChunkForTag("textarea"));
        var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
        for (propKey$jscomp$2 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$2)) {
            var propValue$jscomp$2 = props[propKey$jscomp$2];
            if (null != propValue$jscomp$2)
              switch (propKey$jscomp$2) {
                case "children":
                  children$jscomp$2 = propValue$jscomp$2;
                  break;
                case "value":
                  value$jscomp$0 = propValue$jscomp$2;
                  break;
                case "defaultValue":
                  defaultValue = propValue$jscomp$2;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(91));
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$2,
                    propValue$jscomp$2
                  );
              }
          }
        null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
        target$jscomp$0.push(">");
        if (null != children$jscomp$2) {
          if (null != value$jscomp$0) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children$jscomp$2)) {
            if (1 < children$jscomp$2.length)
              throw Error(formatProdErrorMessage(93));
            value$jscomp$0 = "" + children$jscomp$2[0];
          }
          value$jscomp$0 = "" + children$jscomp$2;
        }
        "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push("\n");
        null !== value$jscomp$0 && target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0));
        return null;
      case "input":
        target$jscomp$0.push(startChunkForTag("input"));
        var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
        for (propKey$jscomp$3 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$3)) {
            var propValue$jscomp$3 = props[propKey$jscomp$3];
            if (null != propValue$jscomp$3)
              switch (propKey$jscomp$3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(399, "input"));
                case "name":
                  name = propValue$jscomp$3;
                  break;
                case "formAction":
                  formAction = propValue$jscomp$3;
                  break;
                case "formEncType":
                  formEncType = propValue$jscomp$3;
                  break;
                case "formMethod":
                  formMethod = propValue$jscomp$3;
                  break;
                case "formTarget":
                  formTarget = propValue$jscomp$3;
                  break;
                case "defaultChecked":
                  defaultChecked = propValue$jscomp$3;
                  break;
                case "defaultValue":
                  defaultValue$jscomp$0 = propValue$jscomp$3;
                  break;
                case "checked":
                  checked = propValue$jscomp$3;
                  break;
                case "value":
                  value$jscomp$1 = propValue$jscomp$3;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$3,
                    propValue$jscomp$3
                  );
              }
          }
        var formData = pushFormActionAttribute(
          target$jscomp$0,
          resumableState,
          renderState,
          formAction,
          formEncType,
          formMethod,
          formTarget,
          name
        );
        null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
        null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
        target$jscomp$0.push("/>");
        null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
        return null;
      case "button":
        target$jscomp$0.push(startChunkForTag("button"));
        var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
        for (propKey$jscomp$4 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$4)) {
            var propValue$jscomp$4 = props[propKey$jscomp$4];
            if (null != propValue$jscomp$4)
              switch (propKey$jscomp$4) {
                case "children":
                  children$jscomp$3 = propValue$jscomp$4;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$2 = propValue$jscomp$4;
                  break;
                case "name":
                  name$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formAction":
                  formAction$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formEncType":
                  formEncType$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formMethod":
                  formMethod$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formTarget":
                  formTarget$jscomp$0 = propValue$jscomp$4;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$4,
                    propValue$jscomp$4
                  );
              }
          }
        var formData$jscomp$0 = pushFormActionAttribute(
          target$jscomp$0,
          resumableState,
          renderState,
          formAction$jscomp$0,
          formEncType$jscomp$0,
          formMethod$jscomp$0,
          formTarget$jscomp$0,
          name$jscomp$0
        );
        target$jscomp$0.push(">");
        null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
        if ("string" === typeof children$jscomp$3) {
          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
          var JSCompiler_inline_result$jscomp$0 = null;
        } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
        return JSCompiler_inline_result$jscomp$0;
      case "form":
        target$jscomp$0.push(startChunkForTag("form"));
        var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
        for (propKey$jscomp$5 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$5)) {
            var propValue$jscomp$5 = props[propKey$jscomp$5];
            if (null != propValue$jscomp$5)
              switch (propKey$jscomp$5) {
                case "children":
                  children$jscomp$4 = propValue$jscomp$5;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$3 = propValue$jscomp$5;
                  break;
                case "action":
                  formAction$jscomp$1 = propValue$jscomp$5;
                  break;
                case "encType":
                  formEncType$jscomp$1 = propValue$jscomp$5;
                  break;
                case "method":
                  formMethod$jscomp$1 = propValue$jscomp$5;
                  break;
                case "target":
                  formTarget$jscomp$1 = propValue$jscomp$5;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$5,
                    propValue$jscomp$5
                  );
              }
          }
        var formData$jscomp$1 = null, formActionName = null;
        if ("function" === typeof formAction$jscomp$1) {
          var customFields = getCustomFormFields(
            resumableState,
            formAction$jscomp$1
          );
          null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
            " ",
            "action",
            '="',
            actionJavaScriptURL,
            '"'
          ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
        null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
        null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
        null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
        target$jscomp$0.push(">");
        null !== formActionName && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push("/>"), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
        if ("string" === typeof children$jscomp$4) {
          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
          var JSCompiler_inline_result$jscomp$1 = null;
        } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
        return JSCompiler_inline_result$jscomp$1;
      case "menuitem":
        target$jscomp$0.push(startChunkForTag("menuitem"));
        for (var propKey$jscomp$6 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$6)) {
            var propValue$jscomp$6 = props[propKey$jscomp$6];
            if (null != propValue$jscomp$6)
              switch (propKey$jscomp$6) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(400));
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$6,
                    propValue$jscomp$6
                  );
              }
          }
        target$jscomp$0.push(">");
        return null;
      case "object":
        target$jscomp$0.push(startChunkForTag("object"));
        var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
        for (propKey$jscomp$7 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$7)) {
            var propValue$jscomp$7 = props[propKey$jscomp$7];
            if (null != propValue$jscomp$7)
              switch (propKey$jscomp$7) {
                case "children":
                  children$jscomp$5 = propValue$jscomp$7;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$4 = propValue$jscomp$7;
                  break;
                case "data":
                  var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                  if ("" === sanitizedValue) break;
                  target$jscomp$0.push(
                    " ",
                    "data",
                    '="',
                    escapeTextForBrowser(sanitizedValue),
                    '"'
                  );
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$7,
                    propValue$jscomp$7
                  );
              }
          }
        target$jscomp$0.push(">");
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
        if ("string" === typeof children$jscomp$5) {
          target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
          var JSCompiler_inline_result$jscomp$2 = null;
        } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
        return JSCompiler_inline_result$jscomp$2;
      case "title":
        var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
        if (4 === formatContext.insertionMode || noscriptTagInScope || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(
            target$jscomp$0,
            props
          );
        else
          isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
        return JSCompiler_inline_result$jscomp$3;
      case "link":
        var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
          pushLinkImpl(target$jscomp$0, props);
          var JSCompiler_inline_result$jscomp$4 = null;
        } else if ("stylesheet" === props.rel)
          if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)
            JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
              target$jscomp$0,
              props
            );
          else {
            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
            if (null !== resourceState) {
              resumableState.styleResources[href] = null;
              styleQueue || (styleQueue = {
                precedence: escapeTextForBrowser(precedence),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue));
              var resource = {
                state: 0,
                props: assign({}, props, {
                  "data-precedence": props.precedence,
                  precedence: null
                })
              };
              if (resourceState) {
                2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                var preloadResource = renderState.preloads.stylesheets.get(href);
                preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
              }
              styleQueue.sheets.set(href, resource);
              hoistableState && hoistableState.stylesheets.add(resource);
            } else if (styleQueue) {
              var resource$9 = styleQueue.sheets.get(href);
              resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
            }
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$4 = null;
          }
        else
          props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
            target$jscomp$0,
            props
          ) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$4 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
        return JSCompiler_inline_result$jscomp$4;
      case "script":
        var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
        if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || noscriptTagInScope$jscomp$1 || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(
            target$jscomp$0,
            props
          );
        else {
          var key = props.src;
          if ("module" === props.type) {
            var resources = resumableState.moduleScriptResources;
            var preloads = renderState.preloads.moduleScripts;
          } else
            resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
          var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
          if (null !== resourceState$jscomp$0) {
            resources[key] = null;
            var scriptProps = props;
            if (resourceState$jscomp$0) {
              2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
              var preloadResource$jscomp$0 = preloads.get(key);
              preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
            }
            var resource$jscomp$0 = [];
            renderState.scripts.add(resource$jscomp$0);
            pushScriptImpl(resource$jscomp$0, scriptProps);
          }
          textEmbedded && target$jscomp$0.push("<!-- -->");
          JSCompiler_inline_result$jscomp$5 = null;
        }
        return JSCompiler_inline_result$jscomp$5;
      case "style":
        var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1, precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
          target$jscomp$0.push(startChunkForTag("style"));
          var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
          for (propKey$jscomp$8 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$8)) {
              var propValue$jscomp$8 = props[propKey$jscomp$8];
              if (null != propValue$jscomp$8)
                switch (propKey$jscomp$8) {
                  case "children":
                    children$jscomp$6 = propValue$jscomp$8;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$5 = propValue$jscomp$8;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$8,
                      propValue$jscomp$8
                    );
                }
            }
          target$jscomp$0.push(">");
          var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
          "function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(("" + child).replace(styleRegex, styleReplacer));
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
          target$jscomp$0.push(endChunkForTag("style"));
          var JSCompiler_inline_result$jscomp$6 = null;
        } else {
          var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
          if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
            resumableState.styleResources[href$jscomp$0] = null;
            styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
              precedence: escapeTextForBrowser(precedence$jscomp$0),
              rules: [],
              hrefs: [],
              sheets: /* @__PURE__ */ new Map()
            }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
            var nonceStyle = renderState.nonce.style;
            if (!nonceStyle || nonceStyle === nonce) {
              styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser(href$jscomp$0));
              var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
              for (propKey$jscomp$9 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                  var propValue$jscomp$9 = props[propKey$jscomp$9];
                  if (null != propValue$jscomp$9)
                    switch (propKey$jscomp$9) {
                      case "children":
                        children$jscomp$7 = propValue$jscomp$9;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$6 = propValue$jscomp$9;
                    }
                }
              var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              "function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(
                ("" + child$jscomp$0).replace(styleRegex, styleReplacer)
              );
              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);
            }
          }
          styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
          textEmbedded && target$jscomp$0.push("<!-- -->");
          JSCompiler_inline_result$jscomp$6 = void 0;
        }
        return JSCompiler_inline_result$jscomp$6;
      case "meta":
        var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$3 || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(
            target$jscomp$0,
            props,
            "meta"
          );
        else
          textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$7 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
        return JSCompiler_inline_result$jscomp$7;
      case "listing":
      case "pre":
        target$jscomp$0.push(startChunkForTag(type));
        var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
        for (propKey$jscomp$10 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$10)) {
            var propValue$jscomp$10 = props[propKey$jscomp$10];
            if (null != propValue$jscomp$10)
              switch (propKey$jscomp$10) {
                case "children":
                  children$jscomp$8 = propValue$jscomp$10;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$7 = propValue$jscomp$10;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$10,
                    propValue$jscomp$10
                  );
              }
          }
        target$jscomp$0.push(">");
        if (null != innerHTML$jscomp$7) {
          if (null != children$jscomp$8) throw Error(formatProdErrorMessage(60));
          if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
            throw Error(formatProdErrorMessage(61));
          var html = innerHTML$jscomp$7.__html;
          null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push("\n", html) : target$jscomp$0.push("" + html));
        }
        "string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push("\n");
        return children$jscomp$8;
      case "img":
        var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
        if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
          null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
          var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
          if (resource$jscomp$1) {
            if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
              promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
          } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
            resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
            var input = props.crossOrigin;
            var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
            var headers = renderState.headers, header;
            headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
              imageSrcSet: props.srcSet,
              imageSizes: props.sizes,
              crossOrigin: JSCompiler_inline_result$jscomp$8,
              integrity: props.integrity,
              nonce: props.nonce,
              type: props.type,
              fetchPriority: props.fetchPriority,
              referrerPolicy: props.refererPolicy
            }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
              rel: "preload",
              as: "image",
              href: srcSet ? void 0 : src,
              imageSrcSet: srcSet,
              imageSizes: sizes,
              crossOrigin: JSCompiler_inline_result$jscomp$8,
              integrity: props.integrity,
              type: props.type,
              fetchPriority: props.fetchPriority,
              referrerPolicy: props.referrerPolicy
            }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
          }
        }
        return pushSelfClosing(target$jscomp$0, props, "img");
      case "base":
      case "area":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "param":
      case "source":
      case "track":
      case "wbr":
        return pushSelfClosing(target$jscomp$0, props, type);
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        break;
      case "head":
        if (2 > formatContext.insertionMode) {
          var preamble = preambleState || renderState.preamble;
          if (preamble.headChunks)
            throw Error(formatProdErrorMessage(545, "`<head>`"));
          null !== preambleState && target$jscomp$0.push("<!--head-->");
          preamble.headChunks = [];
          var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
            preamble.headChunks,
            props,
            "head"
          );
        } else
          JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "head"
          );
        return JSCompiler_inline_result$jscomp$9;
      case "body":
        if (2 > formatContext.insertionMode) {
          var preamble$jscomp$0 = preambleState || renderState.preamble;
          if (preamble$jscomp$0.bodyChunks)
            throw Error(formatProdErrorMessage(545, "`<body>`"));
          null !== preambleState && target$jscomp$0.push("<!--body-->");
          preamble$jscomp$0.bodyChunks = [];
          var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
            preamble$jscomp$0.bodyChunks,
            props,
            "body"
          );
        } else
          JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "body"
          );
        return JSCompiler_inline_result$jscomp$10;
      case "html":
        if (0 === formatContext.insertionMode) {
          var preamble$jscomp$1 = preambleState || renderState.preamble;
          if (preamble$jscomp$1.htmlChunks)
            throw Error(formatProdErrorMessage(545, "`<html>`"));
          null !== preambleState && target$jscomp$0.push("<!--html-->");
          preamble$jscomp$1.htmlChunks = [""];
          var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
            preamble$jscomp$1.htmlChunks,
            props,
            "html"
          );
        } else
          JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "html"
          );
        return JSCompiler_inline_result$jscomp$11;
      default:
        if (-1 !== type.indexOf("-")) {
          target$jscomp$0.push(startChunkForTag(type));
          var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
          for (propKey$jscomp$11 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$11)) {
              var propValue$jscomp$11 = props[propKey$jscomp$11];
              if (null != propValue$jscomp$11) {
                var attributeName = propKey$jscomp$11;
                switch (propKey$jscomp$11) {
                  case "children":
                    children$jscomp$9 = propValue$jscomp$11;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$8 = propValue$jscomp$11;
                    break;
                  case "style":
                    pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "ref":
                    break;
                  case "className":
                    attributeName = "class";
                  default:
                    if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                      if (true === propValue$jscomp$11) propValue$jscomp$11 = "";
                      else if ("object" === typeof propValue$jscomp$11) continue;
                      target$jscomp$0.push(
                        " ",
                        attributeName,
                        '="',
                        escapeTextForBrowser(propValue$jscomp$11),
                        '"'
                      );
                    }
                }
              }
            }
          target$jscomp$0.push(">");
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
          return children$jscomp$9;
        }
    }
    return pushStartGenericElement(target$jscomp$0, props, type);
  }
  __name(pushStartInstance, "pushStartInstance");
  var endTagCache = /* @__PURE__ */ new Map();
  function endChunkForTag(tag2) {
    var chunk = endTagCache.get(tag2);
    void 0 === chunk && (chunk = "</" + tag2 + ">", endTagCache.set(tag2, chunk));
    return chunk;
  }
  __name(endChunkForTag, "endChunkForTag");
  function hoistPreambleState(renderState, preambleState) {
    renderState = renderState.preamble;
    null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
    null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
    null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
  }
  __name(hoistPreambleState, "hoistPreambleState");
  function writeBootstrap(destination, renderState) {
    renderState = renderState.bootstrapChunks;
    for (var i2 = 0; i2 < renderState.length - 1; i2++)
      destination.push(renderState[i2]);
    return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, destination.push(i2)) : true;
  }
  __name(writeBootstrap, "writeBootstrap");
  function writeStartPendingSuspenseBoundary(destination, renderState, id) {
    destination.push('<!--$?--><template id="');
    if (null === id) throw Error(formatProdErrorMessage(395));
    destination.push(renderState.boundaryPrefix);
    renderState = id.toString(16);
    destination.push(renderState);
    return destination.push('"></template>');
  }
  __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
  function writeStartSegment(destination, renderState, formatContext, id) {
    switch (formatContext.insertionMode) {
      case 0:
      case 1:
      case 3:
      case 2:
        return destination.push('<div hidden id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 4:
        return destination.push('<svg aria-hidden="true" style="display:none" id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 5:
        return destination.push('<math aria-hidden="true" style="display:none" id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 6:
        return destination.push('<table hidden id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 7:
        return destination.push('<table hidden><tbody id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 8:
        return destination.push('<table hidden><tr id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      case 9:
        return destination.push('<table hidden><colgroup id="'), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push('">');
      default:
        throw Error(formatProdErrorMessage(397));
    }
  }
  __name(writeStartSegment, "writeStartSegment");
  function writeEndSegment(destination, formatContext) {
    switch (formatContext.insertionMode) {
      case 0:
      case 1:
      case 3:
      case 2:
        return destination.push("</div>");
      case 4:
        return destination.push("</svg>");
      case 5:
        return destination.push("</math>");
      case 6:
        return destination.push("</table>");
      case 7:
        return destination.push("</tbody></table>");
      case 8:
        return destination.push("</tr></table>");
      case 9:
        return destination.push("</colgroup></table>");
      default:
        throw Error(formatProdErrorMessage(397));
    }
  }
  __name(writeEndSegment, "writeEndSegment");
  var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
  function escapeJSStringsForInstructionScripts(input) {
    return JSON.stringify(input).replace(
      regexForJSStringsInInstructionScripts,
      function(match) {
        switch (match) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error(
              "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
    );
  }
  __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
  var regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
  function escapeJSObjectForInstructionScripts(input) {
    return JSON.stringify(input).replace(
      regexForJSStringsInScripts,
      function(match) {
        switch (match) {
          case "&":
            return "\\u0026";
          case ">":
            return "\\u003e";
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error(
              "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
    );
  }
  __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
  var currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true;
  function flushStyleTagsLateForBoundary(styleQueue) {
    var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i2 = 0;
    if (hrefs.length) {
      this.push(currentlyFlushingRenderState.startInlineStyle);
      this.push(' media="not all" data-precedence="');
      this.push(styleQueue.precedence);
      for (this.push('" data-href="'); i2 < hrefs.length - 1; i2++)
        this.push(hrefs[i2]), this.push(" ");
      this.push(hrefs[i2]);
      this.push('">');
      for (i2 = 0; i2 < rules.length; i2++) this.push(rules[i2]);
      destinationHasCapacity = this.push("</style>");
      currentlyRenderingBoundaryHasStylesToHoist = true;
      rules.length = 0;
      hrefs.length = 0;
    }
  }
  __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
  function hasStylesToHoist(stylesheet) {
    return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
  }
  __name(hasStylesToHoist, "hasStylesToHoist");
  function writeHoistablesForBoundary(destination, hoistableState, renderState) {
    currentlyRenderingBoundaryHasStylesToHoist = false;
    destinationHasCapacity = true;
    currentlyFlushingRenderState = renderState;
    hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
    currentlyFlushingRenderState = null;
    hoistableState.stylesheets.forEach(hasStylesToHoist);
    currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
    return destinationHasCapacity;
  }
  __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
  function flushResource(resource) {
    for (var i2 = 0; i2 < resource.length; i2++) this.push(resource[i2]);
    resource.length = 0;
  }
  __name(flushResource, "flushResource");
  var stylesheetFlushingQueue = [];
  function flushStyleInPreamble(stylesheet) {
    pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
    for (var i2 = 0; i2 < stylesheetFlushingQueue.length; i2++)
      this.push(stylesheetFlushingQueue[i2]);
    stylesheetFlushingQueue.length = 0;
    stylesheet.state = 2;
  }
  __name(flushStyleInPreamble, "flushStyleInPreamble");
  function flushStylesInPreamble(styleQueue) {
    var hasStylesheets = 0 < styleQueue.sheets.size;
    styleQueue.sheets.forEach(flushStyleInPreamble, this);
    styleQueue.sheets.clear();
    var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
    if (!hasStylesheets || hrefs.length) {
      this.push(currentlyFlushingRenderState.startInlineStyle);
      this.push(' data-precedence="');
      this.push(styleQueue.precedence);
      styleQueue = 0;
      if (hrefs.length) {
        for (this.push('" data-href="'); styleQueue < hrefs.length - 1; styleQueue++)
          this.push(hrefs[styleQueue]), this.push(" ");
        this.push(hrefs[styleQueue]);
      }
      this.push('">');
      for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
        this.push(rules[styleQueue]);
      this.push("</style>");
      rules.length = 0;
      hrefs.length = 0;
    }
  }
  __name(flushStylesInPreamble, "flushStylesInPreamble");
  function preloadLateStyle(stylesheet) {
    if (0 === stylesheet.state) {
      stylesheet.state = 1;
      var props = stylesheet.props;
      pushLinkImpl(stylesheetFlushingQueue, {
        rel: "preload",
        as: "style",
        href: stylesheet.props.href,
        crossOrigin: props.crossOrigin,
        fetchPriority: props.fetchPriority,
        integrity: props.integrity,
        media: props.media,
        hrefLang: props.hrefLang,
        referrerPolicy: props.referrerPolicy
      });
      for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
        this.push(stylesheetFlushingQueue[stylesheet]);
      stylesheetFlushingQueue.length = 0;
    }
  }
  __name(preloadLateStyle, "preloadLateStyle");
  function preloadLateStyles(styleQueue) {
    styleQueue.sheets.forEach(preloadLateStyle, this);
    styleQueue.sheets.clear();
  }
  __name(preloadLateStyles, "preloadLateStyles");
  function pushCompletedShellIdAttribute(target, resumableState) {
    0 === (resumableState.instructions & 32) && (resumableState.instructions |= 32, target.push(
      ' id="',
      escapeTextForBrowser("_" + resumableState.idPrefix + "R_"),
      '"'
    ));
  }
  __name(pushCompletedShellIdAttribute, "pushCompletedShellIdAttribute");
  function writeStyleResourceDependenciesInJS(destination, hoistableState) {
    destination.push("[");
    var nextArrayOpenBrackChunk = "[";
    hoistableState.stylesheets.forEach(function(resource) {
      if (2 !== resource.state)
        if (3 === resource.state)
          destination.push(nextArrayOpenBrackChunk), resource = escapeJSObjectForInstructionScripts(
            "" + resource.props.href
          ), destination.push(resource), destination.push("]"), nextArrayOpenBrackChunk = ",[";
        else {
          destination.push(nextArrayOpenBrackChunk);
          var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
          coercedHref = escapeJSObjectForInstructionScripts(coercedHref);
          destination.push(coercedHref);
          precedence = "" + precedence;
          destination.push(",");
          precedence = escapeJSObjectForInstructionScripts(precedence);
          destination.push(precedence);
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
              switch (propKey) {
                case "href":
                case "rel":
                case "precedence":
                case "data-precedence":
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(399, "link"));
                default:
                  writeStyleResourceAttributeInJS(
                    destination,
                    propKey,
                    precedence
                  );
              }
          destination.push("]");
          nextArrayOpenBrackChunk = ",[";
          resource.state = 3;
        }
    });
    destination.push("]");
  }
  __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
  function writeStyleResourceAttributeInJS(destination, name, value) {
    var attributeName = name.toLowerCase();
    switch (typeof value) {
      case "function":
      case "symbol":
        return;
    }
    switch (name) {
      case "innerHTML":
      case "dangerouslySetInnerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "style":
      case "ref":
        return;
      case "className":
        attributeName = "class";
        name = "" + value;
        break;
      case "hidden":
        if (false === value) return;
        name = "";
        break;
      case "src":
      case "href":
        value = sanitizeURL(value);
        name = "" + value;
        break;
      default:
        if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
          return;
        name = "" + value;
    }
    destination.push(",");
    attributeName = escapeJSObjectForInstructionScripts(attributeName);
    destination.push(attributeName);
    destination.push(",");
    attributeName = escapeJSObjectForInstructionScripts(name);
    destination.push(attributeName);
  }
  __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
  function createHoistableState() {
    return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set(), suspenseyImages: false };
  }
  __name(createHoistableState, "createHoistableState");
  function prefetchDNS(href) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if ("string" === typeof href && href) {
        if (!resumableState.dnsResources.hasOwnProperty(href)) {
          resumableState.dnsResources[href] = null;
          resumableState = renderState.headers;
          var header, JSCompiler_temp;
          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
            JSCompiler_temp = (header = "<" + ("" + href).replace(
              regexForHrefInLinkHeaderURLContext,
              escapeHrefForLinkHeaderURLContextReplacer
            ) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
          JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.D(href);
  }
  __name(prefetchDNS, "prefetchDNS");
  function preconnect(href, crossOrigin) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if ("string" === typeof href && href) {
        var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
        if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
          resumableState.connectResources[bucket][href] = null;
          resumableState = renderState.headers;
          var header, JSCompiler_temp;
          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
            JSCompiler_temp = "<" + ("" + href).replace(
              regexForHrefInLinkHeaderURLContext,
              escapeHrefForLinkHeaderURLContextReplacer
            ) + ">; rel=preconnect";
            if ("string" === typeof crossOrigin) {
              var escapedCrossOrigin = ("" + crossOrigin).replace(
                regexForLinkHeaderQuotedParamValueContext,
                escapeStringForLinkHeaderQuotedParamValueContextReplacer
              );
              JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
            }
            JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
          }
          JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
            rel: "preconnect",
            href,
            crossOrigin
          }), renderState.preconnects.add(bucket));
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.C(href, crossOrigin);
  }
  __name(preconnect, "preconnect");
  function preload(href, as, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (as && href) {
        switch (as) {
          case "image":
            if (options) {
              var imageSrcSet = options.imageSrcSet;
              var imageSizes = options.imageSizes;
              var fetchPriority = options.fetchPriority;
            }
            var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
            if (resumableState.imageResources.hasOwnProperty(key)) return;
            resumableState.imageResources[key] = PRELOAD_NO_CREDS;
            resumableState = renderState.headers;
            var header;
            resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
              resumableState,
              assign(
                { rel: "preload", href: imageSrcSet ? void 0 : href, as },
                options
              )
            ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
            break;
          case "style":
            if (resumableState.styleResources.hasOwnProperty(href)) return;
            imageSrcSet = [];
            pushLinkImpl(
              imageSrcSet,
              assign({ rel: "preload", href, as }, options)
            );
            resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            renderState.preloads.stylesheets.set(href, imageSrcSet);
            renderState.bulkPreloads.add(imageSrcSet);
            break;
          case "script":
            if (resumableState.scriptResources.hasOwnProperty(href)) return;
            imageSrcSet = [];
            renderState.preloads.scripts.set(href, imageSrcSet);
            renderState.bulkPreloads.add(imageSrcSet);
            pushLinkImpl(
              imageSrcSet,
              assign({ rel: "preload", href, as }, options)
            );
            resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            break;
          default:
            if (resumableState.unknownResources.hasOwnProperty(as)) {
              if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                return;
            } else
              imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
            imageSrcSet[href] = PRELOAD_NO_CREDS;
            if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
              renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
            else
              switch (resumableState = [], href = assign({ rel: "preload", href, as }, options), pushLinkImpl(resumableState, href), as) {
                case "font":
                  renderState.fontPreloads.add(resumableState);
                  break;
                default:
                  renderState.bulkPreloads.add(resumableState);
              }
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.L(href, as, options);
  }
  __name(preload, "preload");
  function preloadModule(href, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (href) {
        var as = options && "string" === typeof options.as ? options.as : "script";
        switch (as) {
          case "script":
            if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
            as = [];
            resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            renderState.preloads.moduleScripts.set(href, as);
            break;
          default:
            if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
              var resources = resumableState.unknownResources[as];
              if (resources.hasOwnProperty(href)) return;
            } else
              resources = {}, resumableState.moduleUnknownResources[as] = resources;
            as = [];
            resources[href] = PRELOAD_NO_CREDS;
        }
        pushLinkImpl(as, assign({ rel: "modulepreload", href }, options));
        renderState.bulkPreloads.add(as);
        enqueueFlush(request);
      }
    } else previousDispatcher.m(href, options);
  }
  __name(preloadModule, "preloadModule");
  function preinitStyle(href, precedence, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (href) {
        precedence = precedence || "default";
        var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
        null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
          precedence: escapeTextForBrowser(precedence),
          rules: [],
          hrefs: [],
          sheets: /* @__PURE__ */ new Map()
        }, renderState.styles.set(precedence, styleQueue)), precedence = {
          state: 0,
          props: assign(
            { rel: "stylesheet", href, "data-precedence": precedence },
            options
          )
        }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
      }
    } else previousDispatcher.S(href, precedence, options);
  }
  __name(preinitStyle, "preinitStyle");
  function preinitScript(src, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (src) {
        var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
        null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
      }
    } else previousDispatcher.X(src, options);
  }
  __name(preinitScript, "preinitScript");
  function preinitModuleScript(src, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (src) {
        var resourceState = resumableState.moduleScriptResources.hasOwnProperty(
          src
        ) ? resumableState.moduleScriptResources[src] : void 0;
        null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: "module", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
      }
    } else previousDispatcher.M(src, options);
  }
  __name(preinitModuleScript, "preinitModuleScript");
  function adoptPreloadCredentials(target, preloadState) {
    null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
    null == target.integrity && (target.integrity = preloadState[1]);
  }
  __name(adoptPreloadCredentials, "adoptPreloadCredentials");
  function getPreloadAsHeader(href, as, params) {
    href = ("" + href).replace(
      regexForHrefInLinkHeaderURLContext,
      escapeHrefForLinkHeaderURLContextReplacer
    );
    as = ("" + as).replace(
      regexForLinkHeaderQuotedParamValueContext,
      escapeStringForLinkHeaderQuotedParamValueContextReplacer
    );
    as = "<" + href + '>; rel=preload; as="' + as + '"';
    for (var paramName in params)
      hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + ("" + href).replace(
        regexForLinkHeaderQuotedParamValueContext,
        escapeStringForLinkHeaderQuotedParamValueContextReplacer
      ) + '"'));
    return as;
  }
  __name(getPreloadAsHeader, "getPreloadAsHeader");
  var regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
  function escapeHrefForLinkHeaderURLContextReplacer(match) {
    switch (match) {
      case "<":
        return "%3C";
      case ">":
        return "%3E";
      case "\n":
        return "%0A";
      case "\r":
        return "%0D";
      default:
        throw Error(
          "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
        );
    }
  }
  __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
  var regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
  function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
    switch (match) {
      case '"':
        return "%22";
      case "'":
        return "%27";
      case ";":
        return "%3B";
      case ",":
        return "%2C";
      case "\n":
        return "%0A";
      case "\r":
        return "%0D";
      default:
        throw Error(
          "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
        );
    }
  }
  __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
  function hoistStyleQueueDependency(styleQueue) {
    this.styles.add(styleQueue);
  }
  __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
  function hoistStylesheetDependency(stylesheet) {
    this.stylesheets.add(stylesheet);
  }
  __name(hoistStylesheetDependency, "hoistStylesheetDependency");
  function hoistHoistables(parentState, childState) {
    childState.styles.forEach(hoistStyleQueueDependency, parentState);
    childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
    childState.suspenseyImages && (parentState.suspenseyImages = true);
  }
  __name(hoistHoistables, "hoistHoistables");
  function createRenderState(resumableState, generateStaticMarkup) {
    var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
    void 0 !== bootstrapScriptContent && (bootstrapChunks.push("<script"), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
      ">",
      ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer),
      "<\/script>"
    ));
    bootstrapScriptContent = idPrefix + "P:";
    var JSCompiler_object_inline_segmentPrefix_1673 = idPrefix + "S:";
    idPrefix += "B:";
    var JSCompiler_object_inline_preconnects_1687 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_fontPreloads_1688 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_highImagePreloads_1689 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_styles_1690 = /* @__PURE__ */ new Map(), JSCompiler_object_inline_bootstrapScripts_1691 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_scripts_1692 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_bulkPreloads_1693 = /* @__PURE__ */ new Set(), JSCompiler_object_inline_preloads_1694 = {
      images: /* @__PURE__ */ new Map(),
      stylesheets: /* @__PURE__ */ new Map(),
      scripts: /* @__PURE__ */ new Map(),
      moduleScripts: /* @__PURE__ */ new Map()
    };
    if (void 0 !== bootstrapScripts)
      for (var i2 = 0; i2 < bootstrapScripts.length; i2++) {
        var scriptConfig = bootstrapScripts[i2], src, crossOrigin = void 0, integrity = void 0, props = {
          rel: "preload",
          as: "script",
          fetchPriority: "low",
          nonce: void 0
        };
        "string" === typeof scriptConfig ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = "string" === typeof scriptConfig.integrity ? scriptConfig.integrity : void 0, props.crossOrigin = crossOrigin = "string" === typeof scriptConfig || null == scriptConfig.crossOrigin ? void 0 : "use-credentials" === scriptConfig.crossOrigin ? "use-credentials" : "");
        scriptConfig = resumableState;
        var href = src;
        scriptConfig.scriptResources[href] = null;
        scriptConfig.moduleScriptResources[href] = null;
        scriptConfig = [];
        pushLinkImpl(scriptConfig, props);
        JSCompiler_object_inline_bootstrapScripts_1691.add(scriptConfig);
        bootstrapChunks.push('<script src="', escapeTextForBrowser(src), '"');
        "string" === typeof integrity && bootstrapChunks.push(
          ' integrity="',
          escapeTextForBrowser(integrity),
          '"'
        );
        "string" === typeof crossOrigin && bootstrapChunks.push(
          ' crossorigin="',
          escapeTextForBrowser(crossOrigin),
          '"'
        );
        pushCompletedShellIdAttribute(bootstrapChunks, resumableState);
        bootstrapChunks.push(' async=""><\/script>');
      }
    if (void 0 !== bootstrapModules)
      for (bootstrapScripts = 0; bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
        props = bootstrapModules[bootstrapScripts], crossOrigin = src = void 0, integrity = {
          rel: "modulepreload",
          fetchPriority: "low",
          nonce: void 0
        }, "string" === typeof props ? integrity.href = i2 = props : (integrity.href = i2 = props.src, integrity.integrity = crossOrigin = "string" === typeof props.integrity ? props.integrity : void 0, integrity.crossOrigin = src = "string" === typeof props || null == props.crossOrigin ? void 0 : "use-credentials" === props.crossOrigin ? "use-credentials" : ""), props = resumableState, scriptConfig = i2, props.scriptResources[scriptConfig] = null, props.moduleScriptResources[scriptConfig] = null, props = [], pushLinkImpl(props, integrity), JSCompiler_object_inline_bootstrapScripts_1691.add(props), bootstrapChunks.push(
          '<script type="module" src="',
          escapeTextForBrowser(i2),
          '"'
        ), "string" === typeof crossOrigin && bootstrapChunks.push(
          ' integrity="',
          escapeTextForBrowser(crossOrigin),
          '"'
        ), "string" === typeof src && bootstrapChunks.push(
          ' crossorigin="',
          escapeTextForBrowser(src),
          '"'
        ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(' async=""><\/script>');
    return {
      placeholderPrefix: bootstrapScriptContent,
      segmentPrefix: JSCompiler_object_inline_segmentPrefix_1673,
      boundaryPrefix: idPrefix,
      startInlineScript: "<script",
      startInlineStyle: "<style",
      preamble: { htmlChunks: null, headChunks: null, bodyChunks: null },
      externalRuntimeScript: null,
      bootstrapChunks,
      importMapChunks: [],
      onHeaders: void 0,
      headers: null,
      resets: {
        font: {},
        dns: {},
        connect: { default: {}, anonymous: {}, credentials: {} },
        image: {},
        style: {}
      },
      charsetChunks: [],
      viewportChunks: [],
      hoistableChunks: [],
      preconnects: JSCompiler_object_inline_preconnects_1687,
      fontPreloads: JSCompiler_object_inline_fontPreloads_1688,
      highImagePreloads: JSCompiler_object_inline_highImagePreloads_1689,
      styles: JSCompiler_object_inline_styles_1690,
      bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1691,
      scripts: JSCompiler_object_inline_scripts_1692,
      bulkPreloads: JSCompiler_object_inline_bulkPreloads_1693,
      preloads: JSCompiler_object_inline_preloads_1694,
      nonce: { script: void 0, style: void 0 },
      stylesToHoist: false,
      generateStaticMarkup
    };
  }
  __name(createRenderState, "createRenderState");
  function pushTextInstance(target, text2, renderState, textEmbedded) {
    if (renderState.generateStaticMarkup)
      return target.push(escapeTextForBrowser(text2)), false;
    "" === text2 ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser(text2)), target = true);
    return target;
  }
  __name(pushTextInstance, "pushTextInstance");
  function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
    renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
  }
  __name(pushSegmentFinale, "pushSegmentFinale");
  var bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return type.displayName || "Context";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {
          }
      }
    return null;
  }
  __name(getComponentNameFromType, "getComponentNameFromType");
  var emptyContextObject = {}, currentActiveSnapshot = null;
  function popToNearestCommonAncestor(prev, next) {
    if (prev !== next) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      var parentNext = next.parent;
      if (null === prev) {
        if (null !== parentNext) throw Error(formatProdErrorMessage(401));
      } else {
        if (null === parentNext) throw Error(formatProdErrorMessage(401));
        popToNearestCommonAncestor(prev, parentNext);
      }
      next.context._currentValue2 = next.value;
    }
  }
  __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
  function popAllPrevious(prev) {
    prev.context._currentValue2 = prev.parentValue;
    prev = prev.parent;
    null !== prev && popAllPrevious(prev);
  }
  __name(popAllPrevious, "popAllPrevious");
  function pushAllNext(next) {
    var parentNext = next.parent;
    null !== parentNext && pushAllNext(parentNext);
    next.context._currentValue2 = next.value;
  }
  __name(pushAllNext, "pushAllNext");
  function popPreviousToCommonLevel(prev, next) {
    prev.context._currentValue2 = prev.parentValue;
    prev = prev.parent;
    if (null === prev) throw Error(formatProdErrorMessage(402));
    prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
  }
  __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
  function popNextToCommonLevel(prev, next) {
    var parentNext = next.parent;
    if (null === parentNext) throw Error(formatProdErrorMessage(402));
    prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
    next.context._currentValue2 = next.value;
  }
  __name(popNextToCommonLevel, "popNextToCommonLevel");
  function switchContext(newSnapshot) {
    var prev = currentActiveSnapshot;
    prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
  }
  __name(switchContext, "switchContext");
  var classComponentUpdater = {
    enqueueSetState: /* @__PURE__ */ __name(function(inst, payload) {
      inst = inst._reactInternals;
      null !== inst.queue && inst.queue.push(payload);
    }, "enqueueSetState"),
    enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload) {
      inst = inst._reactInternals;
      inst.replace = true;
      inst.queue = [payload];
    }, "enqueueReplaceState"),
    enqueueForceUpdate: /* @__PURE__ */ __name(function() {
    }, "enqueueForceUpdate")
  }, emptyTreeContext = { id: 1, overflow: "" };
  function pushTreeContext(baseContext, totalChildren, index2) {
    var baseIdWithLeadingBit = baseContext.id;
    baseContext = baseContext.overflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index2 += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      return {
        id: 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit,
        overflow: length + baseContext
      };
    }
    return {
      id: 1 << length | index2 << baseLength | baseIdWithLeadingBit,
      overflow: baseContext
    };
  }
  __name(pushTreeContext, "pushTreeContext");
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log5 = Math.log, LN2 = Math.LN2;
  function clz32Fallback(x) {
    x >>>= 0;
    return 0 === x ? 32 : 31 - (log5(x) / LN2 | 0) | 0;
  }
  __name(clz32Fallback, "clz32Fallback");
  function noop2() {
  }
  __name(noop2, "noop");
  var SuspenseException = Error(formatProdErrorMessage(460));
  function trackUsedThenable(thenableState2, thenable, index2) {
    index2 = thenableState2[index2];
    void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop2, noop2), thenable = index2);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        "string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
          function(fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function(error5) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error5;
            }
          }
        ));
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  __name(trackUsedThenable, "trackUsedThenable");
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  __name(getSuspendedThenable, "getSuspendedThenable");
  function is2(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  __name(is2, "is");
  var objectIs = "function" === typeof Object.is ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0;
  function resolveCurrentlyRenderingComponent() {
    if (null === currentlyRenderingComponent)
      throw Error(formatProdErrorMessage(321));
    return currentlyRenderingComponent;
  }
  __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
  function createHook() {
    if (0 < numberOfReRenders) throw Error(formatProdErrorMessage(312));
    return { memoizedState: null, queue: null, next: null };
  }
  __name(createHook, "createHook");
  function createWorkInProgressHook() {
    null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
    return workInProgressHook;
  }
  __name(createWorkInProgressHook, "createWorkInProgressHook");
  function getThenableStateAfterSuspending() {
    var state = thenableState;
    thenableState = null;
    return state;
  }
  __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
  function resetHooksState() {
    currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
    didScheduleRenderPhaseUpdate = false;
    firstWorkInProgressHook = null;
    numberOfReRenders = 0;
    workInProgressHook = renderPhaseUpdates = null;
  }
  __name(resetHooksState, "resetHooksState");
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  __name(basicStateReducer, "basicStateReducer");
  function useReducer(reducer, initialArg, init) {
    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
    workInProgressHook = createWorkInProgressHook();
    if (isReRender) {
      var queue = workInProgressHook.queue;
      initialArg = queue.dispatch;
      if (null !== renderPhaseUpdates && (init = renderPhaseUpdates.get(queue), void 0 !== init)) {
        renderPhaseUpdates.delete(queue);
        queue = workInProgressHook.memoizedState;
        do
          queue = reducer(queue, init.action), init = init.next;
        while (null !== init);
        workInProgressHook.memoizedState = queue;
        return [queue, initialArg];
      }
      return [workInProgressHook.memoizedState, initialArg];
    }
    reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
    workInProgressHook.memoizedState = reducer;
    reducer = workInProgressHook.queue = { last: null, dispatch: null };
    reducer = reducer.dispatch = dispatchAction.bind(
      null,
      currentlyRenderingComponent,
      reducer
    );
    return [workInProgressHook.memoizedState, reducer];
  }
  __name(useReducer, "useReducer");
  function useMemo(nextCreate, deps) {
    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
    workInProgressHook = createWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    if (null !== workInProgressHook) {
      var prevState = workInProgressHook.memoizedState;
      if (null !== prevState && null !== deps) {
        var prevDeps = prevState[1];
        a: if (null === prevDeps) prevDeps = false;
        else {
          for (var i2 = 0; i2 < prevDeps.length && i2 < deps.length; i2++)
            if (!objectIs(deps[i2], prevDeps[i2])) {
              prevDeps = false;
              break a;
            }
          prevDeps = true;
        }
        if (prevDeps) return prevState[0];
      }
    }
    nextCreate = nextCreate();
    workInProgressHook.memoizedState = [nextCreate, deps];
    return nextCreate;
  }
  __name(useMemo, "useMemo");
  function dispatchAction(componentIdentity, queue, action) {
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    if (componentIdentity === currentlyRenderingComponent)
      if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
        renderPhaseUpdates.set(queue, componentIdentity);
      else {
        for (queue = action; null !== queue.next; ) queue = queue.next;
        queue.next = componentIdentity;
      }
  }
  __name(dispatchAction, "dispatchAction");
  function throwOnUseEffectEventCall() {
    throw Error(formatProdErrorMessage(440));
  }
  __name(throwOnUseEffectEventCall, "throwOnUseEffectEventCall");
  function unsupportedStartTransition() {
    throw Error(formatProdErrorMessage(394));
  }
  __name(unsupportedStartTransition, "unsupportedStartTransition");
  function unsupportedSetOptimisticState() {
    throw Error(formatProdErrorMessage(479));
  }
  __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
  function useActionState(action, initialState, permalink) {
    resolveCurrentlyRenderingComponent();
    var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
    if ("function" === typeof action.$$FORM_ACTION) {
      var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
      request = request.formState;
      var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
      if (null !== request && "function" === typeof isSignatureEqual) {
        var postbackKey = request[1];
        isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
          JSON.stringify([componentKeyPath, null, actionStateHookIndex]),
          0
        ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
      }
      var boundAction = action.bind(null, initialState);
      action = /* @__PURE__ */ __name(function(payload) {
        boundAction(payload);
      }, "action");
      "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
        prefix2 = boundAction.$$FORM_ACTION(prefix2);
        void 0 !== permalink && (permalink += "", prefix2.action = permalink);
        var formData = prefix2.data;
        formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
          JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]),
          0
        )), formData.append("$ACTION_KEY", nextPostbackStateKey));
        return prefix2;
      });
      return [initialState, action, false];
    }
    var boundAction$22 = action.bind(null, initialState);
    return [
      initialState,
      function(payload) {
        boundAction$22(payload);
      },
      false
    ];
  }
  __name(useActionState, "useActionState");
  function unwrapThenable(thenable) {
    var index2 = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    return trackUsedThenable(thenableState, thenable, index2);
  }
  __name(unwrapThenable, "unwrapThenable");
  function unsupportedRefresh() {
    throw Error(formatProdErrorMessage(393));
  }
  __name(unsupportedRefresh, "unsupportedRefresh");
  var HooksDispatcher = {
    readContext: /* @__PURE__ */ __name(function(context3) {
      return context3._currentValue2;
    }, "readContext"),
    use: /* @__PURE__ */ __name(function(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return unwrapThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return usable._currentValue2;
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }, "use"),
    useContext: /* @__PURE__ */ __name(function(context3) {
      resolveCurrentlyRenderingComponent();
      return context3._currentValue2;
    }, "useContext"),
    useMemo,
    useReducer,
    useRef: /* @__PURE__ */ __name(function(initialValue) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      var previousRef = workInProgressHook.memoizedState;
      return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;
    }, "useRef"),
    useState: /* @__PURE__ */ __name(function(initialState) {
      return useReducer(basicStateReducer, initialState);
    }, "useState"),
    useInsertionEffect: noop2,
    useLayoutEffect: noop2,
    useCallback: /* @__PURE__ */ __name(function(callback, deps) {
      return useMemo(function() {
        return callback;
      }, deps);
    }, "useCallback"),
    useImperativeHandle: noop2,
    useEffect: noop2,
    useDebugValue: noop2,
    useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
      resolveCurrentlyRenderingComponent();
      return void 0 !== initialValue ? initialValue : value;
    }, "useDeferredValue"),
    useTransition: /* @__PURE__ */ __name(function() {
      resolveCurrentlyRenderingComponent();
      return [false, unsupportedStartTransition];
    }, "useTransition"),
    useId: /* @__PURE__ */ __name(function() {
      var JSCompiler_inline_result = currentlyRenderingTask.treeContext;
      var overflow = JSCompiler_inline_result.overflow;
      JSCompiler_inline_result = JSCompiler_inline_result.id;
      JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;
      var resumableState = currentResumableState;
      if (null === resumableState) throw Error(formatProdErrorMessage(404));
      overflow = localIdCounter++;
      JSCompiler_inline_result = "_" + resumableState.idPrefix + "R_" + JSCompiler_inline_result;
      0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
      return JSCompiler_inline_result + "_";
    }, "useId"),
    useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {
      if (void 0 === getServerSnapshot)
        throw Error(formatProdErrorMessage(407));
      return getServerSnapshot();
    }, "useSyncExternalStore"),
    useOptimistic: /* @__PURE__ */ __name(function(passthrough) {
      resolveCurrentlyRenderingComponent();
      return [passthrough, unsupportedSetOptimisticState];
    }, "useOptimistic"),
    useActionState,
    useFormState: useActionState,
    useHostTransitionStatus: /* @__PURE__ */ __name(function() {
      resolveCurrentlyRenderingComponent();
      return sharedNotPendingObject;
    }, "useHostTransitionStatus"),
    useMemoCache: /* @__PURE__ */ __name(function(size) {
      for (var data = Array(size), i2 = 0; i2 < size; i2++)
        data[i2] = REACT_MEMO_CACHE_SENTINEL;
      return data;
    }, "useMemoCache"),
    useCacheRefresh: /* @__PURE__ */ __name(function() {
      return unsupportedRefresh;
    }, "useCacheRefresh"),
    useEffectEvent: /* @__PURE__ */ __name(function() {
      return throwOnUseEffectEventCall;
    }, "useEffectEvent")
  }, currentResumableState = null, DefaultAsyncDispatcher = {
    getCacheForType: /* @__PURE__ */ __name(function() {
      throw Error(formatProdErrorMessage(248));
    }, "getCacheForType"),
    cacheSignal: /* @__PURE__ */ __name(function() {
      throw Error(formatProdErrorMessage(248));
    }, "cacheSignal")
  }, prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix)
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return "\n" + prefix + name + suffix;
  }
  __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
  var reentry = false;
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
          try {
            if (construct) {
              var Fake = /* @__PURE__ */ __name(function() {
                throw Error();
              }, "Fake");
              Object.defineProperty(Fake.prototype, "props", {
                set: /* @__PURE__ */ __name(function() {
                  throw Error();
                }, "set")
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$24) {
                  control = x$24;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$25) {
                control = x$25;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
              });
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack)
              return [sample.stack, control.stack];
          }
          return [null, null];
        }, "DetermineComponentFrameRoot")
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name"
      );
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
          RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        ); )
          namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
            namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
              do
                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                  var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                  fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                  return frame;
                }
              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
            }
            break;
          }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  __name(describeNativeComponentFrame, "describeNativeComponentFrame");
  function describeComponentStackByType(type) {
    if ("string" === typeof type) return describeBuiltInComponentFrame(type);
    if ("function" === typeof type)
      return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
    if ("object" === typeof type && null !== type) {
      switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          return describeNativeComponentFrame(type.render, false);
        case REACT_MEMO_TYPE:
          return describeNativeComponentFrame(type.type, false);
        case REACT_LAZY_TYPE:
          var lazyComponent = type, payload = lazyComponent._payload;
          lazyComponent = lazyComponent._init;
          try {
            type = lazyComponent(payload);
          } catch (x) {
            return describeBuiltInComponentFrame("Lazy");
          }
          return describeComponentStackByType(type);
      }
      if ("string" === typeof type.name) {
        a: {
          payload = type.name;
          lazyComponent = type.env;
          var location = type.debugLocation;
          if (null != location && (type = Error.prepareStackTrace, Error.prepareStackTrace = void 0, location = location.stack, Error.prepareStackTrace = type, location.startsWith("Error: react-stack-top-frame\n") && (location = location.slice(29)), type = location.indexOf("\n"), -1 !== type && (location = location.slice(type + 1)), type = location.indexOf("react_stack_bottom_frame"), -1 !== type && (type = location.lastIndexOf("\n", type)), type = -1 !== type ? location = location.slice(0, type) : "", location = type.lastIndexOf("\n"), type = -1 === location ? type : type.slice(location + 1), -1 !== type.indexOf(payload))) {
            payload = "\n" + type;
            break a;
          }
          payload = describeBuiltInComponentFrame(
            payload + (lazyComponent ? " [" + lazyComponent + "]" : "")
          );
        }
        return payload;
      }
    }
    switch (type) {
      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame("SuspenseList");
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame("Suspense");
    }
    return "";
  }
  __name(describeComponentStackByType, "describeComponentStackByType");
  function isEligibleForOutlining(request, boundary) {
    return (500 < boundary.byteSize || false) && null === boundary.contentPreamble;
  }
  __name(isEligibleForOutlining, "isEligibleForOutlining");
  function defaultErrorHandler(error5) {
    if ("object" === typeof error5 && null !== error5 && "string" === typeof error5.environmentName) {
      var JSCompiler_inline_result = error5.environmentName;
      error5 = [error5].slice(0);
      "string" === typeof error5[0] ? error5.splice(
        0,
        1,
        "[%s] " + error5[0],
        " " + JSCompiler_inline_result + " "
      ) : error5.splice(0, 0, "[%s]", " " + JSCompiler_inline_result + " ");
      error5.unshift(console);
      JSCompiler_inline_result = bind.apply(console.error, error5);
      JSCompiler_inline_result();
    } else console.error(error5);
    return null;
  }
  __name(defaultErrorHandler, "defaultErrorHandler");
  function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
    var abortSet = /* @__PURE__ */ new Set();
    this.destination = null;
    this.flushScheduled = false;
    this.resumableState = resumableState;
    this.renderState = renderState;
    this.rootFormatContext = rootFormatContext;
    this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
    this.status = 10;
    this.fatalError = null;
    this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
    this.completedPreambleSegments = this.completedRootSegment = null;
    this.byteSize = 0;
    this.abortableTasks = abortSet;
    this.pingedTasks = [];
    this.clientRenderedBoundaries = [];
    this.completedBoundaries = [];
    this.partialBoundaries = [];
    this.trackedPostpones = null;
    this.onError = void 0 === onError2 ? defaultErrorHandler : onError2;
    this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
    this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
    this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
    this.onShellError = void 0 === onShellError ? noop2 : onShellError;
    this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
    this.formState = void 0 === formState ? null : formState;
  }
  __name(RequestInstance, "RequestInstance");
  function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
    resumableState = new RequestInstance(
      resumableState,
      renderState,
      rootFormatContext,
      progressiveChunkSize,
      onError2,
      onAllReady,
      onShellReady,
      onShellError,
      onFatalError,
      onPostpone,
      formState
    );
    renderState = createPendingSegment(
      resumableState,
      0,
      null,
      rootFormatContext,
      false,
      false
    );
    renderState.parentFlushed = true;
    children = createRenderTask(
      resumableState,
      null,
      children,
      -1,
      null,
      renderState,
      null,
      null,
      resumableState.abortableTasks,
      null,
      rootFormatContext,
      null,
      emptyTreeContext,
      null,
      null
    );
    pushComponentStack(children);
    resumableState.pingedTasks.push(children);
    return resumableState;
  }
  __name(createRequest2, "createRequest");
  var currentRequest = null;
  function pingTask(request, task) {
    request.pingedTasks.push(task);
    1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, performWork(request));
  }
  __name(pingTask, "pingTask");
  function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
    fallbackAbortableTasks = {
      status: 0,
      rootSegmentID: -1,
      parentFlushed: false,
      pendingTasks: 0,
      row,
      completedSegments: [],
      byteSize: 0,
      fallbackAbortableTasks,
      errorDigest: null,
      contentState: createHoistableState(),
      fallbackState: createHoistableState(),
      contentPreamble,
      fallbackPreamble,
      trackedContentKeyPath: null,
      trackedFallbackNode: null
    };
    null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables(fallbackAbortableTasks.contentState, request));
    return fallbackAbortableTasks;
  }
  __name(createSuspenseBoundary, "createSuspenseBoundary");
  function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context3, treeContext, row, componentStack) {
    request.allPendingTasks++;
    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
    null !== row && row.pendingTasks++;
    var task = {
      replay: null,
      node,
      childIndex,
      ping: /* @__PURE__ */ __name(function() {
        return pingTask(request, task);
      }, "ping"),
      blockedBoundary,
      blockedSegment,
      blockedPreamble,
      hoistableState,
      abortSet,
      keyPath,
      formatContext,
      context: context3,
      treeContext,
      row,
      componentStack,
      thenableState: thenableState2
    };
    abortSet.add(task);
    return task;
  }
  __name(createRenderTask, "createRenderTask");
  function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context3, treeContext, row, componentStack) {
    request.allPendingTasks++;
    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
    null !== row && row.pendingTasks++;
    replay.pendingTasks++;
    var task = {
      replay,
      node,
      childIndex,
      ping: /* @__PURE__ */ __name(function() {
        return pingTask(request, task);
      }, "ping"),
      blockedBoundary,
      blockedSegment: null,
      blockedPreamble: null,
      hoistableState,
      abortSet,
      keyPath,
      formatContext,
      context: context3,
      treeContext,
      row,
      componentStack,
      thenableState: thenableState2
    };
    abortSet.add(task);
    return task;
  }
  __name(createReplayTask, "createReplayTask");
  function createPendingSegment(request, index2, boundary, parentFormatContext, lastPushedText, textEmbedded) {
    return {
      status: 0,
      parentFlushed: false,
      id: -1,
      index: index2,
      chunks: [],
      children: [],
      preambleChildren: [],
      parentFormatContext,
      boundary,
      lastPushedText,
      textEmbedded
    };
  }
  __name(createPendingSegment, "createPendingSegment");
  function pushComponentStack(task) {
    var node = task.node;
    if ("object" === typeof node && null !== node)
      switch (node.$$typeof) {
        case REACT_ELEMENT_TYPE:
          task.componentStack = { parent: task.componentStack, type: node.type };
      }
  }
  __name(pushComponentStack, "pushComponentStack");
  function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
    return null === componentStack ? null : { parent: componentStack.parent, type: "Suspense Fallback" };
  }
  __name(replaceSuspenseComponentStackWithSuspenseFallbackStack, "replaceSuspenseComponentStackWithSuspenseFallbackStack");
  function getThrownInfo(node$jscomp$0) {
    var errorInfo = {};
    node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
      configurable: true,
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        try {
          var info5 = "", node = node$jscomp$0;
          do
            info5 += describeComponentStackByType(node.type), node = node.parent;
          while (node);
          var JSCompiler_inline_result = info5;
        } catch (x) {
          JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        Object.defineProperty(errorInfo, "componentStack", {
          value: JSCompiler_inline_result
        });
        return JSCompiler_inline_result;
      }, "get")
    });
    return errorInfo;
  }
  __name(getThrownInfo, "getThrownInfo");
  function logRecoverableError(request, error5, errorInfo) {
    request = request.onError;
    error5 = request(error5, errorInfo);
    if (null == error5 || "string" === typeof error5) return error5;
  }
  __name(logRecoverableError, "logRecoverableError");
  function fatalError(request, error5) {
    var onShellError = request.onShellError, onFatalError = request.onFatalError;
    onShellError(error5);
    onFatalError(error5);
    null !== request.destination ? (request.status = 14, request.destination.destroy(error5)) : (request.status = 13, request.fatalError = error5);
  }
  __name(fatalError, "fatalError");
  function finishSuspenseListRow(request, row) {
    unblockSuspenseListRow(request, row.next, row.hoistables);
  }
  __name(finishSuspenseListRow, "finishSuspenseListRow");
  function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
    for (; null !== unblockedRow; ) {
      null !== inheritedHoistables && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
      var unblockedBoundaries = unblockedRow.boundaries;
      if (null !== unblockedBoundaries) {
        unblockedRow.boundaries = null;
        for (var i2 = 0; i2 < unblockedBoundaries.length; i2++) {
          var unblockedBoundary = unblockedBoundaries[i2];
          null !== inheritedHoistables && hoistHoistables(unblockedBoundary.contentState, inheritedHoistables);
          finishedTask(request, unblockedBoundary, null, null);
        }
      }
      unblockedRow.pendingTasks--;
      if (0 < unblockedRow.pendingTasks) break;
      inheritedHoistables = unblockedRow.hoistables;
      unblockedRow = unblockedRow.next;
    }
  }
  __name(unblockSuspenseListRow, "unblockSuspenseListRow");
  function tryToResolveTogetherRow(request, togetherRow) {
    var boundaries = togetherRow.boundaries;
    if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
      for (var allCompleteAndInlinable = true, i2 = 0; i2 < boundaries.length; i2++) {
        var rowBoundary = boundaries[i2];
        if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
          allCompleteAndInlinable = false;
          break;
        }
      }
      allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
    }
  }
  __name(tryToResolveTogetherRow, "tryToResolveTogetherRow");
  function createSuspenseListRow(previousRow) {
    var newRow = {
      pendingTasks: 1,
      boundaries: null,
      hoistables: createHoistableState(),
      inheritedHoistables: null,
      together: false,
      next: null
    };
    null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
    return newRow;
  }
  __name(createSuspenseListRow, "createSuspenseListRow");
  function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
    var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row;
    task.keyPath = keyPath;
    keyPath = rows.length;
    var previousSuspenseListRow = null;
    if (null !== task.replay) {
      var resumeSlots = task.replay.slots;
      if (null !== resumeSlots && "object" === typeof resumeSlots)
        for (var n2 = 0; n2 < keyPath; n2++) {
          var i2 = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n2 : keyPath - 1 - n2, node = rows[i2];
          task.row = previousSuspenseListRow = createSuspenseListRow(
            previousSuspenseListRow
          );
          task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
          var resumeSegmentID = resumeSlots[i2];
          "number" === typeof resumeSegmentID ? (resumeNode(request, task, resumeSegmentID, node, i2), delete resumeSlots[i2]) : renderNode(request, task, node, i2);
          0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
        }
      else
        for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)
          n2 = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i2 = rows[n2], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n2), renderNode(request, task, i2, n2), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
    } else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder)
      for (revealOrder = 0; revealOrder < keyPath; revealOrder++)
        resumeSlots = rows[revealOrder], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(
          prevTreeContext,
          keyPath,
          revealOrder
        ), renderNode(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
    else {
      revealOrder = task.blockedSegment;
      resumeSlots = revealOrder.children.length;
      n2 = revealOrder.chunks.length;
      for (i2 = keyPath - 1; 0 <= i2; i2--) {
        node = rows[i2];
        task.row = previousSuspenseListRow = createSuspenseListRow(
          previousSuspenseListRow
        );
        task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
        resumeSegmentID = createPendingSegment(
          request,
          n2,
          null,
          task.formatContext,
          0 === i2 ? revealOrder.lastPushedText : true,
          true
        );
        revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
        task.blockedSegment = resumeSegmentID;
        try {
          renderNode(request, task, node, i2), pushSegmentFinale(
            resumeSegmentID.chunks,
            request.renderState,
            resumeSegmentID.lastPushedText,
            resumeSegmentID.textEmbedded
          ), resumeSegmentID.status = 1, 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
        } catch (thrownValue) {
          throw resumeSegmentID.status = 12 === request.status ? 3 : 4, thrownValue;
        }
      }
      task.blockedSegment = revealOrder;
      revealOrder.lastPushedText = false;
    }
    null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
    task.treeContext = prevTreeContext;
    task.row = prevRow;
    task.keyPath = prevKeyPath;
  }
  __name(renderSuspenseListRows, "renderSuspenseListRows");
  function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
    var prevThenableState = task.thenableState;
    task.thenableState = null;
    currentlyRenderingComponent = {};
    currentlyRenderingTask = task;
    currentlyRenderingRequest = request;
    currentlyRenderingKeyPath = keyPath;
    actionStateCounter = localIdCounter = 0;
    actionStateMatchingIndex = -1;
    thenableIndexCounter = 0;
    thenableState = prevThenableState;
    for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )
      didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
    resetHooksState();
    return request;
  }
  __name(renderWithHooks, "renderWithHooks");
  function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
    var didEmitActionStateMarkers = false;
    if (0 !== actionStateCount && null !== request.formState) {
      var segment = task.blockedSegment;
      if (null !== segment) {
        didEmitActionStateMarkers = true;
        segment = segment.chunks;
        for (var i2 = 0; i2 < actionStateCount; i2++)
          i2 === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
      }
    }
    actionStateCount = task.keyPath;
    task.keyPath = keyPath;
    hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
    task.keyPath = actionStateCount;
  }
  __name(finishFunctionComponent, "finishFunctionComponent");
  function renderElement2(request, task, keyPath, type, props, ref3) {
    if ("function" === typeof type)
      if (type.prototype && type.prototype.isReactComponent) {
        var newProps = props;
        if ("ref" in props) {
          newProps = {};
          for (var propName in props)
            "ref" !== propName && (newProps[propName] = props[propName]);
        }
        var defaultProps = type.defaultProps;
        if (defaultProps) {
          newProps === props && (newProps = assign({}, newProps, props));
          for (var propName$43 in defaultProps)
            void 0 === newProps[propName$43] && (newProps[propName$43] = defaultProps[propName$43]);
        }
        props = newProps;
        newProps = emptyContextObject;
        defaultProps = type.contextType;
        "object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue2);
        newProps = new type(props, newProps);
        var initialState = void 0 !== newProps.state ? newProps.state : null;
        newProps.updater = classComponentUpdater;
        newProps.props = props;
        newProps.state = initialState;
        defaultProps = { queue: [], replace: false };
        newProps._reactInternals = defaultProps;
        ref3 = type.contextType;
        newProps.context = "object" === typeof ref3 && null !== ref3 ? ref3._currentValue2 : emptyContextObject;
        ref3 = type.getDerivedStateFromProps;
        "function" === typeof ref3 && (ref3 = ref3(props, initialState), initialState = null === ref3 || void 0 === ref3 ? initialState : assign({}, initialState, ref3), newProps.state = initialState);
        if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount))
          if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater.enqueueReplaceState(
            newProps,
            newProps.state,
            null
          ), null !== defaultProps.queue && 0 < defaultProps.queue.length)
            if (type = defaultProps.queue, ref3 = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref3 && 1 === type.length)
              newProps.state = type[0];
            else {
              defaultProps = ref3 ? type[0] : newProps.state;
              initialState = true;
              for (ref3 = ref3 ? 1 : 0; ref3 < type.length; ref3++)
                propName$43 = type[ref3], propName$43 = "function" === typeof propName$43 ? propName$43.call(newProps, defaultProps, props, void 0) : propName$43, null != propName$43 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$43)) : assign(defaultProps, propName$43));
              newProps.state = defaultProps;
            }
          else defaultProps.queue = null;
        type = newProps.render();
        if (12 === request.status) throw null;
        props = task.keyPath;
        task.keyPath = keyPath;
        renderNodeDestructive(request, task, type, -1);
        task.keyPath = props;
      } else {
        type = renderWithHooks(request, task, keyPath, type, props, void 0);
        if (12 === request.status) throw null;
        finishFunctionComponent(
          request,
          task,
          keyPath,
          type,
          0 !== localIdCounter,
          actionStateCounter,
          actionStateMatchingIndex
        );
      }
    else if ("string" === typeof type)
      if (newProps = task.blockedSegment, null === newProps)
        newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type, props), task.keyPath = keyPath, renderNode(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
      else {
        initialState = pushStartInstance(
          newProps.chunks,
          type,
          props,
          request.resumableState,
          request.renderState,
          task.blockedPreamble,
          task.hoistableState,
          task.formatContext,
          newProps.lastPushedText
        );
        newProps.lastPushedText = false;
        defaultProps = task.formatContext;
        ref3 = task.keyPath;
        task.keyPath = keyPath;
        if (3 === (task.formatContext = getChildFormatContext(defaultProps, type, props)).insertionMode) {
          keyPath = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          );
          newProps.preambleChildren.push(keyPath);
          task.blockedSegment = keyPath;
          try {
            keyPath.status = 6, renderNode(request, task, initialState, -1), pushSegmentFinale(
              keyPath.chunks,
              request.renderState,
              keyPath.lastPushedText,
              keyPath.textEmbedded
            ), keyPath.status = 1;
          } finally {
            task.blockedSegment = newProps;
          }
        } else renderNode(request, task, initialState, -1);
        task.formatContext = defaultProps;
        task.keyPath = ref3;
        a: {
          task = newProps.chunks;
          request = request.resumableState;
          switch (type) {
            case "title":
            case "style":
            case "script":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
              break a;
            case "body":
              if (1 >= defaultProps.insertionMode) {
                request.hasBody = true;
                break a;
              }
              break;
            case "html":
              if (0 === defaultProps.insertionMode) {
                request.hasHtml = true;
                break a;
              }
              break;
            case "head":
              if (1 >= defaultProps.insertionMode) break a;
          }
          task.push(endChunkForTag(type));
        }
        newProps.lastPushedText = false;
      }
    else {
      switch (type) {
        case REACT_LEGACY_HIDDEN_TYPE:
        case REACT_STRICT_MODE_TYPE:
        case REACT_PROFILER_TYPE:
        case REACT_FRAGMENT_TYPE:
          type = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, props.children, -1);
          task.keyPath = type;
          return;
        case REACT_ACTIVITY_TYPE:
          type = task.blockedSegment;
          null === type ? "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = type) : "hidden" !== props.mode && (request.renderState.generateStaticMarkup || type.chunks.push("<!--&-->"), type.lastPushedText = false, newProps = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = newProps, request.renderState.generateStaticMarkup || type.chunks.push("<!--/&-->"), type.lastPushedText = false);
          return;
        case REACT_SUSPENSE_LIST_TYPE:
          a: {
            type = props.children;
            props = props.revealOrder;
            if ("forwards" === props || "backwards" === props || "unstable_legacy-backwards" === props) {
              if (isArrayImpl(type)) {
                renderSuspenseListRows(request, task, keyPath, type, props);
                break a;
              }
              if (newProps = getIteratorFn(type)) {
                if (newProps = newProps.call(type)) {
                  defaultProps = newProps.next();
                  if (!defaultProps.done) {
                    do
                      defaultProps = newProps.next();
                    while (!defaultProps.done);
                    renderSuspenseListRows(request, task, keyPath, type, props);
                  }
                  break a;
                }
              }
            }
            "together" === props ? (props = task.keyPath, newProps = task.row, defaultProps = task.row = createSuspenseListRow(null), defaultProps.boundaries = [], defaultProps.together = true, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), 0 === --defaultProps.pendingTasks && finishSuspenseListRow(request, defaultProps), task.keyPath = props, task.row = newProps, null !== newProps && 0 < defaultProps.pendingTasks && (newProps.pendingTasks++, defaultProps.next = newProps)) : (props = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), task.keyPath = props);
          }
          return;
        case REACT_VIEW_TRANSITION_TYPE:
        case REACT_SCOPE_TYPE:
          throw Error(formatProdErrorMessage(343));
        case REACT_SUSPENSE_TYPE:
          a: if (null !== task.replay) {
            type = task.keyPath;
            newProps = task.formatContext;
            defaultProps = task.row;
            task.keyPath = keyPath;
            task.formatContext = getSuspenseContentFormatContext(
              request.resumableState,
              newProps
            );
            task.row = null;
            keyPath = props.children;
            try {
              renderNode(request, task, keyPath, -1);
            } finally {
              task.keyPath = type, task.formatContext = newProps, task.row = defaultProps;
            }
          } else {
            type = task.keyPath;
            ref3 = task.formatContext;
            var prevRow = task.row, parentBoundary = task.blockedBoundary;
            propName$43 = task.blockedPreamble;
            var parentHoistableState = task.hoistableState;
            propName = task.blockedSegment;
            var fallback = props.fallback;
            props = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = createSuspenseBoundary(
              request,
              task.row,
              fallbackAbortSet,
              null,
              null
            );
            null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
            var boundarySegment = createPendingSegment(
              request,
              propName.chunks.length,
              newBoundary,
              task.formatContext,
              false,
              false
            );
            propName.children.push(boundarySegment);
            propName.lastPushedText = false;
            var contentRootSegment = createPendingSegment(
              request,
              0,
              null,
              task.formatContext,
              false,
              false
            );
            contentRootSegment.parentFlushed = true;
            if (null !== request.trackedPostpones) {
              newProps = task.componentStack;
              defaultProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
              initialState = [defaultProps[1], defaultProps[2], [], null];
              request.trackedPostpones.workingMap.set(defaultProps, initialState);
              newBoundary.trackedFallbackNode = initialState;
              task.blockedSegment = boundarySegment;
              task.blockedPreamble = newBoundary.fallbackPreamble;
              task.keyPath = defaultProps;
              task.formatContext = getSuspenseFallbackFormatContext(
                request.resumableState,
                ref3
              );
              task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(newProps);
              boundarySegment.status = 6;
              try {
                renderNode(request, task, fallback, -1), pushSegmentFinale(
                  boundarySegment.chunks,
                  request.renderState,
                  boundarySegment.lastPushedText,
                  boundarySegment.textEmbedded
                ), boundarySegment.status = 1;
              } catch (thrownValue) {
                throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
              } finally {
                task.blockedSegment = propName, task.blockedPreamble = propName$43, task.keyPath = type, task.formatContext = ref3;
              }
              task = createRenderTask(
                request,
                null,
                props,
                -1,
                newBoundary,
                contentRootSegment,
                newBoundary.contentPreamble,
                newBoundary.contentState,
                task.abortSet,
                keyPath,
                getSuspenseContentFormatContext(
                  request.resumableState,
                  task.formatContext
                ),
                task.context,
                task.treeContext,
                null,
                newProps
              );
              pushComponentStack(task);
              request.pingedTasks.push(task);
            } else {
              task.blockedBoundary = newBoundary;
              task.blockedPreamble = newBoundary.contentPreamble;
              task.hoistableState = newBoundary.contentState;
              task.blockedSegment = contentRootSegment;
              task.keyPath = keyPath;
              task.formatContext = getSuspenseContentFormatContext(
                request.resumableState,
                ref3
              );
              task.row = null;
              contentRootSegment.status = 6;
              try {
                if (renderNode(request, task, props, -1), pushSegmentFinale(
                  contentRootSegment.chunks,
                  request.renderState,
                  contentRootSegment.lastPushedText,
                  contentRootSegment.textEmbedded
                ), contentRootSegment.status = 1, queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
                  if (newBoundary.status = 1, !isEligibleForOutlining(request, newBoundary)) {
                    null !== prevRow && 0 === --prevRow.pendingTasks && finishSuspenseListRow(request, prevRow);
                    0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                    break a;
                  }
                } else
                  null !== prevRow && prevRow.together && tryToResolveTogetherRow(request, prevRow);
              } catch (thrownValue$30) {
                newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$30), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(
                  request,
                  newProps,
                  defaultProps
                ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);
              } finally {
                task.blockedBoundary = parentBoundary, task.blockedPreamble = propName$43, task.hoistableState = parentHoistableState, task.blockedSegment = propName, task.keyPath = type, task.formatContext = ref3, task.row = prevRow;
              }
              task = createRenderTask(
                request,
                null,
                fallback,
                -1,
                parentBoundary,
                boundarySegment,
                newBoundary.fallbackPreamble,
                newBoundary.fallbackState,
                fallbackAbortSet,
                [keyPath[0], "Suspense Fallback", keyPath[2]],
                getSuspenseFallbackFormatContext(
                  request.resumableState,
                  task.formatContext
                ),
                task.context,
                task.treeContext,
                task.row,
                replaceSuspenseComponentStackWithSuspenseFallbackStack(
                  task.componentStack
                )
              );
              pushComponentStack(task);
              request.pingedTasks.push(task);
            }
          }
          return;
      }
      if ("object" === typeof type && null !== type)
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            if ("ref" in props)
              for (fallback in newProps = {}, props)
                "ref" !== fallback && (newProps[fallback] = props[fallback]);
            else newProps = props;
            type = renderWithHooks(
              request,
              task,
              keyPath,
              type.render,
              newProps,
              ref3
            );
            finishFunctionComponent(
              request,
              task,
              keyPath,
              type,
              0 !== localIdCounter,
              actionStateCounter,
              actionStateMatchingIndex
            );
            return;
          case REACT_MEMO_TYPE:
            renderElement2(request, task, keyPath, type.type, props, ref3);
            return;
          case REACT_CONTEXT_TYPE:
            defaultProps = props.children;
            newProps = task.keyPath;
            props = props.value;
            initialState = type._currentValue2;
            type._currentValue2 = props;
            ref3 = currentActiveSnapshot;
            currentActiveSnapshot = type = {
              parent: ref3,
              depth: null === ref3 ? 0 : ref3.depth + 1,
              context: type,
              parentValue: initialState,
              value: props
            };
            task.context = type;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, defaultProps, -1);
            request = currentActiveSnapshot;
            if (null === request) throw Error(formatProdErrorMessage(403));
            request.context._currentValue2 = request.parentValue;
            request = currentActiveSnapshot = request.parent;
            task.context = request;
            task.keyPath = newProps;
            return;
          case REACT_CONSUMER_TYPE:
            props = props.children;
            type = props(type._context._currentValue2);
            props = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, type, -1);
            task.keyPath = props;
            return;
          case REACT_LAZY_TYPE:
            newProps = type._init;
            type = newProps(type._payload);
            if (12 === request.status) throw null;
            renderElement2(request, task, keyPath, type, props, ref3);
            return;
        }
      throw Error(
        formatProdErrorMessage(130, null == type ? type : typeof type, "")
      );
    }
  }
  __name(renderElement2, "renderElement");
  function resumeNode(request, task, segmentId, node, childIndex) {
    var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
      request,
      0,
      null,
      task.formatContext,
      false,
      false
    );
    resumedSegment.id = segmentId;
    resumedSegment.parentFlushed = true;
    try {
      task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = 1, null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
    } finally {
      task.replay = prevReplay, task.blockedSegment = null;
    }
  }
  __name(resumeNode, "resumeNode");
  function renderNodeDestructive(request, task, node, childIndex) {
    null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);
  }
  __name(renderNodeDestructive, "renderNodeDestructive");
  function retryNode(request, task) {
    var node = task.node, childIndex = task.childIndex;
    if (null !== node) {
      if ("object" === typeof node) {
        switch (node.$$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = node.type, key = node.key, props = node.props;
            node = props.ref;
            var ref3 = void 0 !== node ? node : null, name = getComponentNameFromType(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
            key = [task.keyPath, name, keyOrIndex];
            if (null !== task.replay)
              a: {
                var replay = task.replay;
                childIndex = replay.nodes;
                for (node = 0; node < childIndex.length; node++) {
                  var node$jscomp$0 = childIndex[node];
                  if (keyOrIndex === node$jscomp$0[1]) {
                    if (4 === node$jscomp$0.length) {
                      if (null !== name && name !== node$jscomp$0[0])
                        throw Error(
                          formatProdErrorMessage(490, node$jscomp$0[0], name)
                        );
                      var childNodes = node$jscomp$0[2];
                      name = node$jscomp$0[3];
                      keyOrIndex = task.node;
                      task.replay = {
                        nodes: childNodes,
                        slots: name,
                        pendingTasks: 1
                      };
                      try {
                        renderElement2(request, task, key, type, props, ref3);
                        if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                          throw Error(formatProdErrorMessage(488));
                        task.replay.pendingTasks--;
                      } catch (x) {
                        if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                          throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(node, 1), x;
                        task.replay.pendingTasks--;
                        props = getThrownInfo(task.componentStack);
                        key = request;
                        request = task.blockedBoundary;
                        type = x;
                        props = logRecoverableError(key, type, props);
                        abortRemainingReplayNodes(
                          key,
                          request,
                          childNodes,
                          name,
                          type,
                          props
                        );
                      }
                      task.replay = replay;
                    } else {
                      if (type !== REACT_SUSPENSE_TYPE)
                        throw Error(
                          formatProdErrorMessage(
                            490,
                            "Suspense",
                            getComponentNameFromType(type) || "Unknown"
                          )
                        );
                      b: {
                        replay = void 0;
                        type = node$jscomp$0[5];
                        ref3 = node$jscomp$0[2];
                        name = node$jscomp$0[3];
                        keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
                        node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
                        var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                        props = createSuspenseBoundary(
                          request,
                          task.row,
                          fallbackAbortSet,
                          null,
                          null
                        );
                        props.parentFlushed = true;
                        props.rootSegmentID = type;
                        task.blockedBoundary = props;
                        task.hoistableState = props.contentState;
                        task.keyPath = key;
                        task.formatContext = getSuspenseContentFormatContext(
                          request.resumableState,
                          prevContext
                        );
                        task.row = null;
                        task.replay = {
                          nodes: ref3,
                          slots: name,
                          pendingTasks: 1
                        };
                        try {
                          renderNode(request, task, content, -1);
                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                            throw Error(formatProdErrorMessage(488));
                          task.replay.pendingTasks--;
                          if (0 === props.pendingTasks && 0 === props.status) {
                            props.status = 1;
                            request.completedBoundaries.push(props);
                            break b;
                          }
                        } catch (error5) {
                          props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                            request,
                            error5,
                            childNodes
                          ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                        } finally {
                          task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
                        }
                        childNodes = createReplayTask(
                          request,
                          null,
                          {
                            nodes: keyOrIndex,
                            slots: node$jscomp$0,
                            pendingTasks: 0
                          },
                          fallback,
                          -1,
                          parentBoundary,
                          props.fallbackState,
                          fallbackAbortSet,
                          [key[0], "Suspense Fallback", key[2]],
                          getSuspenseFallbackFormatContext(
                            request.resumableState,
                            task.formatContext
                          ),
                          task.context,
                          task.treeContext,
                          task.row,
                          replaceSuspenseComponentStackWithSuspenseFallbackStack(
                            task.componentStack
                          )
                        );
                        pushComponentStack(childNodes);
                        request.pingedTasks.push(childNodes);
                      }
                    }
                    childIndex.splice(node, 1);
                    break a;
                  }
                }
              }
            else renderElement2(request, task, key, type, props, ref3);
            return;
          case REACT_PORTAL_TYPE:
            throw Error(formatProdErrorMessage(257));
          case REACT_LAZY_TYPE:
            childNodes = node._init;
            node = childNodes(node._payload);
            if (12 === request.status) throw null;
            renderNodeDestructive(request, task, node, childIndex);
            return;
        }
        if (isArrayImpl(node)) {
          renderChildrenArray(request, task, node, childIndex);
          return;
        }
        if (childNodes = getIteratorFn(node)) {
          if (childNodes = childNodes.call(node)) {
            node = childNodes.next();
            if (!node.done) {
              props = [];
              do
                props.push(node.value), node = childNodes.next();
              while (!node.done);
              renderChildrenArray(request, task, props, childIndex);
            }
            return;
          }
        }
        if ("function" === typeof node.then)
          return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
        if (node.$$typeof === REACT_CONTEXT_TYPE)
          return renderNodeDestructive(
            request,
            task,
            node._currentValue2,
            childIndex
          );
        childIndex = Object.prototype.toString.call(node);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex
          )
        );
      }
      if ("string" === typeof node)
        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
          childIndex.chunks,
          node,
          request.renderState,
          childIndex.lastPushedText
        ));
      else if ("number" === typeof node || "bigint" === typeof node)
        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
          childIndex.chunks,
          "" + node,
          request.renderState,
          childIndex.lastPushedText
        ));
    }
  }
  __name(retryNode, "retryNode");
  function renderChildrenArray(request, task, children, childIndex) {
    var prevKeyPath = task.keyPath;
    if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
      for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
        var node = replayNodes[j];
        if (node[1] === childIndex) {
          childIndex = node[2];
          node = node[3];
          task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
          try {
            renderChildrenArray(request, task, children, -1);
            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
              throw Error(formatProdErrorMessage(488));
            task.replay.pendingTasks--;
          } catch (x) {
            if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
              throw x;
            task.replay.pendingTasks--;
            children = getThrownInfo(task.componentStack);
            var boundary = task.blockedBoundary, error5 = x;
            children = logRecoverableError(request, error5, children);
            abortRemainingReplayNodes(
              request,
              boundary,
              childIndex,
              node,
              error5,
              children
            );
          }
          task.replay = replay;
          replayNodes.splice(j, 1);
          break;
        }
      }
      task.keyPath = prevKeyPath;
      return;
    }
    replay = task.treeContext;
    replayNodes = children.length;
    if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
      for (childIndex = 0; childIndex < replayNodes; childIndex++)
        node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j[childIndex], "number" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
      return;
    }
    for (j = 0; j < replayNodes; j++)
      childIndex = children[j], task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
    task.treeContext = replay;
    task.keyPath = prevKeyPath;
  }
  __name(renderChildrenArray, "renderChildrenArray");
  function trackPostponedBoundary(request, trackedPostpones, boundary) {
    boundary.status = 5;
    boundary.rootSegmentID = request.nextSegmentId++;
    request = boundary.trackedContentKeyPath;
    if (null === request) throw Error(formatProdErrorMessage(486));
    var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
    if (void 0 === boundaryNode)
      return boundary = [
        request[1],
        request[2],
        children,
        null,
        fallbackReplayNode,
        boundary.rootSegmentID
      ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
    boundaryNode[4] = fallbackReplayNode;
    boundaryNode[5] = boundary.rootSegmentID;
    return boundaryNode;
  }
  __name(trackPostponedBoundary, "trackPostponedBoundary");
  function trackPostpone(request, trackedPostpones, task, segment) {
    segment.status = 5;
    var keyPath = task.keyPath, boundary = task.blockedBoundary;
    if (null === boundary)
      segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = 5);
    else {
      if (null !== boundary && 0 === boundary.status) {
        var boundaryNode = trackPostponedBoundary(
          request,
          trackedPostpones,
          boundary
        );
        if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
          -1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
          boundaryNode[3] = segment.id;
          return;
        }
      }
      -1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
      if (-1 === task.childIndex)
        null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
      else {
        if (null === keyPath)
          if (request = trackedPostpones.rootSlots, null === request)
            request = trackedPostpones.rootSlots = {};
          else {
            if ("number" === typeof request)
              throw Error(formatProdErrorMessage(491));
          }
        else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode)
          request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
        else if (request = boundaryNode[3], null === request)
          request = boundaryNode[3] = {};
        else if ("number" === typeof request)
          throw Error(formatProdErrorMessage(491));
        request[task.childIndex] = segment.id;
      }
    }
  }
  __name(trackPostpone, "trackPostpone");
  function untrackBoundary(request, boundary) {
    request = request.trackedPostpones;
    null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
  }
  __name(untrackBoundary, "untrackBoundary");
  function spawnNewSuspendedReplayTask(request, task, thenableState2) {
    return createReplayTask(
      request,
      thenableState2,
      task.replay,
      task.node,
      task.childIndex,
      task.blockedBoundary,
      task.hoistableState,
      task.abortSet,
      task.keyPath,
      task.formatContext,
      task.context,
      task.treeContext,
      task.row,
      task.componentStack
    );
  }
  __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
  function spawnNewSuspendedRenderTask(request, task, thenableState2) {
    var segment = task.blockedSegment, newSegment = createPendingSegment(
      request,
      segment.chunks.length,
      null,
      task.formatContext,
      segment.lastPushedText,
      true
    );
    segment.children.push(newSegment);
    segment.lastPushedText = false;
    return createRenderTask(
      request,
      thenableState2,
      task.node,
      task.childIndex,
      task.blockedBoundary,
      newSegment,
      task.blockedPreamble,
      task.hoistableState,
      task.abortSet,
      task.keyPath,
      task.formatContext,
      task.context,
      task.treeContext,
      task.row,
      task.componentStack
    );
  }
  __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
  function renderNode(request, task, node, childIndex) {
    var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
    if (null === segment) {
      segment = task.replay;
      try {
        return renderNodeDestructive(request, task, node, childIndex);
      } catch (thrownValue) {
        if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
          if ("function" === typeof node.then) {
            childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
            request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
            node.then(request, request);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            task.replay = segment;
            switchContext(previousContext);
            return;
          }
          if ("Maximum call stack size exceeded" === node.message) {
            node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
            node = spawnNewSuspendedReplayTask(request, task, node);
            request.pingedTasks.push(node);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            task.replay = segment;
            switchContext(previousContext);
            return;
          }
        }
      }
    } else {
      var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
      try {
        return renderNodeDestructive(request, task, node, childIndex);
      } catch (thrownValue$62) {
        if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$62 === SuspenseException ? getSuspendedThenable() : thrownValue$62, 12 !== request.status && "object" === typeof node && null !== node) {
          if ("function" === typeof node.then) {
            segment = node;
            node = thrownValue$62 === SuspenseException ? getThenableStateAfterSuspending() : null;
            request = spawnNewSuspendedRenderTask(request, task, node).ping;
            segment.then(request, request);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            switchContext(previousContext);
            return;
          }
          if ("Maximum call stack size exceeded" === node.message) {
            segment = thrownValue$62 === SuspenseException ? getThenableStateAfterSuspending() : null;
            segment = spawnNewSuspendedRenderTask(request, task, segment);
            request.pingedTasks.push(segment);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            switchContext(previousContext);
            return;
          }
        }
      }
    }
    task.formatContext = previousFormatContext;
    task.context = previousContext;
    task.keyPath = previousKeyPath;
    task.treeContext = previousTreeContext;
    switchContext(previousContext);
    throw node;
  }
  __name(renderNode, "renderNode");
  function abortTaskSoft(task) {
    var boundary = task.blockedBoundary, segment = task.blockedSegment;
    null !== segment && (segment.status = 3, finishedTask(this, boundary, task.row, segment));
  }
  __name(abortTaskSoft, "abortTaskSoft");
  function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error5, errorDigest$jscomp$0) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var node = nodes[i2];
      if (4 === node.length)
        abortRemainingReplayNodes(
          request$jscomp$0,
          boundary,
          node[2],
          node[3],
          error5,
          errorDigest$jscomp$0
        );
      else {
        node = node[5];
        var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(
          request,
          null,
          /* @__PURE__ */ new Set(),
          null,
          null
        );
        resumedBoundary.parentFlushed = true;
        resumedBoundary.rootSegmentID = node;
        resumedBoundary.status = 4;
        resumedBoundary.errorDigest = errorDigest;
        resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
      }
    }
    nodes.length = 0;
    if (null !== slots) {
      if (null === boundary) throw Error(formatProdErrorMessage(487));
      4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
      if ("object" === typeof slots) for (var index2 in slots) delete slots[index2];
    }
  }
  __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
  function abortTask(task, request, error5) {
    var boundary = task.blockedBoundary, segment = task.blockedSegment;
    if (null !== segment) {
      if (6 === segment.status) return;
      segment.status = 3;
    }
    var errorInfo = getThrownInfo(task.componentStack);
    if (null === boundary) {
      if (13 !== request.status && 14 !== request.status) {
        boundary = task.replay;
        if (null === boundary) {
          null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError(request, error5, errorInfo), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error5, errorInfo), fatalError(request, error5));
          return;
        }
        boundary.pendingTasks--;
        0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error5, errorInfo), abortRemainingReplayNodes(
          request,
          null,
          boundary.nodes,
          boundary.slots,
          error5,
          segment
        ));
        request.pendingRootTasks--;
        0 === request.pendingRootTasks && completeShell(request);
      }
    } else {
      var trackedPostpones$63 = request.trackedPostpones;
      if (4 !== boundary.status) {
        if (null !== trackedPostpones$63 && null !== segment)
          return logRecoverableError(request, error5, errorInfo), trackPostpone(request, trackedPostpones$63, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error5);
          }), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
        boundary.status = 4;
        segment = logRecoverableError(request, error5, errorInfo);
        boundary.status = 4;
        boundary.errorDigest = segment;
        untrackBoundary(request, boundary);
        boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
      }
      boundary.pendingTasks--;
      segment = boundary.row;
      null !== segment && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
      boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
        return abortTask(fallbackTask, request, error5);
      });
      boundary.fallbackAbortableTasks.clear();
    }
    task = task.row;
    null !== task && 0 === --task.pendingTasks && finishSuspenseListRow(request, task);
    request.allPendingTasks--;
    0 === request.allPendingTasks && completeAll(request);
  }
  __name(abortTask, "abortTask");
  function safelyEmitEarlyPreloads(request, shellComplete) {
    try {
      var renderState = request.renderState, onHeaders = renderState.onHeaders;
      if (onHeaders) {
        var headers = renderState.headers;
        if (headers) {
          renderState.headers = null;
          var linkHeader = headers.preconnects;
          headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
          headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
          if (!shellComplete) {
            var queueIter = renderState.styles.values(), queueStep = queueIter.next();
            b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                  crossOrigin: props$jscomp$0.crossOrigin,
                  integrity: props$jscomp$0.integrity,
                  nonce: props$jscomp$0.nonce,
                  type: props$jscomp$0.type,
                  fetchPriority: props$jscomp$0.fetchPriority,
                  referrerPolicy: props$jscomp$0.referrerPolicy,
                  media: props$jscomp$0.media
                });
                if (0 <= (headers.remainingCapacity -= header.length + 2))
                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                else break b;
              }
          }
          linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
        }
      }
    } catch (error5) {
      logRecoverableError(request, error5, {});
    }
  }
  __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
  function completeShell(request) {
    null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
    null === request.trackedPostpones && preparePreamble(request);
    request.onShellError = noop2;
    request = request.onShellReady;
    request();
  }
  __name(completeShell, "completeShell");
  function completeAll(request) {
    safelyEmitEarlyPreloads(
      request,
      null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status
    );
    preparePreamble(request);
    request = request.onAllReady;
    request();
  }
  __name(completeAll, "completeAll");
  function queueCompletedSegment(boundary, segment) {
    if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
      var childSegment = segment.children[0];
      childSegment.id = segment.id;
      childSegment.parentFlushed = true;
      1 !== childSegment.status && 3 !== childSegment.status && 4 !== childSegment.status || queueCompletedSegment(boundary, childSegment);
    } else boundary.completedSegments.push(segment);
  }
  __name(queueCompletedSegment, "queueCompletedSegment");
  function finishedTask(request, boundary, row, segment) {
    null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
    request.allPendingTasks--;
    if (null === boundary) {
      if (null !== segment && segment.parentFlushed) {
        if (null !== request.completedRootSegment)
          throw Error(formatProdErrorMessage(389));
        request.completedRootSegment = segment;
      }
      request.pendingRootTasks--;
      0 === request.pendingRootTasks && completeShell(request);
    } else if (boundary.pendingTasks--, 4 !== boundary.status)
      if (0 === boundary.pendingTasks)
        if (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && (1 === segment.status || 3 === segment.status) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status)
          row = boundary.row, null !== row && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request);
        else {
          if (5 === boundary.status && (boundary = boundary.row, null !== boundary)) {
            if (null !== request.trackedPostpones) {
              row = request.trackedPostpones;
              var postponedRow = boundary.next;
              if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment))
                for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
                  var postponedBoundary = segment[postponedRow];
                  trackPostponedBoundary(request, row, postponedBoundary);
                  finishedTask(request, postponedBoundary, null, null);
                }
            }
            0 === --boundary.pendingTasks && finishSuspenseListRow(request, boundary);
          }
        }
      else
        null === segment || !segment.parentFlushed || 1 !== segment.status && 3 !== segment.status || (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow(request, boundary);
    0 === request.allPendingTasks && completeAll(request);
  }
  __name(finishedTask, "finishedTask");
  function performWork(request$jscomp$2) {
    if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
      var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = HooksDispatcher;
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      var prevRequest = currentRequest;
      currentRequest = request$jscomp$2;
      var prevResumableState = currentResumableState;
      currentResumableState = request$jscomp$2.resumableState;
      try {
        var pingedTasks = request$jscomp$2.pingedTasks, i2;
        for (i2 = 0; i2 < pingedTasks.length; i2++) {
          var task = pingedTasks[i2], request = request$jscomp$2, segment = task.blockedSegment;
          if (null === segment) {
            var request$jscomp$0 = request;
            if (0 !== task.replay.pendingTasks) {
              switchContext(task.context);
              try {
                "number" === typeof task.replay.slots ? resumeNode(
                  request$jscomp$0,
                  task,
                  task.replay.slots,
                  task.node,
                  task.childIndex
                ) : retryNode(request$jscomp$0, task);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(formatProdErrorMessage(488));
                task.replay.pendingTasks--;
                task.abortSet.delete(task);
                finishedTask(
                  request$jscomp$0,
                  task.blockedBoundary,
                  task.row,
                  null
                );
              } catch (thrownValue) {
                resetHooksState();
                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                  var ping = task.ping;
                  x.then(ping, ping);
                  task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                } else {
                  task.replay.pendingTasks--;
                  task.abortSet.delete(task);
                  var errorInfo = getThrownInfo(task.componentStack);
                  request = void 0;
                  var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
                  request = logRecoverableError(
                    request$jscomp$1,
                    error$jscomp$0,
                    errorInfo
                  );
                  abortRemainingReplayNodes(
                    request$jscomp$1,
                    boundary,
                    replayNodes,
                    resumeSlots,
                    error$jscomp$0,
                    request
                  );
                  request$jscomp$0.pendingRootTasks--;
                  0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                  request$jscomp$0.allPendingTasks--;
                  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                }
              } finally {
              }
            }
          } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
            request$jscomp$1.status = 6;
            switchContext(task.context);
            var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
            try {
              retryNode(request, task), pushSegmentFinale(
                request$jscomp$1.chunks,
                request.renderState,
                request$jscomp$1.lastPushedText,
                request$jscomp$1.textEmbedded
              ), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedTask(
                request,
                task.blockedBoundary,
                task.row,
                request$jscomp$1
              );
            } catch (thrownValue) {
              resetHooksState();
              request$jscomp$1.children.length = childrenLength;
              request$jscomp$1.chunks.length = chunkLength;
              var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
              if (12 === request.status && null !== request.trackedPostpones) {
                var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(task.componentStack);
                task.abortSet.delete(task);
                logRecoverableError(request, x$jscomp$0, thrownInfo);
                trackPostpone(request, trackedPostpones, task, request$jscomp$1);
                finishedTask(
                  request,
                  task.blockedBoundary,
                  task.row,
                  request$jscomp$1
                );
              } else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                request$jscomp$1.status = 0;
                task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                var ping$jscomp$0 = task.ping;
                x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
              } else {
                var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
                task.abortSet.delete(task);
                request$jscomp$1.status = 4;
                var boundary$jscomp$0 = task.blockedBoundary, row = task.row;
                null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
                request.allPendingTasks--;
                request$jscomp$0 = logRecoverableError(
                  request,
                  x$jscomp$0,
                  errorInfo$jscomp$0
                );
                if (null === boundary$jscomp$0) fatalError(request, x$jscomp$0);
                else if (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status) {
                  boundary$jscomp$0.status = 4;
                  boundary$jscomp$0.errorDigest = request$jscomp$0;
                  untrackBoundary(request, boundary$jscomp$0);
                  var boundaryRow = boundary$jscomp$0.row;
                  null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow(request, boundaryRow);
                  boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                  0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request);
                }
                0 === request.allPendingTasks && completeAll(request);
              }
            } finally {
            }
          }
        }
        pingedTasks.splice(0, i2);
        null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
      } catch (error5) {
        logRecoverableError(request$jscomp$2, error5, {}), fatalError(request$jscomp$2, error5);
      } finally {
        currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
      }
    }
  }
  __name(performWork, "performWork");
  function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
    segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
    for (var pendingPreambles = false, i2 = 0; i2 < segment.children.length; i2++)
      pendingPreambles = preparePreambleFromSegment(
        request,
        segment.children[i2],
        collectedPreambleSegments
      ) || pendingPreambles;
    return pendingPreambles;
  }
  __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
  function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
    var boundary = segment.boundary;
    if (null === boundary)
      return preparePreambleFromSubtree(
        request,
        segment,
        collectedPreambleSegments
      );
    var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
    if (null === preamble || null === fallbackPreamble) return false;
    switch (boundary.status) {
      case 1:
        hoistPreambleState(request.renderState, preamble);
        request.byteSize += boundary.byteSize;
        segment = boundary.completedSegments[0];
        if (!segment) throw Error(formatProdErrorMessage(391));
        return preparePreambleFromSubtree(
          request,
          segment,
          collectedPreambleSegments
        );
      case 5:
        if (null !== request.trackedPostpones) return true;
      case 4:
        if (1 === segment.status)
          return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
      default:
        return true;
    }
  }
  __name(preparePreambleFromSegment, "preparePreambleFromSegment");
  function preparePreamble(request) {
    if (request.completedRootSegment && null === request.completedPreambleSegments) {
      var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(
        request,
        request.completedRootSegment,
        collectedPreambleSegments
      ), preamble = request.renderState.preamble;
      false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
    }
  }
  __name(preparePreamble, "preparePreamble");
  function flushSubtree(request, destination, segment, hoistableState) {
    segment.parentFlushed = true;
    switch (segment.status) {
      case 0:
        segment.id = request.nextSegmentId++;
      case 5:
        return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push('<template id="'), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push('"></template>');
      case 1:
        segment.status = 2;
        var r2 = true, chunks = segment.chunks, chunkIdx = 0;
        segment = segment.children;
        for (var childIdx = 0; childIdx < segment.length; childIdx++) {
          for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
            destination.push(chunks[chunkIdx]);
          r2 = flushSegment(request, destination, r2, hoistableState);
        }
        for (; chunkIdx < chunks.length - 1; chunkIdx++)
          destination.push(chunks[chunkIdx]);
        chunkIdx < chunks.length && (r2 = destination.push(chunks[chunkIdx]));
        return r2;
      case 3:
        return true;
      default:
        throw Error(formatProdErrorMessage(390));
    }
  }
  __name(flushSubtree, "flushSubtree");
  var flushedByteSize = 0;
  function flushSegment(request, destination, segment, hoistableState) {
    var boundary = segment.boundary;
    if (null === boundary)
      return flushSubtree(request, destination, segment, hoistableState);
    boundary.parentFlushed = true;
    if (4 === boundary.status) {
      var row = boundary.row;
      null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
      request.renderState.generateStaticMarkup || (boundary = boundary.errorDigest, destination.push("<!--$!-->"), destination.push("<template"), boundary && (destination.push(' data-dgst="'), boundary = escapeTextForBrowser(boundary), destination.push(boundary), destination.push('"')), destination.push("></template>"));
      flushSubtree(request, destination, segment, hoistableState);
      request = request.renderState.generateStaticMarkup ? true : destination.push("<!--/$-->");
      return request;
    }
    if (1 !== boundary.status)
      return 0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
        destination,
        request.renderState,
        boundary.rootSegmentID
      ), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState), destination.push("<!--/$-->");
    if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && flushedByteSize + boundary.byteSize > request.progressiveChunkSize)
      return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
        destination,
        request.renderState,
        boundary.rootSegmentID
      ), flushSubtree(request, destination, segment, hoistableState), destination.push("<!--/$-->");
    flushedByteSize += boundary.byteSize;
    hoistableState && hoistHoistables(hoistableState, boundary.contentState);
    segment = boundary.row;
    null !== segment && isEligibleForOutlining(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
    request.renderState.generateStaticMarkup || destination.push("<!--$-->");
    segment = boundary.completedSegments;
    if (1 !== segment.length) throw Error(formatProdErrorMessage(391));
    flushSegment(request, destination, segment[0], hoistableState);
    request = request.renderState.generateStaticMarkup ? true : destination.push("<!--/$-->");
    return request;
  }
  __name(flushSegment, "flushSegment");
  function flushSegmentContainer(request, destination, segment, hoistableState) {
    writeStartSegment(
      destination,
      request.renderState,
      segment.parentFormatContext,
      segment.id
    );
    flushSegment(request, destination, segment, hoistableState);
    return writeEndSegment(destination, segment.parentFormatContext);
  }
  __name(flushSegmentContainer, "flushSegmentContainer");
  function flushCompletedBoundary(request, destination, boundary) {
    flushedByteSize = boundary.byteSize;
    for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++)
      flushPartiallyCompletedSegment(
        request,
        destination,
        boundary,
        completedSegments[i2]
      );
    completedSegments.length = 0;
    completedSegments = boundary.row;
    null !== completedSegments && isEligibleForOutlining(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow(request, completedSegments);
    writeHoistablesForBoundary(
      destination,
      boundary.contentState,
      request.renderState
    );
    completedSegments = request.resumableState;
    request = request.renderState;
    i2 = boundary.rootSegmentID;
    boundary = boundary.contentState;
    var requiresStyleInsertion = request.stylesToHoist;
    request.stylesToHoist = false;
    destination.push(request.startInlineScript);
    destination.push(">");
    requiresStyleInsertion ? (0 === (completedSegments.instructions & 4) && (completedSegments.instructions |= 4, destination.push(
      '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};'
    )), 0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, destination.push(
      '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};'
    )), 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, destination.push(
      '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=\n"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("'
    )) : destination.push('$RR("')) : (0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, destination.push(
      '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};'
    )), destination.push('$RC("'));
    completedSegments = i2.toString(16);
    destination.push(request.boundaryPrefix);
    destination.push(completedSegments);
    destination.push('","');
    destination.push(request.segmentPrefix);
    destination.push(completedSegments);
    requiresStyleInsertion ? (destination.push('",'), writeStyleResourceDependenciesInJS(destination, boundary)) : destination.push('"');
    boundary = destination.push(")<\/script>");
    return writeBootstrap(destination, request) && boundary;
  }
  __name(flushCompletedBoundary, "flushCompletedBoundary");
  function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
    if (2 === segment.status) return true;
    var hoistableState = boundary.contentState, segmentID = segment.id;
    if (-1 === segmentID) {
      if (-1 === (segment.id = boundary.rootSegmentID))
        throw Error(formatProdErrorMessage(392));
      return flushSegmentContainer(request, destination, segment, hoistableState);
    }
    if (segmentID === boundary.rootSegmentID)
      return flushSegmentContainer(request, destination, segment, hoistableState);
    flushSegmentContainer(request, destination, segment, hoistableState);
    boundary = request.resumableState;
    request = request.renderState;
    destination.push(request.startInlineScript);
    destination.push(">");
    0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, destination.push(
      '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
    )) : destination.push('$RS("');
    destination.push(request.segmentPrefix);
    segmentID = segmentID.toString(16);
    destination.push(segmentID);
    destination.push('","');
    destination.push(request.placeholderPrefix);
    destination.push(segmentID);
    destination = destination.push('")<\/script>');
    return destination;
  }
  __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
  var flushingPartialBoundaries = false;
  function flushCompletedQueues(request, destination) {
    try {
      if (!(0 < request.pendingRootTasks)) {
        var i2, completedRootSegment = request.completedRootSegment;
        if (null !== completedRootSegment) {
          if (5 === completedRootSegment.status) return;
          var completedPreambleSegments = request.completedPreambleSegments;
          if (null === completedPreambleSegments) return;
          flushedByteSize = request.byteSize;
          var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
          if (htmlChunks) {
            for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
              destination.push(htmlChunks[i$jscomp$0]);
            if (headChunks)
              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                destination.push(headChunks[i$jscomp$0]);
            else {
              var chunk = startChunkForTag("head");
              destination.push(chunk);
              destination.push(">");
            }
          } else if (headChunks)
            for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
              destination.push(headChunks[i$jscomp$0]);
          var charsetChunks = renderState.charsetChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
            destination.push(charsetChunks[i$jscomp$0]);
          charsetChunks.length = 0;
          renderState.preconnects.forEach(flushResource, destination);
          renderState.preconnects.clear();
          var viewportChunks = renderState.viewportChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
            destination.push(viewportChunks[i$jscomp$0]);
          viewportChunks.length = 0;
          renderState.fontPreloads.forEach(flushResource, destination);
          renderState.fontPreloads.clear();
          renderState.highImagePreloads.forEach(flushResource, destination);
          renderState.highImagePreloads.clear();
          currentlyFlushingRenderState = renderState;
          renderState.styles.forEach(flushStylesInPreamble, destination);
          currentlyFlushingRenderState = null;
          var importMapChunks = renderState.importMapChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
            destination.push(importMapChunks[i$jscomp$0]);
          importMapChunks.length = 0;
          renderState.bootstrapScripts.forEach(flushResource, destination);
          renderState.scripts.forEach(flushResource, destination);
          renderState.scripts.clear();
          renderState.bulkPreloads.forEach(flushResource, destination);
          renderState.bulkPreloads.clear();
          resumableState.instructions |= 32;
          var hoistableChunks = renderState.hoistableChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
            destination.push(hoistableChunks[i$jscomp$0]);
          for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
            var segments = completedPreambleSegments[resumableState];
            for (renderState = 0; renderState < segments.length; renderState++)
              flushSegment(request, destination, segments[renderState], null);
          }
          var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
          if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
            var chunk$jscomp$0 = endChunkForTag("head");
            destination.push(chunk$jscomp$0);
          }
          var bodyChunks = preamble$jscomp$0.bodyChunks;
          if (bodyChunks)
            for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
              destination.push(bodyChunks[completedPreambleSegments]);
          flushSegment(request, destination, completedRootSegment, null);
          request.completedRootSegment = null;
          var renderState$jscomp$0 = request.renderState;
          if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
            var resumableState$jscomp$0 = request.resumableState;
            if (0 === (resumableState$jscomp$0.instructions & 64)) {
              resumableState$jscomp$0.instructions |= 64;
              destination.push(renderState$jscomp$0.startInlineScript);
              if (0 === (resumableState$jscomp$0.instructions & 32)) {
                resumableState$jscomp$0.instructions |= 32;
                var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
                destination.push(' id="');
                var chunk$jscomp$1 = escapeTextForBrowser(shellId);
                destination.push(chunk$jscomp$1);
                destination.push('"');
              }
              destination.push(">");
              destination.push(
                "requestAnimationFrame(function(){$RT=performance.now()});"
              );
              destination.push("<\/script>");
            }
          }
          writeBootstrap(destination, renderState$jscomp$0);
        }
        var renderState$jscomp$1 = request.renderState;
        completedRootSegment = 0;
        var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
        for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
          destination.push(viewportChunks$jscomp$0[completedRootSegment]);
        viewportChunks$jscomp$0.length = 0;
        renderState$jscomp$1.preconnects.forEach(flushResource, destination);
        renderState$jscomp$1.preconnects.clear();
        renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
        renderState$jscomp$1.fontPreloads.clear();
        renderState$jscomp$1.highImagePreloads.forEach(
          flushResource,
          destination
        );
        renderState$jscomp$1.highImagePreloads.clear();
        renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
        renderState$jscomp$1.scripts.forEach(flushResource, destination);
        renderState$jscomp$1.scripts.clear();
        renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
        renderState$jscomp$1.bulkPreloads.clear();
        var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
        for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
          destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
        hoistableChunks$jscomp$0.length = 0;
        var clientRenderedBoundaries = request.clientRenderedBoundaries;
        for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
          var boundary = clientRenderedBoundaries[i2];
          renderState$jscomp$1 = destination;
          var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
          renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);
          renderState$jscomp$1.push(">");
          0 === (resumableState$jscomp$1.instructions & 4) ? (resumableState$jscomp$1.instructions |= 4, renderState$jscomp$1.push(
            '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
          )) : renderState$jscomp$1.push('$RX("');
          renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);
          var chunk$jscomp$2 = id.toString(16);
          renderState$jscomp$1.push(chunk$jscomp$2);
          renderState$jscomp$1.push('"');
          if (errorDigest) {
            renderState$jscomp$1.push(",");
            var chunk$jscomp$3 = escapeJSStringsForInstructionScripts(
              errorDigest || ""
            );
            renderState$jscomp$1.push(chunk$jscomp$3);
          }
          var JSCompiler_inline_result = renderState$jscomp$1.push(")<\/script>");
          if (!JSCompiler_inline_result) {
            request.destination = null;
            i2++;
            clientRenderedBoundaries.splice(0, i2);
            return;
          }
        }
        clientRenderedBoundaries.splice(0, i2);
        var completedBoundaries = request.completedBoundaries;
        for (i2 = 0; i2 < completedBoundaries.length; i2++)
          if (!flushCompletedBoundary(request, destination, completedBoundaries[i2])) {
            request.destination = null;
            i2++;
            completedBoundaries.splice(0, i2);
            return;
          }
        completedBoundaries.splice(0, i2);
        flushingPartialBoundaries = true;
        var partialBoundaries = request.partialBoundaries;
        for (i2 = 0; i2 < partialBoundaries.length; i2++) {
          var boundary$69 = partialBoundaries[i2];
          a: {
            clientRenderedBoundaries = request;
            boundary = destination;
            flushedByteSize = boundary$69.byteSize;
            var completedSegments = boundary$69.completedSegments;
            for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
              if (!flushPartiallyCompletedSegment(
                clientRenderedBoundaries,
                boundary,
                boundary$69,
                completedSegments[JSCompiler_inline_result]
              )) {
                JSCompiler_inline_result++;
                completedSegments.splice(0, JSCompiler_inline_result);
                var JSCompiler_inline_result$jscomp$0 = false;
                break a;
              }
            completedSegments.splice(0, JSCompiler_inline_result);
            var row = boundary$69.row;
            null !== row && row.together && 1 === boundary$69.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow(
              clientRenderedBoundaries,
              row,
              row.hoistables
            ) : row.pendingTasks--);
            JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
              boundary,
              boundary$69.contentState,
              clientRenderedBoundaries.renderState
            );
          }
          if (!JSCompiler_inline_result$jscomp$0) {
            request.destination = null;
            i2++;
            partialBoundaries.splice(0, i2);
            return;
          }
        }
        partialBoundaries.splice(0, i2);
        flushingPartialBoundaries = false;
        var largeBoundaries = request.completedBoundaries;
        for (i2 = 0; i2 < largeBoundaries.length; i2++)
          if (!flushCompletedBoundary(request, destination, largeBoundaries[i2])) {
            request.destination = null;
            i2++;
            largeBoundaries.splice(0, i2);
            return;
          }
        largeBoundaries.splice(0, i2);
      }
    } finally {
      flushingPartialBoundaries = false, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length && (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && (partialBoundaries = endChunkForTag("body"), destination.push(partialBoundaries)), i2.hasHtml && (i2 = endChunkForTag("html"), destination.push(i2)), request.status = 14, destination.push(null), request.destination = null);
    }
  }
  __name(flushCompletedQueues, "flushCompletedQueues");
  function enqueueFlush(request) {
    if (false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination) {
      request.flushScheduled = true;
      var destination = request.destination;
      destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
    }
  }
  __name(enqueueFlush, "enqueueFlush");
  function startFlowing(request, destination) {
    if (13 === request.status)
      request.status = 14, destination.destroy(request.fatalError);
    else if (14 !== request.status && null === request.destination) {
      request.destination = destination;
      try {
        flushCompletedQueues(request, destination);
      } catch (error5) {
        logRecoverableError(request, error5, {}), fatalError(request, error5);
      }
    }
  }
  __name(startFlowing, "startFlowing");
  function abort3(request, reason) {
    if (11 === request.status || 10 === request.status) request.status = 12;
    try {
      var abortableTasks = request.abortableTasks;
      if (0 < abortableTasks.size) {
        var error5 = void 0 === reason ? Error(formatProdErrorMessage(432)) : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error(formatProdErrorMessage(530)) : reason;
        request.fatalError = error5;
        abortableTasks.forEach(function(task) {
          return abortTask(task, request, error5);
        });
        abortableTasks.clear();
      }
      null !== request.destination && flushCompletedQueues(request, request.destination);
    } catch (error$71) {
      logRecoverableError(request, error$71, {}), fatalError(request, error$71);
    }
  }
  __name(abort3, "abort");
  function addToReplayParent(node, parentKeyPath, trackedPostpones) {
    if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
    else {
      var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
      void 0 === parentNode && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
      parentNode[2].push(node);
    }
  }
  __name(addToReplayParent, "addToReplayParent");
  function onError() {
  }
  __name(onError, "onError");
  function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
    var didFatal = false, fatalError2 = null, result = "", readyToStream = false;
    options = createResumableState(options ? options.identifierPrefix : void 0);
    children = createRequest2(
      children,
      options,
      createRenderState(options, generateStaticMarkup),
      createFormatContext(0, null, 0, null),
      Infinity,
      onError,
      void 0,
      function() {
        readyToStream = true;
      },
      void 0,
      void 0,
      void 0
    );
    children.flushScheduled = null !== children.destination;
    performWork(children);
    10 === children.status && (children.status = 11);
    null === children.trackedPostpones && safelyEmitEarlyPreloads(children, 0 === children.pendingRootTasks);
    abort3(children, abortReason);
    startFlowing(children, {
      push: /* @__PURE__ */ __name(function(chunk) {
        null !== chunk && (result += chunk);
        return true;
      }, "push"),
      destroy: /* @__PURE__ */ __name(function(error5) {
        didFatal = true;
        fatalError2 = error5;
      }, "destroy")
    });
    if (didFatal && fatalError2 !== abortReason) throw fatalError2;
    if (!readyToStream) throw Error(formatProdErrorMessage(426));
    return result;
  }
  __name(renderToStringImpl, "renderToStringImpl");
  reactDomServerLegacy_browser_production.renderToStaticMarkup = function(children, options) {
    return renderToStringImpl(
      children,
      options,
      true,
      'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
    );
  };
  reactDomServerLegacy_browser_production.renderToString = function(children, options) {
    return renderToStringImpl(
      children,
      options,
      false,
      'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server'
    );
  };
  reactDomServerLegacy_browser_production.version = "19.2.3";
  return reactDomServerLegacy_browser_production;
}
function requireReactDomServer_browser_production() {
  if (hasRequiredReactDomServer_browser_production) return reactDomServer_browser_production;
  hasRequiredReactDomServer_browser_production = 1;
  var React2 = requireReact(), ReactDOM2 = requireReactDom();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i2 = 2; i2 < arguments.length; i2++)
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  __name(formatProdErrorMessage, "formatProdErrorMessage");
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  __name(getIteratorFn, "getIteratorFn");
  var isArrayImpl = Array.isArray;
  function murmurhash3_32_gc(key, seed) {
    var remainder = key.length & 3;
    var bytes = key.length - remainder;
    var h1 = seed;
    for (seed = 0; seed < bytes; ) {
      var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
      ++seed;
      k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      h1 ^= k1;
      h1 = h1 << 13 | h1 >>> 19;
      h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
    }
    k1 = 0;
    switch (remainder) {
      case 3:
        k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
      case 2:
        k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
      case 1:
        k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
    }
    h1 ^= key.length;
    h1 ^= h1 >>> 16;
    h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
    h1 ^= h1 >>> 13;
    h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
    return (h1 ^ h1 >>> 16) >>> 0;
  }
  __name(murmurhash3_32_gc, "murmurhash3_32_gc");
  var channel3 = new MessageChannel(), taskQueue = [];
  channel3.port1.onmessage = function() {
    var task = taskQueue.shift();
    task && task();
  };
  function scheduleWork(callback) {
    taskQueue.push(callback);
    channel3.port2.postMessage(null);
  }
  __name(scheduleWork, "scheduleWork");
  function handleErrorInNextTick(error5) {
    setTimeout(function() {
      throw error5;
    });
  }
  __name(handleErrorInNextTick, "handleErrorInNextTick");
  var LocalPromise = Promise, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : function(callback) {
    LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  }, currentView = null, writtenBytes = 0;
  function writeChunk(destination, chunk) {
    if (0 !== chunk.byteLength)
      if (2048 < chunk.byteLength)
        0 < writtenBytes && (destination.enqueue(
          new Uint8Array(currentView.buffer, 0, writtenBytes)
        ), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk);
      else {
        var allowableBytes = currentView.length - writtenBytes;
        allowableBytes < chunk.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(chunk.subarray(0, allowableBytes), writtenBytes), destination.enqueue(currentView), chunk = chunk.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);
        currentView.set(chunk, writtenBytes);
        writtenBytes += chunk.byteLength;
      }
  }
  __name(writeChunk, "writeChunk");
  function writeChunkAndReturn(destination, chunk) {
    writeChunk(destination, chunk);
    return true;
  }
  __name(writeChunkAndReturn, "writeChunkAndReturn");
  function completeWriting(destination) {
    currentView && 0 < writtenBytes && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = null, writtenBytes = 0);
  }
  __name(completeWriting, "completeWriting");
  var textEncoder = new TextEncoder();
  function stringToChunk(content) {
    return textEncoder.encode(content);
  }
  __name(stringToChunk, "stringToChunk");
  function stringToPrecomputedChunk(content) {
    return textEncoder.encode(content);
  }
  __name(stringToPrecomputedChunk, "stringToPrecomputedChunk");
  function byteLengthOfChunk(chunk) {
    return chunk.byteLength;
  }
  __name(byteLengthOfChunk, "byteLengthOfChunk");
  function closeWithError(destination, error5) {
    "function" === typeof destination.error ? destination.error(error5) : destination.close();
  }
  __name(closeWithError, "closeWithError");
  var assign = Object.assign, hasOwnProperty = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
      return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  __name(isAttributeNameSafe, "isAttributeNameSafe");
  var unitlessNumbers = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  ), aliases = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), matchHtmlRegExp = /["'&<>]/;
  function escapeTextForBrowser(text2) {
    if ("boolean" === typeof text2 || "number" === typeof text2 || "bigint" === typeof text2)
      return "" + text2;
    text2 = "" + text2;
    var match = matchHtmlRegExp.exec(text2);
    if (match) {
      var html = "", index2, lastIndex = 0;
      for (index2 = match.index; index2 < text2.length; index2++) {
        switch (text2.charCodeAt(index2)) {
          case 34:
            match = "&quot;";
            break;
          case 38:
            match = "&amp;";
            break;
          case 39:
            match = "&#x27;";
            break;
          case 60:
            match = "&lt;";
            break;
          case 62:
            match = "&gt;";
            break;
          default:
            continue;
        }
        lastIndex !== index2 && (html += text2.slice(lastIndex, index2));
        lastIndex = index2 + 1;
        html += match;
      }
      text2 = lastIndex !== index2 ? html + text2.slice(lastIndex, index2) : html;
    }
    return text2;
  }
  __name(escapeTextForBrowser, "escapeTextForBrowser");
  var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/, isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  __name(sanitizeURL, "sanitizeURL");
  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  }, previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: previousDispatcher.f,
    r: previousDispatcher.r,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  var PRELOAD_NO_CREDS = [], currentlyFlushingRenderState = null;
  stringToPrecomputedChunk('"></template>');
  var startInlineScript = stringToPrecomputedChunk("<script"), endInlineScript = stringToPrecomputedChunk("<\/script>"), startScriptSrc = stringToPrecomputedChunk('<script src="'), startModuleSrc = stringToPrecomputedChunk('<script type="module" src="'), scriptNonce = stringToPrecomputedChunk(' nonce="'), scriptIntegirty = stringToPrecomputedChunk(' integrity="'), scriptCrossOrigin = stringToPrecomputedChunk(' crossorigin="'), endAsyncScript = stringToPrecomputedChunk(' async=""><\/script>'), startInlineStyle = stringToPrecomputedChunk("<style"), scriptRegex = /(<\/|<)(s)(cript)/gi;
  function scriptReplacer(match, prefix2, s2, suffix2) {
    return "" + prefix2 + ("s" === s2 ? "\\u0073" : "\\u0053") + suffix2;
  }
  __name(scriptReplacer, "scriptReplacer");
  var importMapScriptStart = stringToPrecomputedChunk(
    '<script type="importmap">'
  ), importMapScriptEnd = stringToPrecomputedChunk("<\/script>");
  function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
    externalRuntimeConfig = "string" === typeof nonce ? nonce : nonce && nonce.script;
    var inlineScriptWithNonce = void 0 === externalRuntimeConfig ? startInlineScript : stringToPrecomputedChunk(
      '<script nonce="' + escapeTextForBrowser(externalRuntimeConfig) + '"'
    ), nonceStyle = "string" === typeof nonce ? void 0 : nonce && nonce.style, inlineStyleWithNonce = void 0 === nonceStyle ? startInlineStyle : stringToPrecomputedChunk(
      '<style nonce="' + escapeTextForBrowser(nonceStyle) + '"'
    ), idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
    void 0 !== bootstrapScriptContent && (bootstrapChunks.push(inlineScriptWithNonce), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
      endOfStartTag,
      stringToChunk(
        ("" + bootstrapScriptContent).replace(scriptRegex, scriptReplacer)
      ),
      endInlineScript
    ));
    bootstrapScriptContent = [];
    void 0 !== importMap && (bootstrapScriptContent.push(importMapScriptStart), bootstrapScriptContent.push(
      stringToChunk(
        ("" + JSON.stringify(importMap)).replace(scriptRegex, scriptReplacer)
      )
    ), bootstrapScriptContent.push(importMapScriptEnd));
    importMap = onHeaders ? {
      preconnects: "",
      fontPreloads: "",
      highImagePreloads: "",
      remainingCapacity: 2 + ("number" === typeof maxHeadersLength ? maxHeadersLength : 2e3)
    } : null;
    onHeaders = {
      placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
      segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
      boundaryPrefix: stringToPrecomputedChunk(idPrefix + "B:"),
      startInlineScript: inlineScriptWithNonce,
      startInlineStyle: inlineStyleWithNonce,
      preamble: createPreambleState(),
      externalRuntimeScript: null,
      bootstrapChunks,
      importMapChunks: bootstrapScriptContent,
      onHeaders,
      headers: importMap,
      resets: {
        font: {},
        dns: {},
        connect: { default: {}, anonymous: {}, credentials: {} },
        image: {},
        style: {}
      },
      charsetChunks: [],
      viewportChunks: [],
      hoistableChunks: [],
      preconnects: /* @__PURE__ */ new Set(),
      fontPreloads: /* @__PURE__ */ new Set(),
      highImagePreloads: /* @__PURE__ */ new Set(),
      styles: /* @__PURE__ */ new Map(),
      bootstrapScripts: /* @__PURE__ */ new Set(),
      scripts: /* @__PURE__ */ new Set(),
      bulkPreloads: /* @__PURE__ */ new Set(),
      preloads: {
        images: /* @__PURE__ */ new Map(),
        stylesheets: /* @__PURE__ */ new Map(),
        scripts: /* @__PURE__ */ new Map(),
        moduleScripts: /* @__PURE__ */ new Map()
      },
      nonce: { script: externalRuntimeConfig, style: nonceStyle },
      hoistableState: null,
      stylesToHoist: false
    };
    if (void 0 !== bootstrapScripts)
      for (importMap = 0; importMap < bootstrapScripts.length; importMap++)
        idPrefix = bootstrapScripts[importMap], nonceStyle = inlineScriptWithNonce = void 0, inlineStyleWithNonce = {
          rel: "preload",
          as: "script",
          fetchPriority: "low",
          nonce
        }, "string" === typeof idPrefix ? inlineStyleWithNonce.href = maxHeadersLength = idPrefix : (inlineStyleWithNonce.href = maxHeadersLength = idPrefix.src, inlineStyleWithNonce.integrity = nonceStyle = "string" === typeof idPrefix.integrity ? idPrefix.integrity : void 0, inlineStyleWithNonce.crossOrigin = inlineScriptWithNonce = "string" === typeof idPrefix || null == idPrefix.crossOrigin ? void 0 : "use-credentials" === idPrefix.crossOrigin ? "use-credentials" : ""), idPrefix = resumableState, bootstrapScriptContent = maxHeadersLength, idPrefix.scriptResources[bootstrapScriptContent] = null, idPrefix.moduleScriptResources[bootstrapScriptContent] = null, idPrefix = [], pushLinkImpl(idPrefix, inlineStyleWithNonce), onHeaders.bootstrapScripts.add(idPrefix), bootstrapChunks.push(
          startScriptSrc,
          stringToChunk(escapeTextForBrowser(maxHeadersLength)),
          attributeEnd
        ), externalRuntimeConfig && bootstrapChunks.push(
          scriptNonce,
          stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),
          attributeEnd
        ), "string" === typeof nonceStyle && bootstrapChunks.push(
          scriptIntegirty,
          stringToChunk(escapeTextForBrowser(nonceStyle)),
          attributeEnd
        ), "string" === typeof inlineScriptWithNonce && bootstrapChunks.push(
          scriptCrossOrigin,
          stringToChunk(escapeTextForBrowser(inlineScriptWithNonce)),
          attributeEnd
        ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
    if (void 0 !== bootstrapModules)
      for (nonce = 0; nonce < bootstrapModules.length; nonce++)
        nonceStyle = bootstrapModules[nonce], maxHeadersLength = importMap = void 0, inlineScriptWithNonce = {
          rel: "modulepreload",
          fetchPriority: "low",
          nonce: externalRuntimeConfig
        }, "string" === typeof nonceStyle ? inlineScriptWithNonce.href = bootstrapScripts = nonceStyle : (inlineScriptWithNonce.href = bootstrapScripts = nonceStyle.src, inlineScriptWithNonce.integrity = maxHeadersLength = "string" === typeof nonceStyle.integrity ? nonceStyle.integrity : void 0, inlineScriptWithNonce.crossOrigin = importMap = "string" === typeof nonceStyle || null == nonceStyle.crossOrigin ? void 0 : "use-credentials" === nonceStyle.crossOrigin ? "use-credentials" : ""), nonceStyle = resumableState, inlineStyleWithNonce = bootstrapScripts, nonceStyle.scriptResources[inlineStyleWithNonce] = null, nonceStyle.moduleScriptResources[inlineStyleWithNonce] = null, nonceStyle = [], pushLinkImpl(nonceStyle, inlineScriptWithNonce), onHeaders.bootstrapScripts.add(nonceStyle), bootstrapChunks.push(
          startModuleSrc,
          stringToChunk(escapeTextForBrowser(bootstrapScripts)),
          attributeEnd
        ), externalRuntimeConfig && bootstrapChunks.push(
          scriptNonce,
          stringToChunk(escapeTextForBrowser(externalRuntimeConfig)),
          attributeEnd
        ), "string" === typeof maxHeadersLength && bootstrapChunks.push(
          scriptIntegirty,
          stringToChunk(escapeTextForBrowser(maxHeadersLength)),
          attributeEnd
        ), "string" === typeof importMap && bootstrapChunks.push(
          scriptCrossOrigin,
          stringToChunk(escapeTextForBrowser(importMap)),
          attributeEnd
        ), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endAsyncScript);
    return onHeaders;
  }
  __name(createRenderState, "createRenderState");
  function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
    return {
      idPrefix: void 0 === identifierPrefix ? "" : identifierPrefix,
      nextFormID: 0,
      streamingFormat: 0,
      bootstrapScriptContent,
      bootstrapScripts,
      bootstrapModules,
      instructions: 0,
      hasBody: false,
      hasHtml: false,
      unknownResources: {},
      dnsResources: {},
      connectResources: { default: {}, anonymous: {}, credentials: {} },
      imageResources: {},
      styleResources: {},
      scriptResources: {},
      moduleUnknownResources: {},
      moduleScriptResources: {}
    };
  }
  __name(createResumableState, "createResumableState");
  function createPreambleState() {
    return { htmlChunks: null, headChunks: null, bodyChunks: null };
  }
  __name(createPreambleState, "createPreambleState");
  function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
    return {
      insertionMode,
      selectedValue,
      tagScope,
      viewTransition
    };
  }
  __name(createFormatContext, "createFormatContext");
  function createRootFormatContext(namespaceURI) {
    return createFormatContext(
      "http://www.w3.org/2000/svg" === namespaceURI ? 4 : "http://www.w3.org/1998/Math/MathML" === namespaceURI ? 5 : 0,
      null,
      0,
      null
    );
  }
  __name(createRootFormatContext, "createRootFormatContext");
  function getChildFormatContext(parentContext, type, props) {
    var subtreeScope = parentContext.tagScope & -25;
    switch (type) {
      case "noscript":
        return createFormatContext(2, null, subtreeScope | 1, null);
      case "select":
        return createFormatContext(
          2,
          null != props.value ? props.value : props.defaultValue,
          subtreeScope,
          null
        );
      case "svg":
        return createFormatContext(4, null, subtreeScope, null);
      case "picture":
        return createFormatContext(2, null, subtreeScope | 2, null);
      case "math":
        return createFormatContext(5, null, subtreeScope, null);
      case "foreignObject":
        return createFormatContext(2, null, subtreeScope, null);
      case "table":
        return createFormatContext(6, null, subtreeScope, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return createFormatContext(7, null, subtreeScope, null);
      case "colgroup":
        return createFormatContext(9, null, subtreeScope, null);
      case "tr":
        return createFormatContext(8, null, subtreeScope, null);
      case "head":
        if (2 > parentContext.insertionMode)
          return createFormatContext(3, null, subtreeScope, null);
        break;
      case "html":
        if (0 === parentContext.insertionMode)
          return createFormatContext(1, null, subtreeScope, null);
    }
    return 6 <= parentContext.insertionMode || 2 > parentContext.insertionMode ? createFormatContext(2, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      subtreeScope,
      null
    ) : parentContext;
  }
  __name(getChildFormatContext, "getChildFormatContext");
  function getSuspenseViewTransition(parentViewTransition) {
    return null === parentViewTransition ? null : {
      update: parentViewTransition.update,
      enter: "none",
      exit: "none",
      share: parentViewTransition.update,
      name: parentViewTransition.autoName,
      autoName: parentViewTransition.autoName,
      nameIdx: 0
    };
  }
  __name(getSuspenseViewTransition, "getSuspenseViewTransition");
  function getSuspenseFallbackFormatContext(resumableState, parentContext) {
    parentContext.tagScope & 32 && (resumableState.instructions |= 128);
    return createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      parentContext.tagScope | 12,
      getSuspenseViewTransition(parentContext.viewTransition)
    );
  }
  __name(getSuspenseFallbackFormatContext, "getSuspenseFallbackFormatContext");
  function getSuspenseContentFormatContext(resumableState, parentContext) {
    resumableState = getSuspenseViewTransition(parentContext.viewTransition);
    var subtreeScope = parentContext.tagScope | 16;
    null !== resumableState && "none" !== resumableState.share && (subtreeScope |= 64);
    return createFormatContext(
      parentContext.insertionMode,
      parentContext.selectedValue,
      subtreeScope,
      resumableState
    );
  }
  __name(getSuspenseContentFormatContext, "getSuspenseContentFormatContext");
  var textSeparator = stringToPrecomputedChunk("<!-- -->");
  function pushTextInstance(target, text2, renderState, textEmbedded) {
    if ("" === text2) return textEmbedded;
    textEmbedded && target.push(textSeparator);
    target.push(stringToChunk(escapeTextForBrowser(text2)));
    return true;
  }
  __name(pushTextInstance, "pushTextInstance");
  var styleNameCache = /* @__PURE__ */ new Map(), styleAttributeStart = stringToPrecomputedChunk(' style="'), styleAssign = stringToPrecomputedChunk(":"), styleSeparator = stringToPrecomputedChunk(";");
  function pushStyleAttribute(target, style) {
    if ("object" !== typeof style) throw Error(formatProdErrorMessage(62));
    var isFirst = true, styleName;
    for (styleName in style)
      if (hasOwnProperty.call(style, styleName)) {
        var styleValue = style[styleName];
        if (null != styleValue && "boolean" !== typeof styleValue && "" !== styleValue) {
          if (0 === styleName.indexOf("--")) {
            var nameChunk = stringToChunk(escapeTextForBrowser(styleName));
            styleValue = stringToChunk(
              escapeTextForBrowser(("" + styleValue).trim())
            );
          } else
            nameChunk = styleNameCache.get(styleName), void 0 === nameChunk && (nameChunk = stringToPrecomputedChunk(
              escapeTextForBrowser(
                styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")
              )
            ), styleNameCache.set(styleName, nameChunk)), styleValue = "number" === typeof styleValue ? 0 === styleValue || unitlessNumbers.has(styleName) ? stringToChunk("" + styleValue) : stringToChunk(styleValue + "px") : stringToChunk(
              escapeTextForBrowser(("" + styleValue).trim())
            );
          isFirst ? (isFirst = false, target.push(
            styleAttributeStart,
            nameChunk,
            styleAssign,
            styleValue
          )) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
        }
      }
    isFirst || target.push(attributeEnd);
  }
  __name(pushStyleAttribute, "pushStyleAttribute");
  var attributeSeparator = stringToPrecomputedChunk(" "), attributeAssign = stringToPrecomputedChunk('="'), attributeEnd = stringToPrecomputedChunk('"'), attributeEmptyString = stringToPrecomputedChunk('=""');
  function pushBooleanAttribute(target, name, value) {
    value && "function" !== typeof value && "symbol" !== typeof value && target.push(attributeSeparator, stringToChunk(name), attributeEmptyString);
  }
  __name(pushBooleanAttribute, "pushBooleanAttribute");
  function pushStringAttribute(target, name, value) {
    "function" !== typeof value && "symbol" !== typeof value && "boolean" !== typeof value && target.push(
      attributeSeparator,
      stringToChunk(name),
      attributeAssign,
      stringToChunk(escapeTextForBrowser(value)),
      attributeEnd
    );
  }
  __name(pushStringAttribute, "pushStringAttribute");
  var actionJavaScriptURL = stringToPrecomputedChunk(
    escapeTextForBrowser(
      "javascript:throw new Error('React form unexpectedly submitted.')"
    )
  ), startHiddenInputChunk = stringToPrecomputedChunk('<input type="hidden"');
  function pushAdditionalFormField(value, key) {
    this.push(startHiddenInputChunk);
    validateAdditionalFormField(value);
    pushStringAttribute(this, "name", key);
    pushStringAttribute(this, "value", value);
    this.push(endOfStartTagSelfClosing);
  }
  __name(pushAdditionalFormField, "pushAdditionalFormField");
  function validateAdditionalFormField(value) {
    if ("string" !== typeof value) throw Error(formatProdErrorMessage(480));
  }
  __name(validateAdditionalFormField, "validateAdditionalFormField");
  function getCustomFormFields(resumableState, formAction) {
    if ("function" === typeof formAction.$$FORM_ACTION) {
      var id = resumableState.nextFormID++;
      resumableState = resumableState.idPrefix + id;
      try {
        var customFields = formAction.$$FORM_ACTION(resumableState);
        if (customFields) {
          var formData = customFields.data;
          null != formData && formData.forEach(validateAdditionalFormField);
        }
        return customFields;
      } catch (x) {
        if ("object" === typeof x && null !== x && "function" === typeof x.then)
          throw x;
      }
    }
    return null;
  }
  __name(getCustomFormFields, "getCustomFormFields");
  function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
    var formData = null;
    if ("function" === typeof formAction) {
      var customFields = getCustomFormFields(resumableState, formAction);
      null !== customFields ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(
        attributeSeparator,
        stringToChunk("formAction"),
        attributeAssign,
        actionJavaScriptURL,
        attributeEnd
      ), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
    }
    null != name && pushAttribute(target, "name", name);
    null != formAction && pushAttribute(target, "formAction", formAction);
    null != formEncType && pushAttribute(target, "formEncType", formEncType);
    null != formMethod && pushAttribute(target, "formMethod", formMethod);
    null != formTarget && pushAttribute(target, "formTarget", formTarget);
    return formData;
  }
  __name(pushFormActionAttribute, "pushFormActionAttribute");
  function pushAttribute(target, name, value) {
    switch (name) {
      case "className":
        pushStringAttribute(target, "class", value);
        break;
      case "tabIndex":
        pushStringAttribute(target, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        pushStringAttribute(target, name, value);
        break;
      case "style":
        pushStyleAttribute(target, value);
        break;
      case "src":
      case "href":
        if ("" === value) break;
      case "action":
      case "formAction":
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
          break;
        value = sanitizeURL("" + value);
        target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "ref":
        break;
      case "autoFocus":
      case "multiple":
      case "muted":
        pushBooleanAttribute(target, name.toLowerCase(), value);
        break;
      case "xlinkHref":
        if ("function" === typeof value || "symbol" === typeof value || "boolean" === typeof value)
          break;
        value = sanitizeURL("" + value);
        target.push(
          attributeSeparator,
          stringToChunk("xlink:href"),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        "function" !== typeof value && "symbol" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeEmptyString
        );
        break;
      case "capture":
      case "download":
        true === value ? target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeEmptyString
        ) : false !== value && "function" !== typeof value && "symbol" !== typeof value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value && target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "rowSpan":
      case "start":
        "function" === typeof value || "symbol" === typeof value || isNaN(value) || target.push(
          attributeSeparator,
          stringToChunk(name),
          attributeAssign,
          stringToChunk(escapeTextForBrowser(value)),
          attributeEnd
        );
        break;
      case "xlinkActuate":
        pushStringAttribute(target, "xlink:actuate", value);
        break;
      case "xlinkArcrole":
        pushStringAttribute(target, "xlink:arcrole", value);
        break;
      case "xlinkRole":
        pushStringAttribute(target, "xlink:role", value);
        break;
      case "xlinkShow":
        pushStringAttribute(target, "xlink:show", value);
        break;
      case "xlinkTitle":
        pushStringAttribute(target, "xlink:title", value);
        break;
      case "xlinkType":
        pushStringAttribute(target, "xlink:type", value);
        break;
      case "xmlBase":
        pushStringAttribute(target, "xml:base", value);
        break;
      case "xmlLang":
        pushStringAttribute(target, "xml:lang", value);
        break;
      case "xmlSpace":
        pushStringAttribute(target, "xml:space", value);
        break;
      default:
        if (!(2 < name.length) || "o" !== name[0] && "O" !== name[0] || "n" !== name[1] && "N" !== name[1]) {
          if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) return;
            }
            target.push(
              attributeSeparator,
              stringToChunk(name),
              attributeAssign,
              stringToChunk(escapeTextForBrowser(value)),
              attributeEnd
            );
          }
        }
    }
  }
  __name(pushAttribute, "pushAttribute");
  var endOfStartTag = stringToPrecomputedChunk(">"), endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
  function pushInnerHTML(target, innerHTML, children) {
    if (null != innerHTML) {
      if (null != children) throw Error(formatProdErrorMessage(60));
      if ("object" !== typeof innerHTML || !("__html" in innerHTML))
        throw Error(formatProdErrorMessage(61));
      innerHTML = innerHTML.__html;
      null !== innerHTML && void 0 !== innerHTML && target.push(stringToChunk("" + innerHTML));
    }
  }
  __name(pushInnerHTML, "pushInnerHTML");
  function flattenOptionChildren(children) {
    var content = "";
    React2.Children.forEach(children, function(child) {
      null != child && (content += child);
    });
    return content;
  }
  __name(flattenOptionChildren, "flattenOptionChildren");
  var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""'), formReplayingRuntimeScript = stringToPrecomputedChunk(
    `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`
  );
  function injectFormReplayingRuntime(resumableState, renderState) {
    if (0 === (resumableState.instructions & 16)) {
      resumableState.instructions |= 16;
      var preamble = renderState.preamble, bootstrapChunks = renderState.bootstrapChunks;
      (preamble.htmlChunks || preamble.headChunks) && 0 === bootstrapChunks.length ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(
        endOfStartTag,
        formReplayingRuntimeScript,
        endInlineScript
      )) : bootstrapChunks.unshift(
        renderState.startInlineScript,
        endOfStartTag,
        formReplayingRuntimeScript,
        endInlineScript
      );
    }
  }
  __name(injectFormReplayingRuntime, "injectFormReplayingRuntime");
  var formStateMarkerIsMatching = stringToPrecomputedChunk("<!--F!-->"), formStateMarkerIsNotMatching = stringToPrecomputedChunk("<!--F-->");
  function pushLinkImpl(target, props) {
    target.push(startChunkForTag("link"));
    for (var propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(399, "link"));
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTagSelfClosing);
    return null;
  }
  __name(pushLinkImpl, "pushLinkImpl");
  var styleRegex = /(<\/|<)(s)(tyle)/gi;
  function styleReplacer(match, prefix2, s2, suffix2) {
    return "" + prefix2 + ("s" === s2 ? "\\73 " : "\\53 ") + suffix2;
  }
  __name(styleReplacer, "styleReplacer");
  function pushSelfClosing(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    for (var propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(399, tag2));
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTagSelfClosing);
    return null;
  }
  __name(pushSelfClosing, "pushSelfClosing");
  function pushTitleImpl(target, props) {
    target.push(startChunkForTag("title"));
    var children = null, innerHTML = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              children = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTag);
    props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
    "function" !== typeof props && "symbol" !== typeof props && null !== props && void 0 !== props && target.push(stringToChunk(escapeTextForBrowser("" + props)));
    pushInnerHTML(target, innerHTML, children);
    target.push(endChunkForTag("title"));
    return null;
  }
  __name(pushTitleImpl, "pushTitleImpl");
  var headPreambleContributionChunk = stringToPrecomputedChunk("<!--head-->"), bodyPreambleContributionChunk = stringToPrecomputedChunk("<!--body-->"), htmlPreambleContributionChunk = stringToPrecomputedChunk("<!--html-->");
  function pushScriptImpl(target, props) {
    target.push(startChunkForTag("script"));
    var children = null, innerHTML = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              children = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTag);
    pushInnerHTML(target, innerHTML, children);
    "string" === typeof children && target.push(
      stringToChunk(("" + children).replace(scriptRegex, scriptReplacer))
    );
    target.push(endChunkForTag("script"));
    return null;
  }
  __name(pushScriptImpl, "pushScriptImpl");
  function pushStartSingletonElement(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    var innerHTML = tag2 = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              tag2 = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTag);
    pushInnerHTML(target, innerHTML, tag2);
    return tag2;
  }
  __name(pushStartSingletonElement, "pushStartSingletonElement");
  function pushStartGenericElement(target, props, tag2) {
    target.push(startChunkForTag(tag2));
    var innerHTML = tag2 = null, propKey;
    for (propKey in props)
      if (hasOwnProperty.call(props, propKey)) {
        var propValue = props[propKey];
        if (null != propValue)
          switch (propKey) {
            case "children":
              tag2 = propValue;
              break;
            case "dangerouslySetInnerHTML":
              innerHTML = propValue;
              break;
            default:
              pushAttribute(target, propKey, propValue);
          }
      }
    target.push(endOfStartTag);
    pushInnerHTML(target, innerHTML, tag2);
    return "string" === typeof tag2 ? (target.push(stringToChunk(escapeTextForBrowser(tag2))), null) : tag2;
  }
  __name(pushStartGenericElement, "pushStartGenericElement");
  var leadingNewline = stringToPrecomputedChunk("\n"), VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache = /* @__PURE__ */ new Map();
  function startChunkForTag(tag2) {
    var tagStartChunk = validatedTagCache.get(tag2);
    if (void 0 === tagStartChunk) {
      if (!VALID_TAG_REGEX.test(tag2))
        throw Error(formatProdErrorMessage(65, tag2));
      tagStartChunk = stringToPrecomputedChunk("<" + tag2);
      validatedTagCache.set(tag2, tagStartChunk);
    }
    return tagStartChunk;
  }
  __name(startChunkForTag, "startChunkForTag");
  var doctypeChunk = stringToPrecomputedChunk("<!DOCTYPE html>");
  function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
    switch (type) {
      case "div":
      case "span":
      case "svg":
      case "path":
        break;
      case "a":
        target$jscomp$0.push(startChunkForTag("a"));
        var children = null, innerHTML = null, propKey;
        for (propKey in props)
          if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "children":
                  children = propValue;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML = propValue;
                  break;
                case "href":
                  "" === propValue ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                  break;
                default:
                  pushAttribute(target$jscomp$0, propKey, propValue);
              }
          }
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML, children);
        if ("string" === typeof children) {
          target$jscomp$0.push(stringToChunk(escapeTextForBrowser(children)));
          var JSCompiler_inline_result = null;
        } else JSCompiler_inline_result = children;
        return JSCompiler_inline_result;
      case "g":
      case "p":
      case "li":
        break;
      case "select":
        target$jscomp$0.push(startChunkForTag("select"));
        var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
        for (propKey$jscomp$0 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$0)) {
            var propValue$jscomp$0 = props[propKey$jscomp$0];
            if (null != propValue$jscomp$0)
              switch (propKey$jscomp$0) {
                case "children":
                  children$jscomp$0 = propValue$jscomp$0;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$0 = propValue$jscomp$0;
                  break;
                case "defaultValue":
                case "value":
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$0,
                    propValue$jscomp$0
                  );
              }
          }
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
        return children$jscomp$0;
      case "option":
        var selectedValue = formatContext.selectedValue;
        target$jscomp$0.push(startChunkForTag("option"));
        var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
        for (propKey$jscomp$1 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$1)) {
            var propValue$jscomp$1 = props[propKey$jscomp$1];
            if (null != propValue$jscomp$1)
              switch (propKey$jscomp$1) {
                case "children":
                  children$jscomp$1 = propValue$jscomp$1;
                  break;
                case "selected":
                  selected = propValue$jscomp$1;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$1 = propValue$jscomp$1;
                  break;
                case "value":
                  value = propValue$jscomp$1;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$1,
                    propValue$jscomp$1
                  );
              }
          }
        if (null != selectedValue) {
          var stringValue = null !== value ? "" + value : flattenOptionChildren(children$jscomp$1);
          if (isArrayImpl(selectedValue))
            for (var i2 = 0; i2 < selectedValue.length; i2++) {
              if ("" + selectedValue[i2] === stringValue) {
                target$jscomp$0.push(selectedMarkerAttribute);
                break;
              }
            }
          else
            "" + selectedValue === stringValue && target$jscomp$0.push(selectedMarkerAttribute);
        } else selected && target$jscomp$0.push(selectedMarkerAttribute);
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
        return children$jscomp$1;
      case "textarea":
        target$jscomp$0.push(startChunkForTag("textarea"));
        var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
        for (propKey$jscomp$2 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$2)) {
            var propValue$jscomp$2 = props[propKey$jscomp$2];
            if (null != propValue$jscomp$2)
              switch (propKey$jscomp$2) {
                case "children":
                  children$jscomp$2 = propValue$jscomp$2;
                  break;
                case "value":
                  value$jscomp$0 = propValue$jscomp$2;
                  break;
                case "defaultValue":
                  defaultValue = propValue$jscomp$2;
                  break;
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(91));
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$2,
                    propValue$jscomp$2
                  );
              }
          }
        null === value$jscomp$0 && null !== defaultValue && (value$jscomp$0 = defaultValue);
        target$jscomp$0.push(endOfStartTag);
        if (null != children$jscomp$2) {
          if (null != value$jscomp$0) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children$jscomp$2)) {
            if (1 < children$jscomp$2.length)
              throw Error(formatProdErrorMessage(93));
            value$jscomp$0 = "" + children$jscomp$2[0];
          }
          value$jscomp$0 = "" + children$jscomp$2;
        }
        "string" === typeof value$jscomp$0 && "\n" === value$jscomp$0[0] && target$jscomp$0.push(leadingNewline);
        null !== value$jscomp$0 && target$jscomp$0.push(
          stringToChunk(escapeTextForBrowser("" + value$jscomp$0))
        );
        return null;
      case "input":
        target$jscomp$0.push(startChunkForTag("input"));
        var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
        for (propKey$jscomp$3 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$3)) {
            var propValue$jscomp$3 = props[propKey$jscomp$3];
            if (null != propValue$jscomp$3)
              switch (propKey$jscomp$3) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(399, "input"));
                case "name":
                  name = propValue$jscomp$3;
                  break;
                case "formAction":
                  formAction = propValue$jscomp$3;
                  break;
                case "formEncType":
                  formEncType = propValue$jscomp$3;
                  break;
                case "formMethod":
                  formMethod = propValue$jscomp$3;
                  break;
                case "formTarget":
                  formTarget = propValue$jscomp$3;
                  break;
                case "defaultChecked":
                  defaultChecked = propValue$jscomp$3;
                  break;
                case "defaultValue":
                  defaultValue$jscomp$0 = propValue$jscomp$3;
                  break;
                case "checked":
                  checked = propValue$jscomp$3;
                  break;
                case "value":
                  value$jscomp$1 = propValue$jscomp$3;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$3,
                    propValue$jscomp$3
                  );
              }
          }
        var formData = pushFormActionAttribute(
          target$jscomp$0,
          resumableState,
          renderState,
          formAction,
          formEncType,
          formMethod,
          formTarget,
          name
        );
        null !== checked ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : null !== defaultChecked && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
        null !== value$jscomp$1 ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : null !== defaultValue$jscomp$0 && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
        target$jscomp$0.push(endOfStartTagSelfClosing);
        null != formData && formData.forEach(pushAdditionalFormField, target$jscomp$0);
        return null;
      case "button":
        target$jscomp$0.push(startChunkForTag("button"));
        var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
        for (propKey$jscomp$4 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$4)) {
            var propValue$jscomp$4 = props[propKey$jscomp$4];
            if (null != propValue$jscomp$4)
              switch (propKey$jscomp$4) {
                case "children":
                  children$jscomp$3 = propValue$jscomp$4;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$2 = propValue$jscomp$4;
                  break;
                case "name":
                  name$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formAction":
                  formAction$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formEncType":
                  formEncType$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formMethod":
                  formMethod$jscomp$0 = propValue$jscomp$4;
                  break;
                case "formTarget":
                  formTarget$jscomp$0 = propValue$jscomp$4;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$4,
                    propValue$jscomp$4
                  );
              }
          }
        var formData$jscomp$0 = pushFormActionAttribute(
          target$jscomp$0,
          resumableState,
          renderState,
          formAction$jscomp$0,
          formEncType$jscomp$0,
          formMethod$jscomp$0,
          formTarget$jscomp$0,
          name$jscomp$0
        );
        target$jscomp$0.push(endOfStartTag);
        null != formData$jscomp$0 && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
        if ("string" === typeof children$jscomp$3) {
          target$jscomp$0.push(
            stringToChunk(escapeTextForBrowser(children$jscomp$3))
          );
          var JSCompiler_inline_result$jscomp$0 = null;
        } else JSCompiler_inline_result$jscomp$0 = children$jscomp$3;
        return JSCompiler_inline_result$jscomp$0;
      case "form":
        target$jscomp$0.push(startChunkForTag("form"));
        var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
        for (propKey$jscomp$5 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$5)) {
            var propValue$jscomp$5 = props[propKey$jscomp$5];
            if (null != propValue$jscomp$5)
              switch (propKey$jscomp$5) {
                case "children":
                  children$jscomp$4 = propValue$jscomp$5;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$3 = propValue$jscomp$5;
                  break;
                case "action":
                  formAction$jscomp$1 = propValue$jscomp$5;
                  break;
                case "encType":
                  formEncType$jscomp$1 = propValue$jscomp$5;
                  break;
                case "method":
                  formMethod$jscomp$1 = propValue$jscomp$5;
                  break;
                case "target":
                  formTarget$jscomp$1 = propValue$jscomp$5;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$5,
                    propValue$jscomp$5
                  );
              }
          }
        var formData$jscomp$1 = null, formActionName = null;
        if ("function" === typeof formAction$jscomp$1) {
          var customFields = getCustomFormFields(
            resumableState,
            formAction$jscomp$1
          );
          null !== customFields ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(
            attributeSeparator,
            stringToChunk("action"),
            attributeAssign,
            actionJavaScriptURL,
            attributeEnd
          ), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
        }
        null != formAction$jscomp$1 && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
        null != formEncType$jscomp$1 && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
        null != formMethod$jscomp$1 && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
        null != formTarget$jscomp$1 && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
        target$jscomp$0.push(endOfStartTag);
        null !== formActionName && (target$jscomp$0.push(startHiddenInputChunk), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), null != formData$jscomp$1 && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
        if ("string" === typeof children$jscomp$4) {
          target$jscomp$0.push(
            stringToChunk(escapeTextForBrowser(children$jscomp$4))
          );
          var JSCompiler_inline_result$jscomp$1 = null;
        } else JSCompiler_inline_result$jscomp$1 = children$jscomp$4;
        return JSCompiler_inline_result$jscomp$1;
      case "menuitem":
        target$jscomp$0.push(startChunkForTag("menuitem"));
        for (var propKey$jscomp$6 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$6)) {
            var propValue$jscomp$6 = props[propKey$jscomp$6];
            if (null != propValue$jscomp$6)
              switch (propKey$jscomp$6) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(400));
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$6,
                    propValue$jscomp$6
                  );
              }
          }
        target$jscomp$0.push(endOfStartTag);
        return null;
      case "object":
        target$jscomp$0.push(startChunkForTag("object"));
        var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
        for (propKey$jscomp$7 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$7)) {
            var propValue$jscomp$7 = props[propKey$jscomp$7];
            if (null != propValue$jscomp$7)
              switch (propKey$jscomp$7) {
                case "children":
                  children$jscomp$5 = propValue$jscomp$7;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$4 = propValue$jscomp$7;
                  break;
                case "data":
                  var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                  if ("" === sanitizedValue) break;
                  target$jscomp$0.push(
                    attributeSeparator,
                    stringToChunk("data"),
                    attributeAssign,
                    stringToChunk(escapeTextForBrowser(sanitizedValue)),
                    attributeEnd
                  );
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$7,
                    propValue$jscomp$7
                  );
              }
          }
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
        if ("string" === typeof children$jscomp$5) {
          target$jscomp$0.push(
            stringToChunk(escapeTextForBrowser(children$jscomp$5))
          );
          var JSCompiler_inline_result$jscomp$2 = null;
        } else JSCompiler_inline_result$jscomp$2 = children$jscomp$5;
        return JSCompiler_inline_result$jscomp$2;
      case "title":
        var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
        if (4 === formatContext.insertionMode || noscriptTagInScope || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$3 = pushTitleImpl(
            target$jscomp$0,
            props
          );
        else
          isFallback ? JSCompiler_inline_result$jscomp$3 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$3 = void 0);
        return JSCompiler_inline_result$jscomp$3;
      case "link":
        var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$0 || null != props.itemProp || "string" !== typeof rel || "string" !== typeof href || "" === href) {
          pushLinkImpl(target$jscomp$0, props);
          var JSCompiler_inline_result$jscomp$4 = null;
        } else if ("stylesheet" === props.rel)
          if ("string" !== typeof precedence || null != props.disabled || props.onLoad || props.onError)
            JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
              target$jscomp$0,
              props
            );
          else {
            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
            if (null !== resourceState) {
              resumableState.styleResources[href] = null;
              styleQueue || (styleQueue = {
                precedence: stringToChunk(escapeTextForBrowser(precedence)),
                rules: [],
                hrefs: [],
                sheets: /* @__PURE__ */ new Map()
              }, renderState.styles.set(precedence, styleQueue));
              var resource = {
                state: 0,
                props: assign({}, props, {
                  "data-precedence": props.precedence,
                  precedence: null
                })
              };
              if (resourceState) {
                2 === resourceState.length && adoptPreloadCredentials(resource.props, resourceState);
                var preloadResource = renderState.preloads.stylesheets.get(href);
                preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = 1;
              }
              styleQueue.sheets.set(href, resource);
              hoistableState && hoistableState.stylesheets.add(resource);
            } else if (styleQueue) {
              var resource$9 = styleQueue.sheets.get(href);
              resource$9 && hoistableState && hoistableState.stylesheets.add(resource$9);
            }
            textEmbedded && target$jscomp$0.push(textSeparator);
            JSCompiler_inline_result$jscomp$4 = null;
          }
        else
          props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$4 = pushLinkImpl(
            target$jscomp$0,
            props
          ) : (textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$4 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
        return JSCompiler_inline_result$jscomp$4;
      case "script":
        var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
        if ("string" !== typeof props.src || !props.src || !asyncProp || "function" === typeof asyncProp || "symbol" === typeof asyncProp || props.onLoad || props.onError || 4 === formatContext.insertionMode || noscriptTagInScope$jscomp$1 || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$5 = pushScriptImpl(
            target$jscomp$0,
            props
          );
        else {
          var key = props.src;
          if ("module" === props.type) {
            var resources = resumableState.moduleScriptResources;
            var preloads = renderState.preloads.moduleScripts;
          } else
            resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
          var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : void 0;
          if (null !== resourceState$jscomp$0) {
            resources[key] = null;
            var scriptProps = props;
            if (resourceState$jscomp$0) {
              2 === resourceState$jscomp$0.length && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
              var preloadResource$jscomp$0 = preloads.get(key);
              preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
            }
            var resource$jscomp$0 = [];
            renderState.scripts.add(resource$jscomp$0);
            pushScriptImpl(resource$jscomp$0, scriptProps);
          }
          textEmbedded && target$jscomp$0.push(textSeparator);
          JSCompiler_inline_result$jscomp$5 = null;
        }
        return JSCompiler_inline_result$jscomp$5;
      case "style":
        var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1, precedence$jscomp$0 = props.precedence, href$jscomp$0 = props.href, nonce = props.nonce;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$2 || null != props.itemProp || "string" !== typeof precedence$jscomp$0 || "string" !== typeof href$jscomp$0 || "" === href$jscomp$0) {
          target$jscomp$0.push(startChunkForTag("style"));
          var children$jscomp$6 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
          for (propKey$jscomp$8 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$8)) {
              var propValue$jscomp$8 = props[propKey$jscomp$8];
              if (null != propValue$jscomp$8)
                switch (propKey$jscomp$8) {
                  case "children":
                    children$jscomp$6 = propValue$jscomp$8;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$5 = propValue$jscomp$8;
                    break;
                  default:
                    pushAttribute(
                      target$jscomp$0,
                      propKey$jscomp$8,
                      propValue$jscomp$8
                    );
                }
            }
          target$jscomp$0.push(endOfStartTag);
          var child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
          "function" !== typeof child && "symbol" !== typeof child && null !== child && void 0 !== child && target$jscomp$0.push(
            stringToChunk(("" + child).replace(styleRegex, styleReplacer))
          );
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$6);
          target$jscomp$0.push(endChunkForTag("style"));
          var JSCompiler_inline_result$jscomp$6 = null;
        } else {
          var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0);
          if (null !== (resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : void 0)) {
            resumableState.styleResources[href$jscomp$0] = null;
            styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
              precedence: stringToChunk(
                escapeTextForBrowser(precedence$jscomp$0)
              ),
              rules: [],
              hrefs: [],
              sheets: /* @__PURE__ */ new Map()
            }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
            var nonceStyle = renderState.nonce.style;
            if (!nonceStyle || nonceStyle === nonce) {
              styleQueue$jscomp$0.hrefs.push(
                stringToChunk(escapeTextForBrowser(href$jscomp$0))
              );
              var target = styleQueue$jscomp$0.rules, children$jscomp$7 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
              for (propKey$jscomp$9 in props)
                if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                  var propValue$jscomp$9 = props[propKey$jscomp$9];
                  if (null != propValue$jscomp$9)
                    switch (propKey$jscomp$9) {
                      case "children":
                        children$jscomp$7 = propValue$jscomp$9;
                        break;
                      case "dangerouslySetInnerHTML":
                        innerHTML$jscomp$6 = propValue$jscomp$9;
                    }
                }
              var child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
              "function" !== typeof child$jscomp$0 && "symbol" !== typeof child$jscomp$0 && null !== child$jscomp$0 && void 0 !== child$jscomp$0 && target.push(
                stringToChunk(
                  ("" + child$jscomp$0).replace(styleRegex, styleReplacer)
                )
              );
              pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$7);
            }
          }
          styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
          textEmbedded && target$jscomp$0.push(textSeparator);
          JSCompiler_inline_result$jscomp$6 = void 0;
        }
        return JSCompiler_inline_result$jscomp$6;
      case "meta":
        var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
        if (4 === formatContext.insertionMode || noscriptTagInScope$jscomp$3 || null != props.itemProp)
          var JSCompiler_inline_result$jscomp$7 = pushSelfClosing(
            target$jscomp$0,
            props,
            "meta"
          );
        else
          textEmbedded && target$jscomp$0.push(textSeparator), JSCompiler_inline_result$jscomp$7 = isFallback$jscomp$1 ? null : "string" === typeof props.charSet ? pushSelfClosing(renderState.charsetChunks, props, "meta") : "viewport" === props.name ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
        return JSCompiler_inline_result$jscomp$7;
      case "listing":
      case "pre":
        target$jscomp$0.push(startChunkForTag(type));
        var children$jscomp$8 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
        for (propKey$jscomp$10 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$10)) {
            var propValue$jscomp$10 = props[propKey$jscomp$10];
            if (null != propValue$jscomp$10)
              switch (propKey$jscomp$10) {
                case "children":
                  children$jscomp$8 = propValue$jscomp$10;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$7 = propValue$jscomp$10;
                  break;
                default:
                  pushAttribute(
                    target$jscomp$0,
                    propKey$jscomp$10,
                    propValue$jscomp$10
                  );
              }
          }
        target$jscomp$0.push(endOfStartTag);
        if (null != innerHTML$jscomp$7) {
          if (null != children$jscomp$8) throw Error(formatProdErrorMessage(60));
          if ("object" !== typeof innerHTML$jscomp$7 || !("__html" in innerHTML$jscomp$7))
            throw Error(formatProdErrorMessage(61));
          var html = innerHTML$jscomp$7.__html;
          null !== html && void 0 !== html && ("string" === typeof html && 0 < html.length && "\n" === html[0] ? target$jscomp$0.push(leadingNewline, stringToChunk(html)) : target$jscomp$0.push(stringToChunk("" + html)));
        }
        "string" === typeof children$jscomp$8 && "\n" === children$jscomp$8[0] && target$jscomp$0.push(leadingNewline);
        return children$jscomp$8;
      case "img":
        var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
        if (!("lazy" === props.loading || !src && !srcSet || "string" !== typeof src && null != src || "string" !== typeof srcSet && null != srcSet || "low" === props.fetchPriority || pictureOrNoScriptTagInScope) && ("string" !== typeof src || ":" !== src[4] || "d" !== src[0] && "D" !== src[0] || "a" !== src[1] && "A" !== src[1] || "t" !== src[2] && "T" !== src[2] || "a" !== src[3] && "A" !== src[3]) && ("string" !== typeof srcSet || ":" !== srcSet[4] || "d" !== srcSet[0] && "D" !== srcSet[0] || "a" !== srcSet[1] && "A" !== srcSet[1] || "t" !== srcSet[2] && "T" !== srcSet[2] || "a" !== srcSet[3] && "A" !== srcSet[3])) {
          null !== hoistableState && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
          var sizes = "string" === typeof props.sizes ? props.sizes : void 0, key$jscomp$0 = srcSet ? srcSet + "\n" + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
          if (resource$jscomp$1) {
            if ("high" === props.fetchPriority || 10 > renderState.highImagePreloads.size)
              promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
          } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
            resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
            var input = props.crossOrigin;
            var JSCompiler_inline_result$jscomp$8 = "string" === typeof input ? "use-credentials" === input ? input : "" : void 0;
            var headers = renderState.headers, header;
            headers && 0 < headers.remainingCapacity && "string" !== typeof props.srcSet && ("high" === props.fetchPriority || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
              imageSrcSet: props.srcSet,
              imageSizes: props.sizes,
              crossOrigin: JSCompiler_inline_result$jscomp$8,
              integrity: props.integrity,
              nonce: props.nonce,
              type: props.type,
              fetchPriority: props.fetchPriority,
              referrerPolicy: props.refererPolicy
            }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
              rel: "preload",
              as: "image",
              href: srcSet ? void 0 : src,
              imageSrcSet: srcSet,
              imageSizes: sizes,
              crossOrigin: JSCompiler_inline_result$jscomp$8,
              integrity: props.integrity,
              type: props.type,
              fetchPriority: props.fetchPriority,
              referrerPolicy: props.referrerPolicy
            }), "high" === props.fetchPriority || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
          }
        }
        return pushSelfClosing(target$jscomp$0, props, "img");
      case "base":
      case "area":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "param":
      case "source":
      case "track":
      case "wbr":
        return pushSelfClosing(target$jscomp$0, props, type);
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        break;
      case "head":
        if (2 > formatContext.insertionMode) {
          var preamble = preambleState || renderState.preamble;
          if (preamble.headChunks)
            throw Error(formatProdErrorMessage(545, "`<head>`"));
          null !== preambleState && target$jscomp$0.push(headPreambleContributionChunk);
          preamble.headChunks = [];
          var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(
            preamble.headChunks,
            props,
            "head"
          );
        } else
          JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "head"
          );
        return JSCompiler_inline_result$jscomp$9;
      case "body":
        if (2 > formatContext.insertionMode) {
          var preamble$jscomp$0 = preambleState || renderState.preamble;
          if (preamble$jscomp$0.bodyChunks)
            throw Error(formatProdErrorMessage(545, "`<body>`"));
          null !== preambleState && target$jscomp$0.push(bodyPreambleContributionChunk);
          preamble$jscomp$0.bodyChunks = [];
          var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(
            preamble$jscomp$0.bodyChunks,
            props,
            "body"
          );
        } else
          JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "body"
          );
        return JSCompiler_inline_result$jscomp$10;
      case "html":
        if (0 === formatContext.insertionMode) {
          var preamble$jscomp$1 = preambleState || renderState.preamble;
          if (preamble$jscomp$1.htmlChunks)
            throw Error(formatProdErrorMessage(545, "`<html>`"));
          null !== preambleState && target$jscomp$0.push(htmlPreambleContributionChunk);
          preamble$jscomp$1.htmlChunks = [doctypeChunk];
          var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(
            preamble$jscomp$1.htmlChunks,
            props,
            "html"
          );
        } else
          JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(
            target$jscomp$0,
            props,
            "html"
          );
        return JSCompiler_inline_result$jscomp$11;
      default:
        if (-1 !== type.indexOf("-")) {
          target$jscomp$0.push(startChunkForTag(type));
          var children$jscomp$9 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
          for (propKey$jscomp$11 in props)
            if (hasOwnProperty.call(props, propKey$jscomp$11)) {
              var propValue$jscomp$11 = props[propKey$jscomp$11];
              if (null != propValue$jscomp$11) {
                var attributeName = propKey$jscomp$11;
                switch (propKey$jscomp$11) {
                  case "children":
                    children$jscomp$9 = propValue$jscomp$11;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$8 = propValue$jscomp$11;
                    break;
                  case "style":
                    pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                  case "ref":
                    break;
                  case "className":
                    attributeName = "class";
                  default:
                    if (isAttributeNameSafe(propKey$jscomp$11) && "function" !== typeof propValue$jscomp$11 && "symbol" !== typeof propValue$jscomp$11 && false !== propValue$jscomp$11) {
                      if (true === propValue$jscomp$11) propValue$jscomp$11 = "";
                      else if ("object" === typeof propValue$jscomp$11) continue;
                      target$jscomp$0.push(
                        attributeSeparator,
                        stringToChunk(attributeName),
                        attributeAssign,
                        stringToChunk(escapeTextForBrowser(propValue$jscomp$11)),
                        attributeEnd
                      );
                    }
                }
              }
            }
          target$jscomp$0.push(endOfStartTag);
          pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$9);
          return children$jscomp$9;
        }
    }
    return pushStartGenericElement(target$jscomp$0, props, type);
  }
  __name(pushStartInstance, "pushStartInstance");
  var endTagCache = /* @__PURE__ */ new Map();
  function endChunkForTag(tag2) {
    var chunk = endTagCache.get(tag2);
    void 0 === chunk && (chunk = stringToPrecomputedChunk("</" + tag2 + ">"), endTagCache.set(tag2, chunk));
    return chunk;
  }
  __name(endChunkForTag, "endChunkForTag");
  function hoistPreambleState(renderState, preambleState) {
    renderState = renderState.preamble;
    null === renderState.htmlChunks && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
    null === renderState.headChunks && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
    null === renderState.bodyChunks && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
  }
  __name(hoistPreambleState, "hoistPreambleState");
  function writeBootstrap(destination, renderState) {
    renderState = renderState.bootstrapChunks;
    for (var i2 = 0; i2 < renderState.length - 1; i2++)
      writeChunk(destination, renderState[i2]);
    return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, writeChunkAndReturn(destination, i2)) : true;
  }
  __name(writeBootstrap, "writeBootstrap");
  var shellTimeRuntimeScript = stringToPrecomputedChunk(
    "requestAnimationFrame(function(){$RT=performance.now()});"
  ), placeholder1 = stringToPrecomputedChunk('<template id="'), placeholder2 = stringToPrecomputedChunk('"></template>'), startActivityBoundary = stringToPrecomputedChunk("<!--&-->"), endActivityBoundary = stringToPrecomputedChunk("<!--/&-->"), startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->"), startPendingSuspenseBoundary1 = stringToPrecomputedChunk(
    '<!--$?--><template id="'
  ), startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>'), startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->"), endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->"), clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template"), clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"'), clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
  stringToPrecomputedChunk(' data-msg="');
  stringToPrecomputedChunk(' data-stck="');
  stringToPrecomputedChunk(' data-cstck="');
  var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
  function writeStartPendingSuspenseBoundary(destination, renderState, id) {
    writeChunk(destination, startPendingSuspenseBoundary1);
    if (null === id) throw Error(formatProdErrorMessage(395));
    writeChunk(destination, renderState.boundaryPrefix);
    writeChunk(destination, stringToChunk(id.toString(16)));
    return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
  }
  __name(writeStartPendingSuspenseBoundary, "writeStartPendingSuspenseBoundary");
  var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="'), startSegmentHTML2 = stringToPrecomputedChunk('">'), endSegmentHTML = stringToPrecomputedChunk("</div>"), startSegmentSVG = stringToPrecomputedChunk(
    '<svg aria-hidden="true" style="display:none" id="'
  ), startSegmentSVG2 = stringToPrecomputedChunk('">'), endSegmentSVG = stringToPrecomputedChunk("</svg>"), startSegmentMathML = stringToPrecomputedChunk(
    '<math aria-hidden="true" style="display:none" id="'
  ), startSegmentMathML2 = stringToPrecomputedChunk('">'), endSegmentMathML = stringToPrecomputedChunk("</math>"), startSegmentTable = stringToPrecomputedChunk('<table hidden id="'), startSegmentTable2 = stringToPrecomputedChunk('">'), endSegmentTable = stringToPrecomputedChunk("</table>"), startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="'), startSegmentTableBody2 = stringToPrecomputedChunk('">'), endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>"), startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="'), startSegmentTableRow2 = stringToPrecomputedChunk('">'), endSegmentTableRow = stringToPrecomputedChunk("</tr></table>"), startSegmentColGroup = stringToPrecomputedChunk(
    '<table hidden><colgroup id="'
  ), startSegmentColGroup2 = stringToPrecomputedChunk('">'), endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
  function writeStartSegment(destination, renderState, formatContext, id) {
    switch (formatContext.insertionMode) {
      case 0:
      case 1:
      case 3:
      case 2:
        return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentHTML2);
      case 4:
        return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentSVG2);
      case 5:
        return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentMathML2);
      case 6:
        return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTable2);
      case 7:
        return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableBody2);
      case 8:
        return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentTableRow2);
      case 9:
        return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, stringToChunk(id.toString(16))), writeChunkAndReturn(destination, startSegmentColGroup2);
      default:
        throw Error(formatProdErrorMessage(397));
    }
  }
  __name(writeStartSegment, "writeStartSegment");
  function writeEndSegment(destination, formatContext) {
    switch (formatContext.insertionMode) {
      case 0:
      case 1:
      case 3:
      case 2:
        return writeChunkAndReturn(destination, endSegmentHTML);
      case 4:
        return writeChunkAndReturn(destination, endSegmentSVG);
      case 5:
        return writeChunkAndReturn(destination, endSegmentMathML);
      case 6:
        return writeChunkAndReturn(destination, endSegmentTable);
      case 7:
        return writeChunkAndReturn(destination, endSegmentTableBody);
      case 8:
        return writeChunkAndReturn(destination, endSegmentTableRow);
      case 9:
        return writeChunkAndReturn(destination, endSegmentColGroup);
      default:
        throw Error(formatProdErrorMessage(397));
    }
  }
  __name(writeEndSegment, "writeEndSegment");
  var completeSegmentScript1Full = stringToPrecomputedChunk(
    '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'
  ), completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("'), completeSegmentScript2 = stringToPrecomputedChunk('","'), completeSegmentScriptEnd = stringToPrecomputedChunk('")<\/script>');
  stringToPrecomputedChunk('<template data-rsi="" data-sid="');
  stringToPrecomputedChunk('" data-pid="');
  var completeBoundaryScriptFunctionOnly = stringToPrecomputedChunk(
    '$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};\n$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};'
  );
  stringToChunk(
    `$RV=function(A,g){function k(a,b){var e=a.getAttribute(b);e&&(b=a.style,l.push(a,b.viewTransitionName,b.viewTransitionClass),"auto"!==e&&(b.viewTransitionClass=e),(a=a.getAttribute("vt-name"))||(a="_T_"+K++ +"_"),b.viewTransitionName=a,B=!0)}var B=!1,K=0,l=[];try{var f=document.__reactViewTransition;if(f){f.finished.finally($RV.bind(null,g));return}var m=new Map;for(f=1;f<g.length;f+=2)for(var h=g[f].querySelectorAll("[vt-share]"),d=0;d<h.length;d++){var c=h[d];m.set(c.getAttribute("vt-name"),c)}var u=[];for(h=0;h<g.length;h+=2){var C=g[h],x=C.parentNode;if(x){var v=x.getBoundingClientRect();if(v.left||v.top||v.width||v.height){c=C;for(f=0;c;){if(8===c.nodeType){var r=c.data;if("/$"===r)if(0===f)break;else f--;else"$"!==r&&"$?"!==r&&"$~"!==r&&"$!"!==r||f++}else if(1===c.nodeType){d=c;var D=d.getAttribute("vt-name"),y=m.get(D);k(d,y?"vt-share":"vt-exit");y&&(k(y,"vt-share"),m.set(D,null));var E=d.querySelectorAll("[vt-share]");for(d=0;d<E.length;d++){var F=E[d],G=F.getAttribute("vt-name"),
H=m.get(G);H&&(k(F,"vt-share"),k(H,"vt-share"),m.set(G,null))}}c=c.nextSibling}for(var I=g[h+1],t=I.firstElementChild;t;)null!==m.get(t.getAttribute("vt-name"))&&k(t,"vt-enter"),t=t.nextElementSibling;c=x;do for(var n=c.firstElementChild;n;){var J=n.getAttribute("vt-update");J&&"none"!==J&&!l.includes(n)&&k(n,"vt-update");n=n.nextElementSibling}while((c=c.parentNode)&&1===c.nodeType&&"none"!==c.getAttribute("vt-update"));u.push.apply(u,I.querySelectorAll('img[src]:not([loading="lazy"])'))}}}if(B){var z=
document.__reactViewTransition=document.startViewTransition({update:function(){A(g);for(var a=[document.documentElement.clientHeight,document.fonts.ready],b={},e=0;e<u.length;b={g:b.g},e++)if(b.g=u[e],!b.g.complete){var p=b.g.getBoundingClientRect();0<p.bottom&&0<p.right&&p.top<window.innerHeight&&p.left<window.innerWidth&&(p=new Promise(function(w){return function(q){w.g.addEventListener("load",q);w.g.addEventListener("error",q)}}(b)),a.push(p))}return Promise.race([Promise.all(a),new Promise(function(w){var q=
performance.now();setTimeout(w,2300>q&&2E3<q?2300-q:500)})])},types:[]});z.ready.finally(function(){for(var a=l.length-3;0<=a;a-=3){var b=l[a],e=b.style;e.viewTransitionName=l[a+1];e.viewTransitionClass=l[a+1];""===b.getAttribute("style")&&b.removeAttribute("style")}});z.finished.finally(function(){document.__reactViewTransition===z&&(document.__reactViewTransition=null)});$RB=[];return}}catch(a){}A(g)}.bind(null,$RV);`
  );
  var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("'), completeBoundaryWithStylesScript1FullPartial = stringToPrecomputedChunk(
    '$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=\n"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=\n"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("'
  ), completeBoundaryWithStylesScript1Partial = stringToPrecomputedChunk('$RR("'), completeBoundaryScript2 = stringToPrecomputedChunk('","'), completeBoundaryScript3a = stringToPrecomputedChunk('",'), completeBoundaryScript3b = stringToPrecomputedChunk('"'), completeBoundaryScriptEnd = stringToPrecomputedChunk(")<\/script>");
  stringToPrecomputedChunk('<template data-rci="" data-bid="');
  stringToPrecomputedChunk('<template data-rri="" data-bid="');
  stringToPrecomputedChunk('" data-sid="');
  stringToPrecomputedChunk('" data-sty="');
  var clientRenderScriptFunctionOnly = stringToPrecomputedChunk(
    '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};'
  ), clientRenderScript1Full = stringToPrecomputedChunk(
    '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("'
  ), clientRenderScript1Partial = stringToPrecomputedChunk('$RX("'), clientRenderScript1A = stringToPrecomputedChunk('"'), clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(","), clientRenderScriptEnd = stringToPrecomputedChunk(")<\/script>");
  stringToPrecomputedChunk('<template data-rxi="" data-bid="');
  stringToPrecomputedChunk('" data-dgst="');
  stringToPrecomputedChunk('" data-msg="');
  stringToPrecomputedChunk('" data-stck="');
  stringToPrecomputedChunk('" data-cstck="');
  var regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
  function escapeJSStringsForInstructionScripts(input) {
    return JSON.stringify(input).replace(
      regexForJSStringsInInstructionScripts,
      function(match) {
        switch (match) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error(
              "escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
    );
  }
  __name(escapeJSStringsForInstructionScripts, "escapeJSStringsForInstructionScripts");
  var regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
  function escapeJSObjectForInstructionScripts(input) {
    return JSON.stringify(input).replace(
      regexForJSStringsInScripts,
      function(match) {
        switch (match) {
          case "&":
            return "\\u0026";
          case ">":
            return "\\u003e";
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error(
              "escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
            );
        }
      }
    );
  }
  __name(escapeJSObjectForInstructionScripts, "escapeJSObjectForInstructionScripts");
  var lateStyleTagResourceOpen1 = stringToPrecomputedChunk(
    ' media="not all" data-precedence="'
  ), lateStyleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), lateStyleTagResourceOpen3 = stringToPrecomputedChunk('">'), lateStyleTagTemplateClose = stringToPrecomputedChunk("</style>"), currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true;
  function flushStyleTagsLateForBoundary(styleQueue) {
    var rules = styleQueue.rules, hrefs = styleQueue.hrefs, i2 = 0;
    if (hrefs.length) {
      writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
      writeChunk(this, lateStyleTagResourceOpen1);
      writeChunk(this, styleQueue.precedence);
      for (writeChunk(this, lateStyleTagResourceOpen2); i2 < hrefs.length - 1; i2++)
        writeChunk(this, hrefs[i2]), writeChunk(this, spaceSeparator);
      writeChunk(this, hrefs[i2]);
      writeChunk(this, lateStyleTagResourceOpen3);
      for (i2 = 0; i2 < rules.length; i2++) writeChunk(this, rules[i2]);
      destinationHasCapacity = writeChunkAndReturn(
        this,
        lateStyleTagTemplateClose
      );
      currentlyRenderingBoundaryHasStylesToHoist = true;
      rules.length = 0;
      hrefs.length = 0;
    }
  }
  __name(flushStyleTagsLateForBoundary, "flushStyleTagsLateForBoundary");
  function hasStylesToHoist(stylesheet) {
    return 2 !== stylesheet.state ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
  }
  __name(hasStylesToHoist, "hasStylesToHoist");
  function writeHoistablesForBoundary(destination, hoistableState, renderState) {
    currentlyRenderingBoundaryHasStylesToHoist = false;
    destinationHasCapacity = true;
    currentlyFlushingRenderState = renderState;
    hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
    currentlyFlushingRenderState = null;
    hoistableState.stylesheets.forEach(hasStylesToHoist);
    currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
    return destinationHasCapacity;
  }
  __name(writeHoistablesForBoundary, "writeHoistablesForBoundary");
  function flushResource(resource) {
    for (var i2 = 0; i2 < resource.length; i2++) writeChunk(this, resource[i2]);
    resource.length = 0;
  }
  __name(flushResource, "flushResource");
  var stylesheetFlushingQueue = [];
  function flushStyleInPreamble(stylesheet) {
    pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
    for (var i2 = 0; i2 < stylesheetFlushingQueue.length; i2++)
      writeChunk(this, stylesheetFlushingQueue[i2]);
    stylesheetFlushingQueue.length = 0;
    stylesheet.state = 2;
  }
  __name(flushStyleInPreamble, "flushStyleInPreamble");
  var styleTagResourceOpen1 = stringToPrecomputedChunk(' data-precedence="'), styleTagResourceOpen2 = stringToPrecomputedChunk('" data-href="'), spaceSeparator = stringToPrecomputedChunk(" "), styleTagResourceOpen3 = stringToPrecomputedChunk('">'), styleTagResourceClose = stringToPrecomputedChunk("</style>");
  function flushStylesInPreamble(styleQueue) {
    var hasStylesheets = 0 < styleQueue.sheets.size;
    styleQueue.sheets.forEach(flushStyleInPreamble, this);
    styleQueue.sheets.clear();
    var rules = styleQueue.rules, hrefs = styleQueue.hrefs;
    if (!hasStylesheets || hrefs.length) {
      writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
      writeChunk(this, styleTagResourceOpen1);
      writeChunk(this, styleQueue.precedence);
      styleQueue = 0;
      if (hrefs.length) {
        for (writeChunk(this, styleTagResourceOpen2); styleQueue < hrefs.length - 1; styleQueue++)
          writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
        writeChunk(this, hrefs[styleQueue]);
      }
      writeChunk(this, styleTagResourceOpen3);
      for (styleQueue = 0; styleQueue < rules.length; styleQueue++)
        writeChunk(this, rules[styleQueue]);
      writeChunk(this, styleTagResourceClose);
      rules.length = 0;
      hrefs.length = 0;
    }
  }
  __name(flushStylesInPreamble, "flushStylesInPreamble");
  function preloadLateStyle(stylesheet) {
    if (0 === stylesheet.state) {
      stylesheet.state = 1;
      var props = stylesheet.props;
      pushLinkImpl(stylesheetFlushingQueue, {
        rel: "preload",
        as: "style",
        href: stylesheet.props.href,
        crossOrigin: props.crossOrigin,
        fetchPriority: props.fetchPriority,
        integrity: props.integrity,
        media: props.media,
        hrefLang: props.hrefLang,
        referrerPolicy: props.referrerPolicy
      });
      for (stylesheet = 0; stylesheet < stylesheetFlushingQueue.length; stylesheet++)
        writeChunk(this, stylesheetFlushingQueue[stylesheet]);
      stylesheetFlushingQueue.length = 0;
    }
  }
  __name(preloadLateStyle, "preloadLateStyle");
  function preloadLateStyles(styleQueue) {
    styleQueue.sheets.forEach(preloadLateStyle, this);
    styleQueue.sheets.clear();
  }
  __name(preloadLateStyles, "preloadLateStyles");
  stringToPrecomputedChunk('<link rel="expect" href="#');
  stringToPrecomputedChunk('" blocking="render"/>');
  var completedShellIdAttributeStart = stringToPrecomputedChunk(' id="');
  function pushCompletedShellIdAttribute(target, resumableState) {
    0 === (resumableState.instructions & 32) && (resumableState.instructions |= 32, target.push(
      completedShellIdAttributeStart,
      stringToChunk(escapeTextForBrowser("_" + resumableState.idPrefix + "R_")),
      attributeEnd
    ));
  }
  __name(pushCompletedShellIdAttribute, "pushCompletedShellIdAttribute");
  var arrayFirstOpenBracket = stringToPrecomputedChunk("["), arraySubsequentOpenBracket = stringToPrecomputedChunk(",["), arrayInterstitial = stringToPrecomputedChunk(","), arrayCloseBracket = stringToPrecomputedChunk("]");
  function writeStyleResourceDependenciesInJS(destination, hoistableState) {
    writeChunk(destination, arrayFirstOpenBracket);
    var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
    hoistableState.stylesheets.forEach(function(resource) {
      if (2 !== resource.state)
        if (3 === resource.state)
          writeChunk(destination, nextArrayOpenBrackChunk), writeChunk(
            destination,
            stringToChunk(
              escapeJSObjectForInstructionScripts("" + resource.props.href)
            )
          ), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
        else {
          writeChunk(destination, nextArrayOpenBrackChunk);
          var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
          writeChunk(
            destination,
            stringToChunk(escapeJSObjectForInstructionScripts(coercedHref))
          );
          precedence = "" + precedence;
          writeChunk(destination, arrayInterstitial);
          writeChunk(
            destination,
            stringToChunk(escapeJSObjectForInstructionScripts(precedence))
          );
          for (var propKey in props)
            if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], null != precedence))
              switch (propKey) {
                case "href":
                case "rel":
                case "precedence":
                case "data-precedence":
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(399, "link"));
                default:
                  writeStyleResourceAttributeInJS(
                    destination,
                    propKey,
                    precedence
                  );
              }
          writeChunk(destination, arrayCloseBracket);
          nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
          resource.state = 3;
        }
    });
    writeChunk(destination, arrayCloseBracket);
  }
  __name(writeStyleResourceDependenciesInJS, "writeStyleResourceDependenciesInJS");
  function writeStyleResourceAttributeInJS(destination, name, value) {
    var attributeName = name.toLowerCase();
    switch (typeof value) {
      case "function":
      case "symbol":
        return;
    }
    switch (name) {
      case "innerHTML":
      case "dangerouslySetInnerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "style":
      case "ref":
        return;
      case "className":
        attributeName = "class";
        name = "" + value;
        break;
      case "hidden":
        if (false === value) return;
        name = "";
        break;
      case "src":
      case "href":
        value = sanitizeURL(value);
        name = "" + value;
        break;
      default:
        if (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1]) || !isAttributeNameSafe(name))
          return;
        name = "" + value;
    }
    writeChunk(destination, arrayInterstitial);
    writeChunk(
      destination,
      stringToChunk(escapeJSObjectForInstructionScripts(attributeName))
    );
    writeChunk(destination, arrayInterstitial);
    writeChunk(
      destination,
      stringToChunk(escapeJSObjectForInstructionScripts(name))
    );
  }
  __name(writeStyleResourceAttributeInJS, "writeStyleResourceAttributeInJS");
  function createHoistableState() {
    return { styles: /* @__PURE__ */ new Set(), stylesheets: /* @__PURE__ */ new Set(), suspenseyImages: false };
  }
  __name(createHoistableState, "createHoistableState");
  function prefetchDNS(href) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if ("string" === typeof href && href) {
        if (!resumableState.dnsResources.hasOwnProperty(href)) {
          resumableState.dnsResources[href] = null;
          resumableState = renderState.headers;
          var header, JSCompiler_temp;
          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
            JSCompiler_temp = (header = "<" + ("" + href).replace(
              regexForHrefInLinkHeaderURLContext,
              escapeHrefForLinkHeaderURLContextReplacer
            ) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
          JSCompiler_temp ? (renderState.resets.dns[href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.D(href);
  }
  __name(prefetchDNS, "prefetchDNS");
  function preconnect(href, crossOrigin) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if ("string" === typeof href && href) {
        var bucket = "use-credentials" === crossOrigin ? "credentials" : "string" === typeof crossOrigin ? "anonymous" : "default";
        if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
          resumableState.connectResources[bucket][href] = null;
          resumableState = renderState.headers;
          var header, JSCompiler_temp;
          if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
            JSCompiler_temp = "<" + ("" + href).replace(
              regexForHrefInLinkHeaderURLContext,
              escapeHrefForLinkHeaderURLContextReplacer
            ) + ">; rel=preconnect";
            if ("string" === typeof crossOrigin) {
              var escapedCrossOrigin = ("" + crossOrigin).replace(
                regexForLinkHeaderQuotedParamValueContext,
                escapeStringForLinkHeaderQuotedParamValueContextReplacer
              );
              JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
            }
            JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
          }
          JSCompiler_temp ? (renderState.resets.connect[bucket][href] = null, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
            rel: "preconnect",
            href,
            crossOrigin
          }), renderState.preconnects.add(bucket));
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.C(href, crossOrigin);
  }
  __name(preconnect, "preconnect");
  function preload(href, as, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (as && href) {
        switch (as) {
          case "image":
            if (options) {
              var imageSrcSet = options.imageSrcSet;
              var imageSizes = options.imageSizes;
              var fetchPriority = options.fetchPriority;
            }
            var key = imageSrcSet ? imageSrcSet + "\n" + (imageSizes || "") : href;
            if (resumableState.imageResources.hasOwnProperty(key)) return;
            resumableState.imageResources[key] = PRELOAD_NO_CREDS;
            resumableState = renderState.headers;
            var header;
            resumableState && 0 < resumableState.remainingCapacity && "string" !== typeof imageSrcSet && "high" === fetchPriority && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(
              resumableState,
              assign(
                { rel: "preload", href: imageSrcSet ? void 0 : href, as },
                options
              )
            ), "high" === fetchPriority ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
            break;
          case "style":
            if (resumableState.styleResources.hasOwnProperty(href)) return;
            imageSrcSet = [];
            pushLinkImpl(
              imageSrcSet,
              assign({ rel: "preload", href, as }, options)
            );
            resumableState.styleResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            renderState.preloads.stylesheets.set(href, imageSrcSet);
            renderState.bulkPreloads.add(imageSrcSet);
            break;
          case "script":
            if (resumableState.scriptResources.hasOwnProperty(href)) return;
            imageSrcSet = [];
            renderState.preloads.scripts.set(href, imageSrcSet);
            renderState.bulkPreloads.add(imageSrcSet);
            pushLinkImpl(
              imageSrcSet,
              assign({ rel: "preload", href, as }, options)
            );
            resumableState.scriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            break;
          default:
            if (resumableState.unknownResources.hasOwnProperty(as)) {
              if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                return;
            } else
              imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
            imageSrcSet[href] = PRELOAD_NO_CREDS;
            if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && "font" === as && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
              renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
            else
              switch (resumableState = [], href = assign({ rel: "preload", href, as }, options), pushLinkImpl(resumableState, href), as) {
                case "font":
                  renderState.fontPreloads.add(resumableState);
                  break;
                default:
                  renderState.bulkPreloads.add(resumableState);
              }
        }
        enqueueFlush(request);
      }
    } else previousDispatcher.L(href, as, options);
  }
  __name(preload, "preload");
  function preloadModule(href, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (href) {
        var as = options && "string" === typeof options.as ? options.as : "script";
        switch (as) {
          case "script":
            if (resumableState.moduleScriptResources.hasOwnProperty(href)) return;
            as = [];
            resumableState.moduleScriptResources[href] = !options || "string" !== typeof options.crossOrigin && "string" !== typeof options.integrity ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
            renderState.preloads.moduleScripts.set(href, as);
            break;
          default:
            if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
              var resources = resumableState.unknownResources[as];
              if (resources.hasOwnProperty(href)) return;
            } else
              resources = {}, resumableState.moduleUnknownResources[as] = resources;
            as = [];
            resources[href] = PRELOAD_NO_CREDS;
        }
        pushLinkImpl(as, assign({ rel: "modulepreload", href }, options));
        renderState.bulkPreloads.add(as);
        enqueueFlush(request);
      }
    } else previousDispatcher.m(href, options);
  }
  __name(preloadModule, "preloadModule");
  function preinitStyle(href, precedence, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (href) {
        precedence = precedence || "default";
        var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : void 0;
        null !== resourceState && (resumableState.styleResources[href] = null, styleQueue || (styleQueue = {
          precedence: stringToChunk(escapeTextForBrowser(precedence)),
          rules: [],
          hrefs: [],
          sheets: /* @__PURE__ */ new Map()
        }, renderState.styles.set(precedence, styleQueue)), precedence = {
          state: 0,
          props: assign(
            { rel: "stylesheet", href, "data-precedence": precedence },
            options
          )
        }, resourceState && (2 === resourceState.length && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = 1), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
      }
    } else previousDispatcher.S(href, precedence, options);
  }
  __name(preinitStyle, "preinitStyle");
  function preinitScript(src, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (src) {
        var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : void 0;
        null !== resourceState && (resumableState.scriptResources[src] = null, options = assign({ src, async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
      }
    } else previousDispatcher.X(src, options);
  }
  __name(preinitScript, "preinitScript");
  function preinitModuleScript(src, options) {
    var request = currentRequest ? currentRequest : null;
    if (request) {
      var resumableState = request.resumableState, renderState = request.renderState;
      if (src) {
        var resourceState = resumableState.moduleScriptResources.hasOwnProperty(
          src
        ) ? resumableState.moduleScriptResources[src] : void 0;
        null !== resourceState && (resumableState.moduleScriptResources[src] = null, options = assign({ src, type: "module", async: true }, options), resourceState && (2 === resourceState.length && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
      }
    } else previousDispatcher.M(src, options);
  }
  __name(preinitModuleScript, "preinitModuleScript");
  function adoptPreloadCredentials(target, preloadState) {
    null == target.crossOrigin && (target.crossOrigin = preloadState[0]);
    null == target.integrity && (target.integrity = preloadState[1]);
  }
  __name(adoptPreloadCredentials, "adoptPreloadCredentials");
  function getPreloadAsHeader(href, as, params) {
    href = ("" + href).replace(
      regexForHrefInLinkHeaderURLContext,
      escapeHrefForLinkHeaderURLContextReplacer
    );
    as = ("" + as).replace(
      regexForLinkHeaderQuotedParamValueContext,
      escapeStringForLinkHeaderQuotedParamValueContextReplacer
    );
    as = "<" + href + '>; rel=preload; as="' + as + '"';
    for (var paramName in params)
      hasOwnProperty.call(params, paramName) && (href = params[paramName], "string" === typeof href && (as += "; " + paramName.toLowerCase() + '="' + ("" + href).replace(
        regexForLinkHeaderQuotedParamValueContext,
        escapeStringForLinkHeaderQuotedParamValueContextReplacer
      ) + '"'));
    return as;
  }
  __name(getPreloadAsHeader, "getPreloadAsHeader");
  var regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
  function escapeHrefForLinkHeaderURLContextReplacer(match) {
    switch (match) {
      case "<":
        return "%3C";
      case ">":
        return "%3E";
      case "\n":
        return "%0A";
      case "\r":
        return "%0D";
      default:
        throw Error(
          "escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
        );
    }
  }
  __name(escapeHrefForLinkHeaderURLContextReplacer, "escapeHrefForLinkHeaderURLContextReplacer");
  var regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
  function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
    switch (match) {
      case '"':
        return "%22";
      case "'":
        return "%27";
      case ";":
        return "%3B";
      case ",":
        return "%2C";
      case "\n":
        return "%0A";
      case "\r":
        return "%0D";
      default:
        throw Error(
          "escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React"
        );
    }
  }
  __name(escapeStringForLinkHeaderQuotedParamValueContextReplacer, "escapeStringForLinkHeaderQuotedParamValueContextReplacer");
  function hoistStyleQueueDependency(styleQueue) {
    this.styles.add(styleQueue);
  }
  __name(hoistStyleQueueDependency, "hoistStyleQueueDependency");
  function hoistStylesheetDependency(stylesheet) {
    this.stylesheets.add(stylesheet);
  }
  __name(hoistStylesheetDependency, "hoistStylesheetDependency");
  function hoistHoistables(parentState, childState) {
    childState.styles.forEach(hoistStyleQueueDependency, parentState);
    childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
    childState.suspenseyImages && (parentState.suspenseyImages = true);
  }
  __name(hoistHoistables, "hoistHoistables");
  function hasSuspenseyContent(hoistableState) {
    return 0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages;
  }
  __name(hasSuspenseyContent, "hasSuspenseyContent");
  var bind = Function.prototype.bind, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return type.displayName || "Context";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x) {
          }
      }
    return null;
  }
  __name(getComponentNameFromType, "getComponentNameFromType");
  var emptyContextObject = {}, currentActiveSnapshot = null;
  function popToNearestCommonAncestor(prev, next) {
    if (prev !== next) {
      prev.context._currentValue = prev.parentValue;
      prev = prev.parent;
      var parentNext = next.parent;
      if (null === prev) {
        if (null !== parentNext) throw Error(formatProdErrorMessage(401));
      } else {
        if (null === parentNext) throw Error(formatProdErrorMessage(401));
        popToNearestCommonAncestor(prev, parentNext);
      }
      next.context._currentValue = next.value;
    }
  }
  __name(popToNearestCommonAncestor, "popToNearestCommonAncestor");
  function popAllPrevious(prev) {
    prev.context._currentValue = prev.parentValue;
    prev = prev.parent;
    null !== prev && popAllPrevious(prev);
  }
  __name(popAllPrevious, "popAllPrevious");
  function pushAllNext(next) {
    var parentNext = next.parent;
    null !== parentNext && pushAllNext(parentNext);
    next.context._currentValue = next.value;
  }
  __name(pushAllNext, "pushAllNext");
  function popPreviousToCommonLevel(prev, next) {
    prev.context._currentValue = prev.parentValue;
    prev = prev.parent;
    if (null === prev) throw Error(formatProdErrorMessage(402));
    prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
  }
  __name(popPreviousToCommonLevel, "popPreviousToCommonLevel");
  function popNextToCommonLevel(prev, next) {
    var parentNext = next.parent;
    if (null === parentNext) throw Error(formatProdErrorMessage(402));
    prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
    next.context._currentValue = next.value;
  }
  __name(popNextToCommonLevel, "popNextToCommonLevel");
  function switchContext(newSnapshot) {
    var prev = currentActiveSnapshot;
    prev !== newSnapshot && (null === prev ? pushAllNext(newSnapshot) : null === newSnapshot ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
  }
  __name(switchContext, "switchContext");
  var classComponentUpdater = {
    enqueueSetState: /* @__PURE__ */ __name(function(inst, payload) {
      inst = inst._reactInternals;
      null !== inst.queue && inst.queue.push(payload);
    }, "enqueueSetState"),
    enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload) {
      inst = inst._reactInternals;
      inst.replace = true;
      inst.queue = [payload];
    }, "enqueueReplaceState"),
    enqueueForceUpdate: /* @__PURE__ */ __name(function() {
    }, "enqueueForceUpdate")
  }, emptyTreeContext = { id: 1, overflow: "" };
  function pushTreeContext(baseContext, totalChildren, index2) {
    var baseIdWithLeadingBit = baseContext.id;
    baseContext = baseContext.overflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index2 += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      return {
        id: 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit,
        overflow: length + baseContext
      };
    }
    return {
      id: 1 << length | index2 << baseLength | baseIdWithLeadingBit,
      overflow: baseContext
    };
  }
  __name(pushTreeContext, "pushTreeContext");
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log5 = Math.log, LN2 = Math.LN2;
  function clz32Fallback(x) {
    x >>>= 0;
    return 0 === x ? 32 : 31 - (log5(x) / LN2 | 0) | 0;
  }
  __name(clz32Fallback, "clz32Fallback");
  function noop2() {
  }
  __name(noop2, "noop");
  var SuspenseException = Error(formatProdErrorMessage(460));
  function trackUsedThenable(thenableState2, thenable, index2) {
    index2 = thenableState2[index2];
    void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop2, noop2), thenable = index2);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        "string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenableState2 = thenable, thenableState2.status = "pending", thenableState2.then(
          function(fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function(error5) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error5;
            }
          }
        ));
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  __name(trackUsedThenable, "trackUsedThenable");
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  __name(getSuspendedThenable, "getSuspendedThenable");
  function is2(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  __name(is2, "is");
  var objectIs = "function" === typeof Object.is ? Object.is : is2, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0;
  function resolveCurrentlyRenderingComponent() {
    if (null === currentlyRenderingComponent)
      throw Error(formatProdErrorMessage(321));
    return currentlyRenderingComponent;
  }
  __name(resolveCurrentlyRenderingComponent, "resolveCurrentlyRenderingComponent");
  function createHook() {
    if (0 < numberOfReRenders) throw Error(formatProdErrorMessage(312));
    return { memoizedState: null, queue: null, next: null };
  }
  __name(createHook, "createHook");
  function createWorkInProgressHook() {
    null === workInProgressHook ? null === firstWorkInProgressHook ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : null === workInProgressHook.next ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
    return workInProgressHook;
  }
  __name(createWorkInProgressHook, "createWorkInProgressHook");
  function getThenableStateAfterSuspending() {
    var state = thenableState;
    thenableState = null;
    return state;
  }
  __name(getThenableStateAfterSuspending, "getThenableStateAfterSuspending");
  function resetHooksState() {
    currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
    didScheduleRenderPhaseUpdate = false;
    firstWorkInProgressHook = null;
    numberOfReRenders = 0;
    workInProgressHook = renderPhaseUpdates = null;
  }
  __name(resetHooksState, "resetHooksState");
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  __name(basicStateReducer, "basicStateReducer");
  function useReducer(reducer, initialArg, init) {
    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
    workInProgressHook = createWorkInProgressHook();
    if (isReRender) {
      var queue = workInProgressHook.queue;
      initialArg = queue.dispatch;
      if (null !== renderPhaseUpdates && (init = renderPhaseUpdates.get(queue), void 0 !== init)) {
        renderPhaseUpdates.delete(queue);
        queue = workInProgressHook.memoizedState;
        do
          queue = reducer(queue, init.action), init = init.next;
        while (null !== init);
        workInProgressHook.memoizedState = queue;
        return [queue, initialArg];
      }
      return [workInProgressHook.memoizedState, initialArg];
    }
    reducer = reducer === basicStateReducer ? "function" === typeof initialArg ? initialArg() : initialArg : void 0 !== init ? init(initialArg) : initialArg;
    workInProgressHook.memoizedState = reducer;
    reducer = workInProgressHook.queue = { last: null, dispatch: null };
    reducer = reducer.dispatch = dispatchAction.bind(
      null,
      currentlyRenderingComponent,
      reducer
    );
    return [workInProgressHook.memoizedState, reducer];
  }
  __name(useReducer, "useReducer");
  function useMemo(nextCreate, deps) {
    currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
    workInProgressHook = createWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    if (null !== workInProgressHook) {
      var prevState = workInProgressHook.memoizedState;
      if (null !== prevState && null !== deps) {
        var prevDeps = prevState[1];
        a: if (null === prevDeps) prevDeps = false;
        else {
          for (var i2 = 0; i2 < prevDeps.length && i2 < deps.length; i2++)
            if (!objectIs(deps[i2], prevDeps[i2])) {
              prevDeps = false;
              break a;
            }
          prevDeps = true;
        }
        if (prevDeps) return prevState[0];
      }
    }
    nextCreate = nextCreate();
    workInProgressHook.memoizedState = [nextCreate, deps];
    return nextCreate;
  }
  __name(useMemo, "useMemo");
  function dispatchAction(componentIdentity, queue, action) {
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    if (componentIdentity === currentlyRenderingComponent)
      if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, null === renderPhaseUpdates && (renderPhaseUpdates = /* @__PURE__ */ new Map()), action = renderPhaseUpdates.get(queue), void 0 === action)
        renderPhaseUpdates.set(queue, componentIdentity);
      else {
        for (queue = action; null !== queue.next; ) queue = queue.next;
        queue.next = componentIdentity;
      }
  }
  __name(dispatchAction, "dispatchAction");
  function throwOnUseEffectEventCall() {
    throw Error(formatProdErrorMessage(440));
  }
  __name(throwOnUseEffectEventCall, "throwOnUseEffectEventCall");
  function unsupportedStartTransition() {
    throw Error(formatProdErrorMessage(394));
  }
  __name(unsupportedStartTransition, "unsupportedStartTransition");
  function unsupportedSetOptimisticState() {
    throw Error(formatProdErrorMessage(479));
  }
  __name(unsupportedSetOptimisticState, "unsupportedSetOptimisticState");
  function useActionState(action, initialState, permalink) {
    resolveCurrentlyRenderingComponent();
    var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
    if ("function" === typeof action.$$FORM_ACTION) {
      var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
      request = request.formState;
      var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
      if (null !== request && "function" === typeof isSignatureEqual) {
        var postbackKey = request[1];
        isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
          JSON.stringify([componentKeyPath, null, actionStateHookIndex]),
          0
        ), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
      }
      var boundAction = action.bind(null, initialState);
      action = /* @__PURE__ */ __name(function(payload) {
        boundAction(payload);
      }, "action");
      "function" === typeof boundAction.$$FORM_ACTION && (action.$$FORM_ACTION = function(prefix2) {
        prefix2 = boundAction.$$FORM_ACTION(prefix2);
        void 0 !== permalink && (permalink += "", prefix2.action = permalink);
        var formData = prefix2.data;
        formData && (null === nextPostbackStateKey && (nextPostbackStateKey = void 0 !== permalink ? "p" + permalink : "k" + murmurhash3_32_gc(
          JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]),
          0
        )), formData.append("$ACTION_KEY", nextPostbackStateKey));
        return prefix2;
      });
      return [initialState, action, false];
    }
    var boundAction$22 = action.bind(null, initialState);
    return [
      initialState,
      function(payload) {
        boundAction$22(payload);
      },
      false
    ];
  }
  __name(useActionState, "useActionState");
  function unwrapThenable(thenable) {
    var index2 = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    return trackUsedThenable(thenableState, thenable, index2);
  }
  __name(unwrapThenable, "unwrapThenable");
  function unsupportedRefresh() {
    throw Error(formatProdErrorMessage(393));
  }
  __name(unsupportedRefresh, "unsupportedRefresh");
  var HooksDispatcher = {
    readContext: /* @__PURE__ */ __name(function(context3) {
      return context3._currentValue;
    }, "readContext"),
    use: /* @__PURE__ */ __name(function(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return unwrapThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return usable._currentValue;
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }, "use"),
    useContext: /* @__PURE__ */ __name(function(context3) {
      resolveCurrentlyRenderingComponent();
      return context3._currentValue;
    }, "useContext"),
    useMemo,
    useReducer,
    useRef: /* @__PURE__ */ __name(function(initialValue) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      var previousRef = workInProgressHook.memoizedState;
      return null === previousRef ? (initialValue = { current: initialValue }, workInProgressHook.memoizedState = initialValue) : previousRef;
    }, "useRef"),
    useState: /* @__PURE__ */ __name(function(initialState) {
      return useReducer(basicStateReducer, initialState);
    }, "useState"),
    useInsertionEffect: noop2,
    useLayoutEffect: noop2,
    useCallback: /* @__PURE__ */ __name(function(callback, deps) {
      return useMemo(function() {
        return callback;
      }, deps);
    }, "useCallback"),
    useImperativeHandle: noop2,
    useEffect: noop2,
    useDebugValue: noop2,
    useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
      resolveCurrentlyRenderingComponent();
      return void 0 !== initialValue ? initialValue : value;
    }, "useDeferredValue"),
    useTransition: /* @__PURE__ */ __name(function() {
      resolveCurrentlyRenderingComponent();
      return [false, unsupportedStartTransition];
    }, "useTransition"),
    useId: /* @__PURE__ */ __name(function() {
      var JSCompiler_inline_result = currentlyRenderingTask.treeContext;
      var overflow = JSCompiler_inline_result.overflow;
      JSCompiler_inline_result = JSCompiler_inline_result.id;
      JSCompiler_inline_result = (JSCompiler_inline_result & ~(1 << 32 - clz32(JSCompiler_inline_result) - 1)).toString(32) + overflow;
      var resumableState = currentResumableState;
      if (null === resumableState) throw Error(formatProdErrorMessage(404));
      overflow = localIdCounter++;
      JSCompiler_inline_result = "_" + resumableState.idPrefix + "R_" + JSCompiler_inline_result;
      0 < overflow && (JSCompiler_inline_result += "H" + overflow.toString(32));
      return JSCompiler_inline_result + "_";
    }, "useId"),
    useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {
      if (void 0 === getServerSnapshot)
        throw Error(formatProdErrorMessage(407));
      return getServerSnapshot();
    }, "useSyncExternalStore"),
    useOptimistic: /* @__PURE__ */ __name(function(passthrough) {
      resolveCurrentlyRenderingComponent();
      return [passthrough, unsupportedSetOptimisticState];
    }, "useOptimistic"),
    useActionState,
    useFormState: useActionState,
    useHostTransitionStatus: /* @__PURE__ */ __name(function() {
      resolveCurrentlyRenderingComponent();
      return sharedNotPendingObject;
    }, "useHostTransitionStatus"),
    useMemoCache: /* @__PURE__ */ __name(function(size) {
      for (var data = Array(size), i2 = 0; i2 < size; i2++)
        data[i2] = REACT_MEMO_CACHE_SENTINEL;
      return data;
    }, "useMemoCache"),
    useCacheRefresh: /* @__PURE__ */ __name(function() {
      return unsupportedRefresh;
    }, "useCacheRefresh"),
    useEffectEvent: /* @__PURE__ */ __name(function() {
      return throwOnUseEffectEventCall;
    }, "useEffectEvent")
  }, currentResumableState = null, DefaultAsyncDispatcher = {
    getCacheForType: /* @__PURE__ */ __name(function() {
      throw Error(formatProdErrorMessage(248));
    }, "getCacheForType"),
    cacheSignal: /* @__PURE__ */ __name(function() {
      throw Error(formatProdErrorMessage(248));
    }, "cacheSignal")
  }, prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix)
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return "\n" + prefix + name + suffix;
  }
  __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
  var reentry = false;
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
          try {
            if (construct) {
              var Fake = /* @__PURE__ */ __name(function() {
                throw Error();
              }, "Fake");
              Object.defineProperty(Fake.prototype, "props", {
                set: /* @__PURE__ */ __name(function() {
                  throw Error();
                }, "set")
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$24) {
                  control = x$24;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$25) {
                control = x$25;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
              });
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack)
              return [sample.stack, control.stack];
          }
          return [null, null];
        }, "DetermineComponentFrameRoot")
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name"
      );
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
          RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        ); )
          namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
            namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
              do
                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                  var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                  fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                  return frame;
                }
              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
            }
            break;
          }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  __name(describeNativeComponentFrame, "describeNativeComponentFrame");
  function describeComponentStackByType(type) {
    if ("string" === typeof type) return describeBuiltInComponentFrame(type);
    if ("function" === typeof type)
      return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
    if ("object" === typeof type && null !== type) {
      switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          return describeNativeComponentFrame(type.render, false);
        case REACT_MEMO_TYPE:
          return describeNativeComponentFrame(type.type, false);
        case REACT_LAZY_TYPE:
          var lazyComponent = type, payload = lazyComponent._payload;
          lazyComponent = lazyComponent._init;
          try {
            type = lazyComponent(payload);
          } catch (x) {
            return describeBuiltInComponentFrame("Lazy");
          }
          return describeComponentStackByType(type);
      }
      if ("string" === typeof type.name) {
        a: {
          payload = type.name;
          lazyComponent = type.env;
          var location = type.debugLocation;
          if (null != location && (type = Error.prepareStackTrace, Error.prepareStackTrace = void 0, location = location.stack, Error.prepareStackTrace = type, location.startsWith("Error: react-stack-top-frame\n") && (location = location.slice(29)), type = location.indexOf("\n"), -1 !== type && (location = location.slice(type + 1)), type = location.indexOf("react_stack_bottom_frame"), -1 !== type && (type = location.lastIndexOf("\n", type)), type = -1 !== type ? location = location.slice(0, type) : "", location = type.lastIndexOf("\n"), type = -1 === location ? type : type.slice(location + 1), -1 !== type.indexOf(payload))) {
            payload = "\n" + type;
            break a;
          }
          payload = describeBuiltInComponentFrame(
            payload + (lazyComponent ? " [" + lazyComponent + "]" : "")
          );
        }
        return payload;
      }
    }
    switch (type) {
      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame("SuspenseList");
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame("Suspense");
    }
    return "";
  }
  __name(describeComponentStackByType, "describeComponentStackByType");
  function isEligibleForOutlining(request, boundary) {
    return (500 < boundary.byteSize || hasSuspenseyContent(boundary.contentState)) && null === boundary.contentPreamble;
  }
  __name(isEligibleForOutlining, "isEligibleForOutlining");
  function defaultErrorHandler(error5) {
    if ("object" === typeof error5 && null !== error5 && "string" === typeof error5.environmentName) {
      var JSCompiler_inline_result = error5.environmentName;
      error5 = [error5].slice(0);
      "string" === typeof error5[0] ? error5.splice(
        0,
        1,
        "%c%s%c " + error5[0],
        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
        " " + JSCompiler_inline_result + " ",
        ""
      ) : error5.splice(
        0,
        0,
        "%c%s%c",
        "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
        " " + JSCompiler_inline_result + " ",
        ""
      );
      error5.unshift(console);
      JSCompiler_inline_result = bind.apply(console.error, error5);
      JSCompiler_inline_result();
    } else console.error(error5);
    return null;
  }
  __name(defaultErrorHandler, "defaultErrorHandler");
  function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
    var abortSet = /* @__PURE__ */ new Set();
    this.destination = null;
    this.flushScheduled = false;
    this.resumableState = resumableState;
    this.renderState = renderState;
    this.rootFormatContext = rootFormatContext;
    this.progressiveChunkSize = void 0 === progressiveChunkSize ? 12800 : progressiveChunkSize;
    this.status = 10;
    this.fatalError = null;
    this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
    this.completedPreambleSegments = this.completedRootSegment = null;
    this.byteSize = 0;
    this.abortableTasks = abortSet;
    this.pingedTasks = [];
    this.clientRenderedBoundaries = [];
    this.completedBoundaries = [];
    this.partialBoundaries = [];
    this.trackedPostpones = null;
    this.onError = void 0 === onError ? defaultErrorHandler : onError;
    this.onPostpone = void 0 === onPostpone ? noop2 : onPostpone;
    this.onAllReady = void 0 === onAllReady ? noop2 : onAllReady;
    this.onShellReady = void 0 === onShellReady ? noop2 : onShellReady;
    this.onShellError = void 0 === onShellError ? noop2 : onShellError;
    this.onFatalError = void 0 === onFatalError ? noop2 : onFatalError;
    this.formState = void 0 === formState ? null : formState;
  }
  __name(RequestInstance, "RequestInstance");
  function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
    resumableState = new RequestInstance(
      resumableState,
      renderState,
      rootFormatContext,
      progressiveChunkSize,
      onError,
      onAllReady,
      onShellReady,
      onShellError,
      onFatalError,
      onPostpone,
      formState
    );
    renderState = createPendingSegment(
      resumableState,
      0,
      null,
      rootFormatContext,
      false,
      false
    );
    renderState.parentFlushed = true;
    children = createRenderTask(
      resumableState,
      null,
      children,
      -1,
      null,
      renderState,
      null,
      null,
      resumableState.abortableTasks,
      null,
      rootFormatContext,
      null,
      emptyTreeContext,
      null,
      null
    );
    pushComponentStack(children);
    resumableState.pingedTasks.push(children);
    return resumableState;
  }
  __name(createRequest2, "createRequest");
  function createPrerenderRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
    children = createRequest2(
      children,
      resumableState,
      renderState,
      rootFormatContext,
      progressiveChunkSize,
      onError,
      onAllReady,
      onShellReady,
      onShellError,
      onFatalError,
      onPostpone,
      void 0
    );
    children.trackedPostpones = {
      workingMap: /* @__PURE__ */ new Map(),
      rootNodes: [],
      rootSlots: null
    };
    return children;
  }
  __name(createPrerenderRequest, "createPrerenderRequest");
  function resumeRequest(children, postponedState, renderState, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
    renderState = new RequestInstance(
      postponedState.resumableState,
      renderState,
      postponedState.rootFormatContext,
      postponedState.progressiveChunkSize,
      onError,
      onAllReady,
      onShellReady,
      onShellError,
      onFatalError,
      onPostpone,
      null
    );
    renderState.nextSegmentId = postponedState.nextSegmentId;
    if ("number" === typeof postponedState.replaySlots)
      return onError = createPendingSegment(
        renderState,
        0,
        null,
        postponedState.rootFormatContext,
        false,
        false
      ), onError.parentFlushed = true, children = createRenderTask(
        renderState,
        null,
        children,
        -1,
        null,
        onError,
        null,
        null,
        renderState.abortableTasks,
        null,
        postponedState.rootFormatContext,
        null,
        emptyTreeContext,
        null,
        null
      ), pushComponentStack(children), renderState.pingedTasks.push(children), renderState;
    children = createReplayTask(
      renderState,
      null,
      {
        nodes: postponedState.replayNodes,
        slots: postponedState.replaySlots,
        pendingTasks: 0
      },
      children,
      -1,
      null,
      null,
      renderState.abortableTasks,
      null,
      postponedState.rootFormatContext,
      null,
      emptyTreeContext,
      null,
      null
    );
    pushComponentStack(children);
    renderState.pingedTasks.push(children);
    return renderState;
  }
  __name(resumeRequest, "resumeRequest");
  function resumeAndPrerenderRequest(children, postponedState, renderState, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone) {
    children = resumeRequest(
      children,
      postponedState,
      renderState,
      onError,
      onAllReady,
      onShellReady,
      onShellError,
      onFatalError,
      onPostpone
    );
    children.trackedPostpones = {
      workingMap: /* @__PURE__ */ new Map(),
      rootNodes: [],
      rootSlots: null
    };
    return children;
  }
  __name(resumeAndPrerenderRequest, "resumeAndPrerenderRequest");
  var currentRequest = null;
  function pingTask(request, task) {
    request.pingedTasks.push(task);
    1 === request.pingedTasks.length && (request.flushScheduled = null !== request.destination, null !== request.trackedPostpones || 10 === request.status ? scheduleMicrotask(function() {
      return performWork(request);
    }) : scheduleWork(function() {
      return performWork(request);
    }));
  }
  __name(pingTask, "pingTask");
  function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
    fallbackAbortableTasks = {
      status: 0,
      rootSegmentID: -1,
      parentFlushed: false,
      pendingTasks: 0,
      row,
      completedSegments: [],
      byteSize: 0,
      fallbackAbortableTasks,
      errorDigest: null,
      contentState: createHoistableState(),
      fallbackState: createHoistableState(),
      contentPreamble,
      fallbackPreamble,
      trackedContentKeyPath: null,
      trackedFallbackNode: null
    };
    null !== row && (row.pendingTasks++, contentPreamble = row.boundaries, null !== contentPreamble && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, null !== request && hoistHoistables(fallbackAbortableTasks.contentState, request));
    return fallbackAbortableTasks;
  }
  __name(createSuspenseBoundary, "createSuspenseBoundary");
  function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context3, treeContext, row, componentStack) {
    request.allPendingTasks++;
    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
    null !== row && row.pendingTasks++;
    var task = {
      replay: null,
      node,
      childIndex,
      ping: /* @__PURE__ */ __name(function() {
        return pingTask(request, task);
      }, "ping"),
      blockedBoundary,
      blockedSegment,
      blockedPreamble,
      hoistableState,
      abortSet,
      keyPath,
      formatContext,
      context: context3,
      treeContext,
      row,
      componentStack,
      thenableState: thenableState2
    };
    abortSet.add(task);
    return task;
  }
  __name(createRenderTask, "createRenderTask");
  function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context3, treeContext, row, componentStack) {
    request.allPendingTasks++;
    null === blockedBoundary ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
    null !== row && row.pendingTasks++;
    replay.pendingTasks++;
    var task = {
      replay,
      node,
      childIndex,
      ping: /* @__PURE__ */ __name(function() {
        return pingTask(request, task);
      }, "ping"),
      blockedBoundary,
      blockedSegment: null,
      blockedPreamble: null,
      hoistableState,
      abortSet,
      keyPath,
      formatContext,
      context: context3,
      treeContext,
      row,
      componentStack,
      thenableState: thenableState2
    };
    abortSet.add(task);
    return task;
  }
  __name(createReplayTask, "createReplayTask");
  function createPendingSegment(request, index2, boundary, parentFormatContext, lastPushedText, textEmbedded) {
    return {
      status: 0,
      parentFlushed: false,
      id: -1,
      index: index2,
      chunks: [],
      children: [],
      preambleChildren: [],
      parentFormatContext,
      boundary,
      lastPushedText,
      textEmbedded
    };
  }
  __name(createPendingSegment, "createPendingSegment");
  function pushComponentStack(task) {
    var node = task.node;
    if ("object" === typeof node && null !== node)
      switch (node.$$typeof) {
        case REACT_ELEMENT_TYPE:
          task.componentStack = { parent: task.componentStack, type: node.type };
      }
  }
  __name(pushComponentStack, "pushComponentStack");
  function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
    return null === componentStack ? null : { parent: componentStack.parent, type: "Suspense Fallback" };
  }
  __name(replaceSuspenseComponentStackWithSuspenseFallbackStack, "replaceSuspenseComponentStackWithSuspenseFallbackStack");
  function getThrownInfo(node$jscomp$0) {
    var errorInfo = {};
    node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
      configurable: true,
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        try {
          var info5 = "", node = node$jscomp$0;
          do
            info5 += describeComponentStackByType(node.type), node = node.parent;
          while (node);
          var JSCompiler_inline_result = info5;
        } catch (x) {
          JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
        }
        Object.defineProperty(errorInfo, "componentStack", {
          value: JSCompiler_inline_result
        });
        return JSCompiler_inline_result;
      }, "get")
    });
    return errorInfo;
  }
  __name(getThrownInfo, "getThrownInfo");
  function logRecoverableError(request, error5, errorInfo) {
    request = request.onError;
    error5 = request(error5, errorInfo);
    if (null == error5 || "string" === typeof error5) return error5;
  }
  __name(logRecoverableError, "logRecoverableError");
  function fatalError(request, error5) {
    var onShellError = request.onShellError, onFatalError = request.onFatalError;
    onShellError(error5);
    onFatalError(error5);
    null !== request.destination ? (request.status = 14, closeWithError(request.destination, error5)) : (request.status = 13, request.fatalError = error5);
  }
  __name(fatalError, "fatalError");
  function finishSuspenseListRow(request, row) {
    unblockSuspenseListRow(request, row.next, row.hoistables);
  }
  __name(finishSuspenseListRow, "finishSuspenseListRow");
  function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
    for (; null !== unblockedRow; ) {
      null !== inheritedHoistables && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
      var unblockedBoundaries = unblockedRow.boundaries;
      if (null !== unblockedBoundaries) {
        unblockedRow.boundaries = null;
        for (var i2 = 0; i2 < unblockedBoundaries.length; i2++) {
          var unblockedBoundary = unblockedBoundaries[i2];
          null !== inheritedHoistables && hoistHoistables(unblockedBoundary.contentState, inheritedHoistables);
          finishedTask(request, unblockedBoundary, null, null);
        }
      }
      unblockedRow.pendingTasks--;
      if (0 < unblockedRow.pendingTasks) break;
      inheritedHoistables = unblockedRow.hoistables;
      unblockedRow = unblockedRow.next;
    }
  }
  __name(unblockSuspenseListRow, "unblockSuspenseListRow");
  function tryToResolveTogetherRow(request, togetherRow) {
    var boundaries = togetherRow.boundaries;
    if (null !== boundaries && togetherRow.pendingTasks === boundaries.length) {
      for (var allCompleteAndInlinable = true, i2 = 0; i2 < boundaries.length; i2++) {
        var rowBoundary = boundaries[i2];
        if (1 !== rowBoundary.pendingTasks || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
          allCompleteAndInlinable = false;
          break;
        }
      }
      allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
    }
  }
  __name(tryToResolveTogetherRow, "tryToResolveTogetherRow");
  function createSuspenseListRow(previousRow) {
    var newRow = {
      pendingTasks: 1,
      boundaries: null,
      hoistables: createHoistableState(),
      inheritedHoistables: null,
      together: false,
      next: null
    };
    null !== previousRow && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
    return newRow;
  }
  __name(createSuspenseListRow, "createSuspenseListRow");
  function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
    var prevKeyPath = task.keyPath, prevTreeContext = task.treeContext, prevRow = task.row;
    task.keyPath = keyPath;
    keyPath = rows.length;
    var previousSuspenseListRow = null;
    if (null !== task.replay) {
      var resumeSlots = task.replay.slots;
      if (null !== resumeSlots && "object" === typeof resumeSlots)
        for (var n2 = 0; n2 < keyPath; n2++) {
          var i2 = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? n2 : keyPath - 1 - n2, node = rows[i2];
          task.row = previousSuspenseListRow = createSuspenseListRow(
            previousSuspenseListRow
          );
          task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
          var resumeSegmentID = resumeSlots[i2];
          "number" === typeof resumeSegmentID ? (resumeNode(request, task, resumeSegmentID, node, i2), delete resumeSlots[i2]) : renderNode(request, task, node, i2);
          0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
        }
      else
        for (resumeSlots = 0; resumeSlots < keyPath; resumeSlots++)
          n2 = "backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder ? resumeSlots : keyPath - 1 - resumeSlots, i2 = rows[n2], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n2), renderNode(request, task, i2, n2), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
    } else if ("backwards" !== revealOrder && "unstable_legacy-backwards" !== revealOrder)
      for (revealOrder = 0; revealOrder < keyPath; revealOrder++)
        resumeSlots = rows[revealOrder], task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(
          prevTreeContext,
          keyPath,
          revealOrder
        ), renderNode(request, task, resumeSlots, revealOrder), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
    else {
      revealOrder = task.blockedSegment;
      resumeSlots = revealOrder.children.length;
      n2 = revealOrder.chunks.length;
      for (i2 = keyPath - 1; 0 <= i2; i2--) {
        node = rows[i2];
        task.row = previousSuspenseListRow = createSuspenseListRow(
          previousSuspenseListRow
        );
        task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
        resumeSegmentID = createPendingSegment(
          request,
          n2,
          null,
          task.formatContext,
          0 === i2 ? revealOrder.lastPushedText : true,
          true
        );
        revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
        task.blockedSegment = resumeSegmentID;
        try {
          renderNode(request, task, node, i2), resumeSegmentID.lastPushedText && resumeSegmentID.textEmbedded && resumeSegmentID.chunks.push(textSeparator), resumeSegmentID.status = 1, finishedSegment(request, task.blockedBoundary, resumeSegmentID), 0 === --previousSuspenseListRow.pendingTasks && finishSuspenseListRow(request, previousSuspenseListRow);
        } catch (thrownValue) {
          throw resumeSegmentID.status = 12 === request.status ? 3 : 4, thrownValue;
        }
      }
      task.blockedSegment = revealOrder;
      revealOrder.lastPushedText = false;
    }
    null !== prevRow && null !== previousSuspenseListRow && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
    task.treeContext = prevTreeContext;
    task.row = prevRow;
    task.keyPath = prevKeyPath;
  }
  __name(renderSuspenseListRows, "renderSuspenseListRows");
  function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
    var prevThenableState = task.thenableState;
    task.thenableState = null;
    currentlyRenderingComponent = {};
    currentlyRenderingTask = task;
    currentlyRenderingRequest = request;
    currentlyRenderingKeyPath = keyPath;
    actionStateCounter = localIdCounter = 0;
    actionStateMatchingIndex = -1;
    thenableIndexCounter = 0;
    thenableState = prevThenableState;
    for (request = Component(props, secondArg); didScheduleRenderPhaseUpdate; )
      didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
    resetHooksState();
    return request;
  }
  __name(renderWithHooks, "renderWithHooks");
  function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
    var didEmitActionStateMarkers = false;
    if (0 !== actionStateCount && null !== request.formState) {
      var segment = task.blockedSegment;
      if (null !== segment) {
        didEmitActionStateMarkers = true;
        segment = segment.chunks;
        for (var i2 = 0; i2 < actionStateCount; i2++)
          i2 === actionStateMatchingIndex2 ? segment.push(formStateMarkerIsMatching) : segment.push(formStateMarkerIsNotMatching);
      }
    }
    actionStateCount = task.keyPath;
    task.keyPath = keyPath;
    hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
    task.keyPath = actionStateCount;
  }
  __name(finishFunctionComponent, "finishFunctionComponent");
  function renderElement2(request, task, keyPath, type, props, ref3) {
    if ("function" === typeof type)
      if (type.prototype && type.prototype.isReactComponent) {
        var newProps = props;
        if ("ref" in props) {
          newProps = {};
          for (var propName in props)
            "ref" !== propName && (newProps[propName] = props[propName]);
        }
        var defaultProps = type.defaultProps;
        if (defaultProps) {
          newProps === props && (newProps = assign({}, newProps, props));
          for (var propName$44 in defaultProps)
            void 0 === newProps[propName$44] && (newProps[propName$44] = defaultProps[propName$44]);
        }
        props = newProps;
        newProps = emptyContextObject;
        defaultProps = type.contextType;
        "object" === typeof defaultProps && null !== defaultProps && (newProps = defaultProps._currentValue);
        newProps = new type(props, newProps);
        var initialState = void 0 !== newProps.state ? newProps.state : null;
        newProps.updater = classComponentUpdater;
        newProps.props = props;
        newProps.state = initialState;
        defaultProps = { queue: [], replace: false };
        newProps._reactInternals = defaultProps;
        ref3 = type.contextType;
        newProps.context = "object" === typeof ref3 && null !== ref3 ? ref3._currentValue : emptyContextObject;
        ref3 = type.getDerivedStateFromProps;
        "function" === typeof ref3 && (ref3 = ref3(props, initialState), initialState = null === ref3 || void 0 === ref3 ? initialState : assign({}, initialState, ref3), newProps.state = initialState);
        if ("function" !== typeof type.getDerivedStateFromProps && "function" !== typeof newProps.getSnapshotBeforeUpdate && ("function" === typeof newProps.UNSAFE_componentWillMount || "function" === typeof newProps.componentWillMount))
          if (type = newProps.state, "function" === typeof newProps.componentWillMount && newProps.componentWillMount(), "function" === typeof newProps.UNSAFE_componentWillMount && newProps.UNSAFE_componentWillMount(), type !== newProps.state && classComponentUpdater.enqueueReplaceState(
            newProps,
            newProps.state,
            null
          ), null !== defaultProps.queue && 0 < defaultProps.queue.length)
            if (type = defaultProps.queue, ref3 = defaultProps.replace, defaultProps.queue = null, defaultProps.replace = false, ref3 && 1 === type.length)
              newProps.state = type[0];
            else {
              defaultProps = ref3 ? type[0] : newProps.state;
              initialState = true;
              for (ref3 = ref3 ? 1 : 0; ref3 < type.length; ref3++)
                propName$44 = type[ref3], propName$44 = "function" === typeof propName$44 ? propName$44.call(newProps, defaultProps, props, void 0) : propName$44, null != propName$44 && (initialState ? (initialState = false, defaultProps = assign({}, defaultProps, propName$44)) : assign(defaultProps, propName$44));
              newProps.state = defaultProps;
            }
          else defaultProps.queue = null;
        type = newProps.render();
        if (12 === request.status) throw null;
        props = task.keyPath;
        task.keyPath = keyPath;
        renderNodeDestructive(request, task, type, -1);
        task.keyPath = props;
      } else {
        type = renderWithHooks(request, task, keyPath, type, props, void 0);
        if (12 === request.status) throw null;
        finishFunctionComponent(
          request,
          task,
          keyPath,
          type,
          0 !== localIdCounter,
          actionStateCounter,
          actionStateMatchingIndex
        );
      }
    else if ("string" === typeof type)
      if (newProps = task.blockedSegment, null === newProps)
        newProps = props.children, defaultProps = task.formatContext, initialState = task.keyPath, task.formatContext = getChildFormatContext(defaultProps, type, props), task.keyPath = keyPath, renderNode(request, task, newProps, -1), task.formatContext = defaultProps, task.keyPath = initialState;
      else {
        initialState = pushStartInstance(
          newProps.chunks,
          type,
          props,
          request.resumableState,
          request.renderState,
          task.blockedPreamble,
          task.hoistableState,
          task.formatContext,
          newProps.lastPushedText
        );
        newProps.lastPushedText = false;
        defaultProps = task.formatContext;
        ref3 = task.keyPath;
        task.keyPath = keyPath;
        if (3 === (task.formatContext = getChildFormatContext(defaultProps, type, props)).insertionMode) {
          keyPath = createPendingSegment(
            request,
            0,
            null,
            task.formatContext,
            false,
            false
          );
          newProps.preambleChildren.push(keyPath);
          task.blockedSegment = keyPath;
          try {
            keyPath.status = 6, renderNode(request, task, initialState, -1), keyPath.lastPushedText && keyPath.textEmbedded && keyPath.chunks.push(textSeparator), keyPath.status = 1, finishedSegment(request, task.blockedBoundary, keyPath);
          } finally {
            task.blockedSegment = newProps;
          }
        } else renderNode(request, task, initialState, -1);
        task.formatContext = defaultProps;
        task.keyPath = ref3;
        a: {
          task = newProps.chunks;
          request = request.resumableState;
          switch (type) {
            case "title":
            case "style":
            case "script":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "img":
            case "input":
            case "keygen":
            case "link":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
              break a;
            case "body":
              if (1 >= defaultProps.insertionMode) {
                request.hasBody = true;
                break a;
              }
              break;
            case "html":
              if (0 === defaultProps.insertionMode) {
                request.hasHtml = true;
                break a;
              }
              break;
            case "head":
              if (1 >= defaultProps.insertionMode) break a;
          }
          task.push(endChunkForTag(type));
        }
        newProps.lastPushedText = false;
      }
    else {
      switch (type) {
        case REACT_LEGACY_HIDDEN_TYPE:
        case REACT_STRICT_MODE_TYPE:
        case REACT_PROFILER_TYPE:
        case REACT_FRAGMENT_TYPE:
          type = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, props.children, -1);
          task.keyPath = type;
          return;
        case REACT_ACTIVITY_TYPE:
          type = task.blockedSegment;
          null === type ? "hidden" !== props.mode && (type = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = type) : "hidden" !== props.mode && (type.chunks.push(startActivityBoundary), type.lastPushedText = false, newProps = task.keyPath, task.keyPath = keyPath, renderNode(request, task, props.children, -1), task.keyPath = newProps, type.chunks.push(endActivityBoundary), type.lastPushedText = false);
          return;
        case REACT_SUSPENSE_LIST_TYPE:
          a: {
            type = props.children;
            props = props.revealOrder;
            if ("forwards" === props || "backwards" === props || "unstable_legacy-backwards" === props) {
              if (isArrayImpl(type)) {
                renderSuspenseListRows(request, task, keyPath, type, props);
                break a;
              }
              if (newProps = getIteratorFn(type)) {
                if (newProps = newProps.call(type)) {
                  defaultProps = newProps.next();
                  if (!defaultProps.done) {
                    do
                      defaultProps = newProps.next();
                    while (!defaultProps.done);
                    renderSuspenseListRows(request, task, keyPath, type, props);
                  }
                  break a;
                }
              }
            }
            "together" === props ? (props = task.keyPath, newProps = task.row, defaultProps = task.row = createSuspenseListRow(null), defaultProps.boundaries = [], defaultProps.together = true, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), 0 === --defaultProps.pendingTasks && finishSuspenseListRow(request, defaultProps), task.keyPath = props, task.row = newProps, null !== newProps && 0 < defaultProps.pendingTasks && (newProps.pendingTasks++, defaultProps.next = newProps)) : (props = task.keyPath, task.keyPath = keyPath, renderNodeDestructive(request, task, type, -1), task.keyPath = props);
          }
          return;
        case REACT_VIEW_TRANSITION_TYPE:
        case REACT_SCOPE_TYPE:
          throw Error(formatProdErrorMessage(343));
        case REACT_SUSPENSE_TYPE:
          a: if (null !== task.replay) {
            type = task.keyPath;
            newProps = task.formatContext;
            defaultProps = task.row;
            task.keyPath = keyPath;
            task.formatContext = getSuspenseContentFormatContext(
              request.resumableState,
              newProps
            );
            task.row = null;
            keyPath = props.children;
            try {
              renderNode(request, task, keyPath, -1);
            } finally {
              task.keyPath = type, task.formatContext = newProps, task.row = defaultProps;
            }
          } else {
            type = task.keyPath;
            ref3 = task.formatContext;
            var prevRow = task.row;
            propName$44 = task.blockedBoundary;
            propName = task.blockedPreamble;
            var parentHoistableState = task.hoistableState, parentSegment = task.blockedSegment, fallback = props.fallback;
            props = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
              request,
              task.row,
              fallbackAbortSet,
              createPreambleState(),
              createPreambleState()
            ) : createSuspenseBoundary(
              request,
              task.row,
              fallbackAbortSet,
              null,
              null
            );
            null !== request.trackedPostpones && (newBoundary.trackedContentKeyPath = keyPath);
            var boundarySegment = createPendingSegment(
              request,
              parentSegment.chunks.length,
              newBoundary,
              task.formatContext,
              false,
              false
            );
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(
              request,
              0,
              null,
              task.formatContext,
              false,
              false
            );
            contentRootSegment.parentFlushed = true;
            if (null !== request.trackedPostpones) {
              newProps = task.componentStack;
              defaultProps = [keyPath[0], "Suspense Fallback", keyPath[2]];
              initialState = [defaultProps[1], defaultProps[2], [], null];
              request.trackedPostpones.workingMap.set(defaultProps, initialState);
              newBoundary.trackedFallbackNode = initialState;
              task.blockedSegment = boundarySegment;
              task.blockedPreamble = newBoundary.fallbackPreamble;
              task.keyPath = defaultProps;
              task.formatContext = getSuspenseFallbackFormatContext(
                request.resumableState,
                ref3
              );
              task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(newProps);
              boundarySegment.status = 6;
              try {
                renderNode(request, task, fallback, -1), boundarySegment.lastPushedText && boundarySegment.textEmbedded && boundarySegment.chunks.push(textSeparator), boundarySegment.status = 1, finishedSegment(request, propName$44, boundarySegment);
              } catch (thrownValue) {
                throw boundarySegment.status = 12 === request.status ? 3 : 4, thrownValue;
              } finally {
                task.blockedSegment = parentSegment, task.blockedPreamble = propName, task.keyPath = type, task.formatContext = ref3;
              }
              task = createRenderTask(
                request,
                null,
                props,
                -1,
                newBoundary,
                contentRootSegment,
                newBoundary.contentPreamble,
                newBoundary.contentState,
                task.abortSet,
                keyPath,
                getSuspenseContentFormatContext(
                  request.resumableState,
                  task.formatContext
                ),
                task.context,
                task.treeContext,
                null,
                newProps
              );
              pushComponentStack(task);
              request.pingedTasks.push(task);
            } else {
              task.blockedBoundary = newBoundary;
              task.blockedPreamble = newBoundary.contentPreamble;
              task.hoistableState = newBoundary.contentState;
              task.blockedSegment = contentRootSegment;
              task.keyPath = keyPath;
              task.formatContext = getSuspenseContentFormatContext(
                request.resumableState,
                ref3
              );
              task.row = null;
              contentRootSegment.status = 6;
              try {
                if (renderNode(request, task, props, -1), contentRootSegment.lastPushedText && contentRootSegment.textEmbedded && contentRootSegment.chunks.push(textSeparator), contentRootSegment.status = 1, finishedSegment(request, newBoundary, contentRootSegment), queueCompletedSegment(newBoundary, contentRootSegment), 0 === newBoundary.pendingTasks && 0 === newBoundary.status) {
                  if (newBoundary.status = 1, !isEligibleForOutlining(request, newBoundary)) {
                    null !== prevRow && 0 === --prevRow.pendingTasks && finishSuspenseListRow(request, prevRow);
                    0 === request.pendingRootTasks && task.blockedPreamble && preparePreamble(request);
                    break a;
                  }
                } else
                  null !== prevRow && prevRow.together && tryToResolveTogetherRow(request, prevRow);
              } catch (thrownValue$31) {
                newBoundary.status = 4, 12 === request.status ? (contentRootSegment.status = 3, newProps = request.fatalError) : (contentRootSegment.status = 4, newProps = thrownValue$31), defaultProps = getThrownInfo(task.componentStack), initialState = logRecoverableError(
                  request,
                  newProps,
                  defaultProps
                ), newBoundary.errorDigest = initialState, untrackBoundary(request, newBoundary);
              } finally {
                task.blockedBoundary = propName$44, task.blockedPreamble = propName, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = type, task.formatContext = ref3, task.row = prevRow;
              }
              task = createRenderTask(
                request,
                null,
                fallback,
                -1,
                propName$44,
                boundarySegment,
                newBoundary.fallbackPreamble,
                newBoundary.fallbackState,
                fallbackAbortSet,
                [keyPath[0], "Suspense Fallback", keyPath[2]],
                getSuspenseFallbackFormatContext(
                  request.resumableState,
                  task.formatContext
                ),
                task.context,
                task.treeContext,
                task.row,
                replaceSuspenseComponentStackWithSuspenseFallbackStack(
                  task.componentStack
                )
              );
              pushComponentStack(task);
              request.pingedTasks.push(task);
            }
          }
          return;
      }
      if ("object" === typeof type && null !== type)
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            if ("ref" in props)
              for (parentSegment in newProps = {}, props)
                "ref" !== parentSegment && (newProps[parentSegment] = props[parentSegment]);
            else newProps = props;
            type = renderWithHooks(
              request,
              task,
              keyPath,
              type.render,
              newProps,
              ref3
            );
            finishFunctionComponent(
              request,
              task,
              keyPath,
              type,
              0 !== localIdCounter,
              actionStateCounter,
              actionStateMatchingIndex
            );
            return;
          case REACT_MEMO_TYPE:
            renderElement2(request, task, keyPath, type.type, props, ref3);
            return;
          case REACT_CONTEXT_TYPE:
            defaultProps = props.children;
            newProps = task.keyPath;
            props = props.value;
            initialState = type._currentValue;
            type._currentValue = props;
            ref3 = currentActiveSnapshot;
            currentActiveSnapshot = type = {
              parent: ref3,
              depth: null === ref3 ? 0 : ref3.depth + 1,
              context: type,
              parentValue: initialState,
              value: props
            };
            task.context = type;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, defaultProps, -1);
            request = currentActiveSnapshot;
            if (null === request) throw Error(formatProdErrorMessage(403));
            request.context._currentValue = request.parentValue;
            request = currentActiveSnapshot = request.parent;
            task.context = request;
            task.keyPath = newProps;
            return;
          case REACT_CONSUMER_TYPE:
            props = props.children;
            type = props(type._context._currentValue);
            props = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, type, -1);
            task.keyPath = props;
            return;
          case REACT_LAZY_TYPE:
            newProps = type._init;
            type = newProps(type._payload);
            if (12 === request.status) throw null;
            renderElement2(request, task, keyPath, type, props, ref3);
            return;
        }
      throw Error(
        formatProdErrorMessage(130, null == type ? type : typeof type, "")
      );
    }
  }
  __name(renderElement2, "renderElement");
  function resumeNode(request, task, segmentId, node, childIndex) {
    var prevReplay = task.replay, blockedBoundary = task.blockedBoundary, resumedSegment = createPendingSegment(
      request,
      0,
      null,
      task.formatContext,
      false,
      false
    );
    resumedSegment.id = segmentId;
    resumedSegment.parentFlushed = true;
    try {
      task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = 1, finishedSegment(request, blockedBoundary, resumedSegment), null === blockedBoundary ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
    } finally {
      task.replay = prevReplay, task.blockedSegment = null;
    }
  }
  __name(resumeNode, "resumeNode");
  function renderNodeDestructive(request, task, node, childIndex) {
    null !== task.replay && "number" === typeof task.replay.slots ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, pushComponentStack(task), retryNode(request, task), task.componentStack = node);
  }
  __name(renderNodeDestructive, "renderNodeDestructive");
  function retryNode(request, task) {
    var node = task.node, childIndex = task.childIndex;
    if (null !== node) {
      if ("object" === typeof node) {
        switch (node.$$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = node.type, key = node.key, props = node.props;
            node = props.ref;
            var ref3 = void 0 !== node ? node : null, name = getComponentNameFromType(type), keyOrIndex = null == key ? -1 === childIndex ? 0 : childIndex : key;
            key = [task.keyPath, name, keyOrIndex];
            if (null !== task.replay)
              a: {
                var replay = task.replay;
                childIndex = replay.nodes;
                for (node = 0; node < childIndex.length; node++) {
                  var node$jscomp$0 = childIndex[node];
                  if (keyOrIndex === node$jscomp$0[1]) {
                    if (4 === node$jscomp$0.length) {
                      if (null !== name && name !== node$jscomp$0[0])
                        throw Error(
                          formatProdErrorMessage(490, node$jscomp$0[0], name)
                        );
                      var childNodes = node$jscomp$0[2];
                      name = node$jscomp$0[3];
                      keyOrIndex = task.node;
                      task.replay = {
                        nodes: childNodes,
                        slots: name,
                        pendingTasks: 1
                      };
                      try {
                        renderElement2(request, task, key, type, props, ref3);
                        if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                          throw Error(formatProdErrorMessage(488));
                        task.replay.pendingTasks--;
                      } catch (x) {
                        if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
                          throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(node, 1), x;
                        task.replay.pendingTasks--;
                        props = getThrownInfo(task.componentStack);
                        key = request;
                        request = task.blockedBoundary;
                        type = x;
                        props = logRecoverableError(key, type, props);
                        abortRemainingReplayNodes(
                          key,
                          request,
                          childNodes,
                          name,
                          type,
                          props
                        );
                      }
                      task.replay = replay;
                    } else {
                      if (type !== REACT_SUSPENSE_TYPE)
                        throw Error(
                          formatProdErrorMessage(
                            490,
                            "Suspense",
                            getComponentNameFromType(type) || "Unknown"
                          )
                        );
                      b: {
                        replay = void 0;
                        type = node$jscomp$0[5];
                        ref3 = node$jscomp$0[2];
                        name = node$jscomp$0[3];
                        keyOrIndex = null === node$jscomp$0[4] ? [] : node$jscomp$0[4][2];
                        node$jscomp$0 = null === node$jscomp$0[4] ? null : node$jscomp$0[4][3];
                        var prevKeyPath = task.keyPath, prevContext = task.formatContext, prevRow = task.row, previousReplaySet = task.replay, parentBoundary = task.blockedBoundary, parentHoistableState = task.hoistableState, content = props.children, fallback = props.fallback, fallbackAbortSet = /* @__PURE__ */ new Set();
                        props = 2 > task.formatContext.insertionMode ? createSuspenseBoundary(
                          request,
                          task.row,
                          fallbackAbortSet,
                          createPreambleState(),
                          createPreambleState()
                        ) : createSuspenseBoundary(
                          request,
                          task.row,
                          fallbackAbortSet,
                          null,
                          null
                        );
                        props.parentFlushed = true;
                        props.rootSegmentID = type;
                        task.blockedBoundary = props;
                        task.hoistableState = props.contentState;
                        task.keyPath = key;
                        task.formatContext = getSuspenseContentFormatContext(
                          request.resumableState,
                          prevContext
                        );
                        task.row = null;
                        task.replay = {
                          nodes: ref3,
                          slots: name,
                          pendingTasks: 1
                        };
                        try {
                          renderNode(request, task, content, -1);
                          if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                            throw Error(formatProdErrorMessage(488));
                          task.replay.pendingTasks--;
                          if (0 === props.pendingTasks && 0 === props.status) {
                            props.status = 1;
                            request.completedBoundaries.push(props);
                            break b;
                          }
                        } catch (error5) {
                          props.status = 4, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(
                            request,
                            error5,
                            childNodes
                          ), props.errorDigest = replay, task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
                        } finally {
                          task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
                        }
                        childNodes = createReplayTask(
                          request,
                          null,
                          {
                            nodes: keyOrIndex,
                            slots: node$jscomp$0,
                            pendingTasks: 0
                          },
                          fallback,
                          -1,
                          parentBoundary,
                          props.fallbackState,
                          fallbackAbortSet,
                          [key[0], "Suspense Fallback", key[2]],
                          getSuspenseFallbackFormatContext(
                            request.resumableState,
                            task.formatContext
                          ),
                          task.context,
                          task.treeContext,
                          task.row,
                          replaceSuspenseComponentStackWithSuspenseFallbackStack(
                            task.componentStack
                          )
                        );
                        pushComponentStack(childNodes);
                        request.pingedTasks.push(childNodes);
                      }
                    }
                    childIndex.splice(node, 1);
                    break a;
                  }
                }
              }
            else renderElement2(request, task, key, type, props, ref3);
            return;
          case REACT_PORTAL_TYPE:
            throw Error(formatProdErrorMessage(257));
          case REACT_LAZY_TYPE:
            childNodes = node._init;
            node = childNodes(node._payload);
            if (12 === request.status) throw null;
            renderNodeDestructive(request, task, node, childIndex);
            return;
        }
        if (isArrayImpl(node)) {
          renderChildrenArray(request, task, node, childIndex);
          return;
        }
        if (childNodes = getIteratorFn(node)) {
          if (childNodes = childNodes.call(node)) {
            node = childNodes.next();
            if (!node.done) {
              props = [];
              do
                props.push(node.value), node = childNodes.next();
              while (!node.done);
              renderChildrenArray(request, task, props, childIndex);
            }
            return;
          }
        }
        if ("function" === typeof node.then)
          return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
        if (node.$$typeof === REACT_CONTEXT_TYPE)
          return renderNodeDestructive(
            request,
            task,
            node._currentValue,
            childIndex
          );
        childIndex = Object.prototype.toString.call(node);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === childIndex ? "object with keys {" + Object.keys(node).join(", ") + "}" : childIndex
          )
        );
      }
      if ("string" === typeof node)
        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
          childIndex.chunks,
          node,
          request.renderState,
          childIndex.lastPushedText
        ));
      else if ("number" === typeof node || "bigint" === typeof node)
        childIndex = task.blockedSegment, null !== childIndex && (childIndex.lastPushedText = pushTextInstance(
          childIndex.chunks,
          "" + node,
          request.renderState,
          childIndex.lastPushedText
        ));
    }
  }
  __name(retryNode, "retryNode");
  function renderChildrenArray(request, task, children, childIndex) {
    var prevKeyPath = task.keyPath;
    if (-1 !== childIndex && (task.keyPath = [task.keyPath, "Fragment", childIndex], null !== task.replay)) {
      for (var replay = task.replay, replayNodes = replay.nodes, j = 0; j < replayNodes.length; j++) {
        var node = replayNodes[j];
        if (node[1] === childIndex) {
          childIndex = node[2];
          node = node[3];
          task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
          try {
            renderChildrenArray(request, task, children, -1);
            if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
              throw Error(formatProdErrorMessage(488));
            task.replay.pendingTasks--;
          } catch (x) {
            if ("object" === typeof x && null !== x && (x === SuspenseException || "function" === typeof x.then))
              throw x;
            task.replay.pendingTasks--;
            children = getThrownInfo(task.componentStack);
            var boundary = task.blockedBoundary, error5 = x;
            children = logRecoverableError(request, error5, children);
            abortRemainingReplayNodes(
              request,
              boundary,
              childIndex,
              node,
              error5,
              children
            );
          }
          task.replay = replay;
          replayNodes.splice(j, 1);
          break;
        }
      }
      task.keyPath = prevKeyPath;
      return;
    }
    replay = task.treeContext;
    replayNodes = children.length;
    if (null !== task.replay && (j = task.replay.slots, null !== j && "object" === typeof j)) {
      for (childIndex = 0; childIndex < replayNodes; childIndex++)
        node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), boundary = j[childIndex], "number" === typeof boundary ? (resumeNode(request, task, boundary, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
      return;
    }
    for (j = 0; j < replayNodes; j++)
      childIndex = children[j], task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
    task.treeContext = replay;
    task.keyPath = prevKeyPath;
  }
  __name(renderChildrenArray, "renderChildrenArray");
  function trackPostponedBoundary(request, trackedPostpones, boundary) {
    boundary.status = 5;
    boundary.rootSegmentID = request.nextSegmentId++;
    request = boundary.trackedContentKeyPath;
    if (null === request) throw Error(formatProdErrorMessage(486));
    var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
    if (void 0 === boundaryNode)
      return boundary = [
        request[1],
        request[2],
        children,
        null,
        fallbackReplayNode,
        boundary.rootSegmentID
      ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
    boundaryNode[4] = fallbackReplayNode;
    boundaryNode[5] = boundary.rootSegmentID;
    return boundaryNode;
  }
  __name(trackPostponedBoundary, "trackPostponedBoundary");
  function trackPostpone(request, trackedPostpones, task, segment) {
    segment.status = 5;
    var keyPath = task.keyPath, boundary = task.blockedBoundary;
    if (null === boundary)
      segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, null !== request.completedRootSegment && (request.completedRootSegment.status = 5);
    else {
      if (null !== boundary && 0 === boundary.status) {
        var boundaryNode = trackPostponedBoundary(
          request,
          trackedPostpones,
          boundary
        );
        if (boundary.trackedContentKeyPath === keyPath && -1 === task.childIndex) {
          -1 === segment.id && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
          boundaryNode[3] = segment.id;
          return;
        }
      }
      -1 === segment.id && (segment.id = segment.parentFlushed && null !== boundary ? boundary.rootSegmentID : request.nextSegmentId++);
      if (-1 === task.childIndex)
        null === keyPath ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), void 0 === task ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
      else {
        if (null === keyPath)
          if (request = trackedPostpones.rootSlots, null === request)
            request = trackedPostpones.rootSlots = {};
          else {
            if ("number" === typeof request)
              throw Error(formatProdErrorMessage(491));
          }
        else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), void 0 === boundaryNode)
          request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
        else if (request = boundaryNode[3], null === request)
          request = boundaryNode[3] = {};
        else if ("number" === typeof request)
          throw Error(formatProdErrorMessage(491));
        request[task.childIndex] = segment.id;
      }
    }
  }
  __name(trackPostpone, "trackPostpone");
  function untrackBoundary(request, boundary) {
    request = request.trackedPostpones;
    null !== request && (boundary = boundary.trackedContentKeyPath, null !== boundary && (boundary = request.workingMap.get(boundary), void 0 !== boundary && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
  }
  __name(untrackBoundary, "untrackBoundary");
  function spawnNewSuspendedReplayTask(request, task, thenableState2) {
    return createReplayTask(
      request,
      thenableState2,
      task.replay,
      task.node,
      task.childIndex,
      task.blockedBoundary,
      task.hoistableState,
      task.abortSet,
      task.keyPath,
      task.formatContext,
      task.context,
      task.treeContext,
      task.row,
      task.componentStack
    );
  }
  __name(spawnNewSuspendedReplayTask, "spawnNewSuspendedReplayTask");
  function spawnNewSuspendedRenderTask(request, task, thenableState2) {
    var segment = task.blockedSegment, newSegment = createPendingSegment(
      request,
      segment.chunks.length,
      null,
      task.formatContext,
      segment.lastPushedText,
      true
    );
    segment.children.push(newSegment);
    segment.lastPushedText = false;
    return createRenderTask(
      request,
      thenableState2,
      task.node,
      task.childIndex,
      task.blockedBoundary,
      newSegment,
      task.blockedPreamble,
      task.hoistableState,
      task.abortSet,
      task.keyPath,
      task.formatContext,
      task.context,
      task.treeContext,
      task.row,
      task.componentStack
    );
  }
  __name(spawnNewSuspendedRenderTask, "spawnNewSuspendedRenderTask");
  function renderNode(request, task, node, childIndex) {
    var previousFormatContext = task.formatContext, previousContext = task.context, previousKeyPath = task.keyPath, previousTreeContext = task.treeContext, previousComponentStack = task.componentStack, segment = task.blockedSegment;
    if (null === segment) {
      segment = task.replay;
      try {
        return renderNodeDestructive(request, task, node, childIndex);
      } catch (thrownValue) {
        if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, 12 !== request.status && "object" === typeof node && null !== node) {
          if ("function" === typeof node.then) {
            childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
            request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
            node.then(request, request);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            task.replay = segment;
            switchContext(previousContext);
            return;
          }
          if ("Maximum call stack size exceeded" === node.message) {
            node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
            node = spawnNewSuspendedReplayTask(request, task, node);
            request.pingedTasks.push(node);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            task.replay = segment;
            switchContext(previousContext);
            return;
          }
        }
      }
    } else {
      var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
      try {
        return renderNodeDestructive(request, task, node, childIndex);
      } catch (thrownValue$63) {
        if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$63 === SuspenseException ? getSuspendedThenable() : thrownValue$63, 12 !== request.status && "object" === typeof node && null !== node) {
          if ("function" === typeof node.then) {
            segment = node;
            node = thrownValue$63 === SuspenseException ? getThenableStateAfterSuspending() : null;
            request = spawnNewSuspendedRenderTask(request, task, node).ping;
            segment.then(request, request);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            switchContext(previousContext);
            return;
          }
          if ("Maximum call stack size exceeded" === node.message) {
            segment = thrownValue$63 === SuspenseException ? getThenableStateAfterSuspending() : null;
            segment = spawnNewSuspendedRenderTask(request, task, segment);
            request.pingedTasks.push(segment);
            task.formatContext = previousFormatContext;
            task.context = previousContext;
            task.keyPath = previousKeyPath;
            task.treeContext = previousTreeContext;
            task.componentStack = previousComponentStack;
            switchContext(previousContext);
            return;
          }
        }
      }
    }
    task.formatContext = previousFormatContext;
    task.context = previousContext;
    task.keyPath = previousKeyPath;
    task.treeContext = previousTreeContext;
    switchContext(previousContext);
    throw node;
  }
  __name(renderNode, "renderNode");
  function abortTaskSoft(task) {
    var boundary = task.blockedBoundary, segment = task.blockedSegment;
    null !== segment && (segment.status = 3, finishedTask(this, boundary, task.row, segment));
  }
  __name(abortTaskSoft, "abortTaskSoft");
  function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error5, errorDigest$jscomp$0) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var node = nodes[i2];
      if (4 === node.length)
        abortRemainingReplayNodes(
          request$jscomp$0,
          boundary,
          node[2],
          node[3],
          error5,
          errorDigest$jscomp$0
        );
      else {
        node = node[5];
        var request = request$jscomp$0, errorDigest = errorDigest$jscomp$0, resumedBoundary = createSuspenseBoundary(
          request,
          null,
          /* @__PURE__ */ new Set(),
          null,
          null
        );
        resumedBoundary.parentFlushed = true;
        resumedBoundary.rootSegmentID = node;
        resumedBoundary.status = 4;
        resumedBoundary.errorDigest = errorDigest;
        resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
      }
    }
    nodes.length = 0;
    if (null !== slots) {
      if (null === boundary) throw Error(formatProdErrorMessage(487));
      4 !== boundary.status && (boundary.status = 4, boundary.errorDigest = errorDigest$jscomp$0, boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
      if ("object" === typeof slots) for (var index2 in slots) delete slots[index2];
    }
  }
  __name(abortRemainingReplayNodes, "abortRemainingReplayNodes");
  function abortTask(task, request, error5) {
    var boundary = task.blockedBoundary, segment = task.blockedSegment;
    if (null !== segment) {
      if (6 === segment.status) return;
      segment.status = 3;
    }
    var errorInfo = getThrownInfo(task.componentStack);
    if (null === boundary) {
      if (13 !== request.status && 14 !== request.status) {
        boundary = task.replay;
        if (null === boundary) {
          null !== request.trackedPostpones && null !== segment ? (boundary = request.trackedPostpones, logRecoverableError(request, error5, errorInfo), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error5, errorInfo), fatalError(request, error5));
          return;
        }
        boundary.pendingTasks--;
        0 === boundary.pendingTasks && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error5, errorInfo), abortRemainingReplayNodes(
          request,
          null,
          boundary.nodes,
          boundary.slots,
          error5,
          segment
        ));
        request.pendingRootTasks--;
        0 === request.pendingRootTasks && completeShell(request);
      }
    } else {
      var trackedPostpones$64 = request.trackedPostpones;
      if (4 !== boundary.status) {
        if (null !== trackedPostpones$64 && null !== segment)
          return logRecoverableError(request, error5, errorInfo), trackPostpone(request, trackedPostpones$64, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
            return abortTask(fallbackTask, request, error5);
          }), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
        boundary.status = 4;
        segment = logRecoverableError(request, error5, errorInfo);
        boundary.status = 4;
        boundary.errorDigest = segment;
        untrackBoundary(request, boundary);
        boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
      }
      boundary.pendingTasks--;
      segment = boundary.row;
      null !== segment && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
      boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
        return abortTask(fallbackTask, request, error5);
      });
      boundary.fallbackAbortableTasks.clear();
    }
    task = task.row;
    null !== task && 0 === --task.pendingTasks && finishSuspenseListRow(request, task);
    request.allPendingTasks--;
    0 === request.allPendingTasks && completeAll(request);
  }
  __name(abortTask, "abortTask");
  function safelyEmitEarlyPreloads(request, shellComplete) {
    try {
      var renderState = request.renderState, onHeaders = renderState.onHeaders;
      if (onHeaders) {
        var headers = renderState.headers;
        if (headers) {
          renderState.headers = null;
          var linkHeader = headers.preconnects;
          headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
          headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
          if (!shellComplete) {
            var queueIter = renderState.styles.values(), queueStep = queueIter.next();
            b: for (; 0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next(); 0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props, header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                  crossOrigin: props$jscomp$0.crossOrigin,
                  integrity: props$jscomp$0.integrity,
                  nonce: props$jscomp$0.nonce,
                  type: props$jscomp$0.type,
                  fetchPriority: props$jscomp$0.fetchPriority,
                  referrerPolicy: props$jscomp$0.referrerPolicy,
                  media: props$jscomp$0.media
                });
                if (0 <= (headers.remainingCapacity -= header.length + 2))
                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = "string" === typeof props.crossOrigin || "string" === typeof props.integrity ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                else break b;
              }
          }
          linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
        }
      }
    } catch (error5) {
      logRecoverableError(request, error5, {});
    }
  }
  __name(safelyEmitEarlyPreloads, "safelyEmitEarlyPreloads");
  function completeShell(request) {
    null === request.trackedPostpones && safelyEmitEarlyPreloads(request, true);
    null === request.trackedPostpones && preparePreamble(request);
    request.onShellError = noop2;
    request = request.onShellReady;
    request();
  }
  __name(completeShell, "completeShell");
  function completeAll(request) {
    safelyEmitEarlyPreloads(
      request,
      null === request.trackedPostpones ? true : null === request.completedRootSegment || 5 !== request.completedRootSegment.status
    );
    preparePreamble(request);
    request = request.onAllReady;
    request();
  }
  __name(completeAll, "completeAll");
  function queueCompletedSegment(boundary, segment) {
    if (0 === segment.chunks.length && 1 === segment.children.length && null === segment.children[0].boundary && -1 === segment.children[0].id) {
      var childSegment = segment.children[0];
      childSegment.id = segment.id;
      childSegment.parentFlushed = true;
      1 !== childSegment.status && 3 !== childSegment.status && 4 !== childSegment.status || queueCompletedSegment(boundary, childSegment);
    } else boundary.completedSegments.push(segment);
  }
  __name(queueCompletedSegment, "queueCompletedSegment");
  function finishedSegment(request, boundary, segment) {
    if (null !== byteLengthOfChunk) {
      segment = segment.chunks;
      for (var segmentByteSize = 0, i2 = 0; i2 < segment.length; i2++)
        segmentByteSize += segment[i2].byteLength;
      null === boundary ? request.byteSize += segmentByteSize : boundary.byteSize += segmentByteSize;
    }
  }
  __name(finishedSegment, "finishedSegment");
  function finishedTask(request, boundary, row, segment) {
    null !== row && (0 === --row.pendingTasks ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
    request.allPendingTasks--;
    if (null === boundary) {
      if (null !== segment && segment.parentFlushed) {
        if (null !== request.completedRootSegment)
          throw Error(formatProdErrorMessage(389));
        request.completedRootSegment = segment;
      }
      request.pendingRootTasks--;
      0 === request.pendingRootTasks && completeShell(request);
    } else if (boundary.pendingTasks--, 4 !== boundary.status)
      if (0 === boundary.pendingTasks)
        if (0 === boundary.status && (boundary.status = 1), null !== segment && segment.parentFlushed && (1 === segment.status || 3 === segment.status) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), 1 === boundary.status)
          row = boundary.row, null !== row && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row)), 0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary.contentPreamble && preparePreamble(request);
        else {
          if (5 === boundary.status && (boundary = boundary.row, null !== boundary)) {
            if (null !== request.trackedPostpones) {
              row = request.trackedPostpones;
              var postponedRow = boundary.next;
              if (null !== postponedRow && (segment = postponedRow.boundaries, null !== segment))
                for (postponedRow.boundaries = null, postponedRow = 0; postponedRow < segment.length; postponedRow++) {
                  var postponedBoundary = segment[postponedRow];
                  trackPostponedBoundary(request, row, postponedBoundary);
                  finishedTask(request, postponedBoundary, null, null);
                }
            }
            0 === --boundary.pendingTasks && finishSuspenseListRow(request, boundary);
          }
        }
      else
        null === segment || !segment.parentFlushed || 1 !== segment.status && 3 !== segment.status || (queueCompletedSegment(boundary, segment), 1 === boundary.completedSegments.length && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, null !== boundary && boundary.together && tryToResolveTogetherRow(request, boundary);
    0 === request.allPendingTasks && completeAll(request);
  }
  __name(finishedTask, "finishedTask");
  function performWork(request$jscomp$2) {
    if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {
      var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = HooksDispatcher;
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      var prevRequest = currentRequest;
      currentRequest = request$jscomp$2;
      var prevResumableState = currentResumableState;
      currentResumableState = request$jscomp$2.resumableState;
      try {
        var pingedTasks = request$jscomp$2.pingedTasks, i2;
        for (i2 = 0; i2 < pingedTasks.length; i2++) {
          var task = pingedTasks[i2], request = request$jscomp$2, segment = task.blockedSegment;
          if (null === segment) {
            var request$jscomp$0 = request;
            if (0 !== task.replay.pendingTasks) {
              switchContext(task.context);
              try {
                "number" === typeof task.replay.slots ? resumeNode(
                  request$jscomp$0,
                  task,
                  task.replay.slots,
                  task.node,
                  task.childIndex
                ) : retryNode(request$jscomp$0, task);
                if (1 === task.replay.pendingTasks && 0 < task.replay.nodes.length)
                  throw Error(formatProdErrorMessage(488));
                task.replay.pendingTasks--;
                task.abortSet.delete(task);
                finishedTask(
                  request$jscomp$0,
                  task.blockedBoundary,
                  task.row,
                  null
                );
              } catch (thrownValue) {
                resetHooksState();
                var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
                if ("object" === typeof x && null !== x && "function" === typeof x.then) {
                  var ping = task.ping;
                  x.then(ping, ping);
                  task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                } else {
                  task.replay.pendingTasks--;
                  task.abortSet.delete(task);
                  var errorInfo = getThrownInfo(task.componentStack);
                  request = void 0;
                  var request$jscomp$1 = request$jscomp$0, boundary = task.blockedBoundary, error$jscomp$0 = 12 === request$jscomp$0.status ? request$jscomp$0.fatalError : x, replayNodes = task.replay.nodes, resumeSlots = task.replay.slots;
                  request = logRecoverableError(
                    request$jscomp$1,
                    error$jscomp$0,
                    errorInfo
                  );
                  abortRemainingReplayNodes(
                    request$jscomp$1,
                    boundary,
                    replayNodes,
                    resumeSlots,
                    error$jscomp$0,
                    request
                  );
                  request$jscomp$0.pendingRootTasks--;
                  0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);
                  request$jscomp$0.allPendingTasks--;
                  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);
                }
              } finally {
              }
            }
          } else if (request$jscomp$0 = void 0, request$jscomp$1 = segment, 0 === request$jscomp$1.status) {
            request$jscomp$1.status = 6;
            switchContext(task.context);
            var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
            try {
              retryNode(request, task), request$jscomp$1.lastPushedText && request$jscomp$1.textEmbedded && request$jscomp$1.chunks.push(textSeparator), task.abortSet.delete(task), request$jscomp$1.status = 1, finishedSegment(request, task.blockedBoundary, request$jscomp$1), finishedTask(
                request,
                task.blockedBoundary,
                task.row,
                request$jscomp$1
              );
            } catch (thrownValue) {
              resetHooksState();
              request$jscomp$1.children.length = childrenLength;
              request$jscomp$1.chunks.length = chunkLength;
              var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : 12 === request.status ? request.fatalError : thrownValue;
              if (12 === request.status && null !== request.trackedPostpones) {
                var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(task.componentStack);
                task.abortSet.delete(task);
                logRecoverableError(request, x$jscomp$0, thrownInfo);
                trackPostpone(request, trackedPostpones, task, request$jscomp$1);
                finishedTask(
                  request,
                  task.blockedBoundary,
                  task.row,
                  request$jscomp$1
                );
              } else if ("object" === typeof x$jscomp$0 && null !== x$jscomp$0 && "function" === typeof x$jscomp$0.then) {
                request$jscomp$1.status = 0;
                task.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
                var ping$jscomp$0 = task.ping;
                x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
              } else {
                var errorInfo$jscomp$0 = getThrownInfo(task.componentStack);
                task.abortSet.delete(task);
                request$jscomp$1.status = 4;
                var boundary$jscomp$0 = task.blockedBoundary, row = task.row;
                null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
                request.allPendingTasks--;
                request$jscomp$0 = logRecoverableError(
                  request,
                  x$jscomp$0,
                  errorInfo$jscomp$0
                );
                if (null === boundary$jscomp$0) fatalError(request, x$jscomp$0);
                else if (boundary$jscomp$0.pendingTasks--, 4 !== boundary$jscomp$0.status) {
                  boundary$jscomp$0.status = 4;
                  boundary$jscomp$0.errorDigest = request$jscomp$0;
                  untrackBoundary(request, boundary$jscomp$0);
                  var boundaryRow = boundary$jscomp$0.row;
                  null !== boundaryRow && 0 === --boundaryRow.pendingTasks && finishSuspenseListRow(request, boundaryRow);
                  boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                  0 === request.pendingRootTasks && null === request.trackedPostpones && null !== boundary$jscomp$0.contentPreamble && preparePreamble(request);
                }
                0 === request.allPendingTasks && completeAll(request);
              }
            } finally {
            }
          }
        }
        pingedTasks.splice(0, i2);
        null !== request$jscomp$2.destination && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
      } catch (error5) {
        logRecoverableError(request$jscomp$2, error5, {}), fatalError(request$jscomp$2, error5);
      } finally {
        currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
      }
    }
  }
  __name(performWork, "performWork");
  function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
    segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
    for (var pendingPreambles = false, i2 = 0; i2 < segment.children.length; i2++)
      pendingPreambles = preparePreambleFromSegment(
        request,
        segment.children[i2],
        collectedPreambleSegments
      ) || pendingPreambles;
    return pendingPreambles;
  }
  __name(preparePreambleFromSubtree, "preparePreambleFromSubtree");
  function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
    var boundary = segment.boundary;
    if (null === boundary)
      return preparePreambleFromSubtree(
        request,
        segment,
        collectedPreambleSegments
      );
    var preamble = boundary.contentPreamble, fallbackPreamble = boundary.fallbackPreamble;
    if (null === preamble || null === fallbackPreamble) return false;
    switch (boundary.status) {
      case 1:
        hoistPreambleState(request.renderState, preamble);
        request.byteSize += boundary.byteSize;
        segment = boundary.completedSegments[0];
        if (!segment) throw Error(formatProdErrorMessage(391));
        return preparePreambleFromSubtree(
          request,
          segment,
          collectedPreambleSegments
        );
      case 5:
        if (null !== request.trackedPostpones) return true;
      case 4:
        if (1 === segment.status)
          return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(
            request,
            segment,
            collectedPreambleSegments
          );
      default:
        return true;
    }
  }
  __name(preparePreambleFromSegment, "preparePreambleFromSegment");
  function preparePreamble(request) {
    if (request.completedRootSegment && null === request.completedPreambleSegments) {
      var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(
        request,
        request.completedRootSegment,
        collectedPreambleSegments
      ), preamble = request.renderState.preamble;
      false === hasPendingPreambles || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
    }
  }
  __name(preparePreamble, "preparePreamble");
  function flushSubtree(request, destination, segment, hoistableState) {
    segment.parentFlushed = true;
    switch (segment.status) {
      case 0:
        segment.id = request.nextSegmentId++;
      case 5:
        return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = stringToChunk(hoistableState.toString(16)), writeChunk(destination, request), writeChunkAndReturn(destination, placeholder2);
      case 1:
        segment.status = 2;
        var r2 = true, chunks = segment.chunks, chunkIdx = 0;
        segment = segment.children;
        for (var childIdx = 0; childIdx < segment.length; childIdx++) {
          for (r2 = segment[childIdx]; chunkIdx < r2.index; chunkIdx++)
            writeChunk(destination, chunks[chunkIdx]);
          r2 = flushSegment(request, destination, r2, hoistableState);
        }
        for (; chunkIdx < chunks.length - 1; chunkIdx++)
          writeChunk(destination, chunks[chunkIdx]);
        chunkIdx < chunks.length && (r2 = writeChunkAndReturn(destination, chunks[chunkIdx]));
        return r2;
      case 3:
        return true;
      default:
        throw Error(formatProdErrorMessage(390));
    }
  }
  __name(flushSubtree, "flushSubtree");
  var flushedByteSize = 0;
  function flushSegment(request, destination, segment, hoistableState) {
    var boundary = segment.boundary;
    if (null === boundary)
      return flushSubtree(request, destination, segment, hoistableState);
    boundary.parentFlushed = true;
    if (4 === boundary.status) {
      var row = boundary.row;
      null !== row && 0 === --row.pendingTasks && finishSuspenseListRow(request, row);
      boundary = boundary.errorDigest;
      writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
      writeChunk(destination, clientRenderedSuspenseBoundaryError1);
      boundary && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, stringToChunk(escapeTextForBrowser(boundary))), writeChunk(
        destination,
        clientRenderedSuspenseBoundaryErrorAttrInterstitial
      ));
      writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
      flushSubtree(request, destination, segment, hoistableState);
    } else if (1 !== boundary.status)
      0 === boundary.status && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
        destination,
        request.renderState,
        boundary.rootSegmentID
      ), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState);
    else if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && (flushedByteSize + boundary.byteSize > request.progressiveChunkSize || hasSuspenseyContent(boundary.contentState)))
      boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(
        destination,
        request.renderState,
        boundary.rootSegmentID
      ), flushSubtree(request, destination, segment, hoistableState);
    else {
      flushedByteSize += boundary.byteSize;
      hoistableState && hoistHoistables(hoistableState, boundary.contentState);
      segment = boundary.row;
      null !== segment && isEligibleForOutlining(request, boundary) && 0 === --segment.pendingTasks && finishSuspenseListRow(request, segment);
      writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
      segment = boundary.completedSegments;
      if (1 !== segment.length) throw Error(formatProdErrorMessage(391));
      flushSegment(request, destination, segment[0], hoistableState);
    }
    return writeChunkAndReturn(destination, endSuspenseBoundary);
  }
  __name(flushSegment, "flushSegment");
  function flushSegmentContainer(request, destination, segment, hoistableState) {
    writeStartSegment(
      destination,
      request.renderState,
      segment.parentFormatContext,
      segment.id
    );
    flushSegment(request, destination, segment, hoistableState);
    return writeEndSegment(destination, segment.parentFormatContext);
  }
  __name(flushSegmentContainer, "flushSegmentContainer");
  function flushCompletedBoundary(request, destination, boundary) {
    flushedByteSize = boundary.byteSize;
    for (var completedSegments = boundary.completedSegments, i2 = 0; i2 < completedSegments.length; i2++)
      flushPartiallyCompletedSegment(
        request,
        destination,
        boundary,
        completedSegments[i2]
      );
    completedSegments.length = 0;
    completedSegments = boundary.row;
    null !== completedSegments && isEligibleForOutlining(request, boundary) && 0 === --completedSegments.pendingTasks && finishSuspenseListRow(request, completedSegments);
    writeHoistablesForBoundary(
      destination,
      boundary.contentState,
      request.renderState
    );
    completedSegments = request.resumableState;
    request = request.renderState;
    i2 = boundary.rootSegmentID;
    boundary = boundary.contentState;
    var requiresStyleInsertion = request.stylesToHoist;
    request.stylesToHoist = false;
    writeChunk(destination, request.startInlineScript);
    writeChunk(destination, endOfStartTag);
    requiresStyleInsertion ? (0 === (completedSegments.instructions & 4) && (completedSegments.instructions |= 4, writeChunk(destination, clientRenderScriptFunctionOnly)), 0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScriptFunctionOnly)), 0 === (completedSegments.instructions & 8) ? (completedSegments.instructions |= 8, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial)) : (0 === (completedSegments.instructions & 2) && (completedSegments.instructions |= 2, writeChunk(destination, completeBoundaryScriptFunctionOnly)), writeChunk(destination, completeBoundaryScript1Partial));
    completedSegments = stringToChunk(i2.toString(16));
    writeChunk(destination, request.boundaryPrefix);
    writeChunk(destination, completedSegments);
    writeChunk(destination, completeBoundaryScript2);
    writeChunk(destination, request.segmentPrefix);
    writeChunk(destination, completedSegments);
    requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
    boundary = writeChunkAndReturn(destination, completeBoundaryScriptEnd);
    return writeBootstrap(destination, request) && boundary;
  }
  __name(flushCompletedBoundary, "flushCompletedBoundary");
  function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
    if (2 === segment.status) return true;
    var hoistableState = boundary.contentState, segmentID = segment.id;
    if (-1 === segmentID) {
      if (-1 === (segment.id = boundary.rootSegmentID))
        throw Error(formatProdErrorMessage(392));
      return flushSegmentContainer(request, destination, segment, hoistableState);
    }
    if (segmentID === boundary.rootSegmentID)
      return flushSegmentContainer(request, destination, segment, hoistableState);
    flushSegmentContainer(request, destination, segment, hoistableState);
    boundary = request.resumableState;
    request = request.renderState;
    writeChunk(destination, request.startInlineScript);
    writeChunk(destination, endOfStartTag);
    0 === (boundary.instructions & 1) ? (boundary.instructions |= 1, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
    writeChunk(destination, request.segmentPrefix);
    segmentID = stringToChunk(segmentID.toString(16));
    writeChunk(destination, segmentID);
    writeChunk(destination, completeSegmentScript2);
    writeChunk(destination, request.placeholderPrefix);
    writeChunk(destination, segmentID);
    destination = writeChunkAndReturn(destination, completeSegmentScriptEnd);
    return destination;
  }
  __name(flushPartiallyCompletedSegment, "flushPartiallyCompletedSegment");
  var flushingPartialBoundaries = false;
  function flushCompletedQueues(request, destination) {
    currentView = new Uint8Array(2048);
    writtenBytes = 0;
    try {
      if (!(0 < request.pendingRootTasks)) {
        var i2, completedRootSegment = request.completedRootSegment;
        if (null !== completedRootSegment) {
          if (5 === completedRootSegment.status) return;
          var completedPreambleSegments = request.completedPreambleSegments;
          if (null === completedPreambleSegments) return;
          flushedByteSize = request.byteSize;
          var resumableState = request.resumableState, renderState = request.renderState, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
          if (htmlChunks) {
            for (i$jscomp$0 = 0; i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
              writeChunk(destination, htmlChunks[i$jscomp$0]);
            if (headChunks)
              for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
                writeChunk(destination, headChunks[i$jscomp$0]);
            else
              writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
          } else if (headChunks)
            for (i$jscomp$0 = 0; i$jscomp$0 < headChunks.length; i$jscomp$0++)
              writeChunk(destination, headChunks[i$jscomp$0]);
          var charsetChunks = renderState.charsetChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
            writeChunk(destination, charsetChunks[i$jscomp$0]);
          charsetChunks.length = 0;
          renderState.preconnects.forEach(flushResource, destination);
          renderState.preconnects.clear();
          var viewportChunks = renderState.viewportChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
            writeChunk(destination, viewportChunks[i$jscomp$0]);
          viewportChunks.length = 0;
          renderState.fontPreloads.forEach(flushResource, destination);
          renderState.fontPreloads.clear();
          renderState.highImagePreloads.forEach(flushResource, destination);
          renderState.highImagePreloads.clear();
          currentlyFlushingRenderState = renderState;
          renderState.styles.forEach(flushStylesInPreamble, destination);
          currentlyFlushingRenderState = null;
          var importMapChunks = renderState.importMapChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
            writeChunk(destination, importMapChunks[i$jscomp$0]);
          importMapChunks.length = 0;
          renderState.bootstrapScripts.forEach(flushResource, destination);
          renderState.scripts.forEach(flushResource, destination);
          renderState.scripts.clear();
          renderState.bulkPreloads.forEach(flushResource, destination);
          renderState.bulkPreloads.clear();
          htmlChunks || headChunks || (resumableState.instructions |= 32);
          var hoistableChunks = renderState.hoistableChunks;
          for (i$jscomp$0 = 0; i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
            writeChunk(destination, hoistableChunks[i$jscomp$0]);
          for (resumableState = hoistableChunks.length = 0; resumableState < completedPreambleSegments.length; resumableState++) {
            var segments = completedPreambleSegments[resumableState];
            for (renderState = 0; renderState < segments.length; renderState++)
              flushSegment(request, destination, segments[renderState], null);
          }
          var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
          (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
          var bodyChunks = preamble$jscomp$0.bodyChunks;
          if (bodyChunks)
            for (completedPreambleSegments = 0; completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
              writeChunk(destination, bodyChunks[completedPreambleSegments]);
          flushSegment(request, destination, completedRootSegment, null);
          request.completedRootSegment = null;
          var renderState$jscomp$0 = request.renderState;
          if (0 !== request.allPendingTasks || 0 !== request.clientRenderedBoundaries.length || 0 !== request.completedBoundaries.length || null !== request.trackedPostpones && (0 !== request.trackedPostpones.rootNodes.length || null !== request.trackedPostpones.rootSlots)) {
            var resumableState$jscomp$0 = request.resumableState;
            if (0 === (resumableState$jscomp$0.instructions & 64)) {
              resumableState$jscomp$0.instructions |= 64;
              writeChunk(destination, renderState$jscomp$0.startInlineScript);
              if (0 === (resumableState$jscomp$0.instructions & 32)) {
                resumableState$jscomp$0.instructions |= 32;
                var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
                writeChunk(destination, completedShellIdAttributeStart);
                writeChunk(
                  destination,
                  stringToChunk(escapeTextForBrowser(shellId))
                );
                writeChunk(destination, attributeEnd);
              }
              writeChunk(destination, endOfStartTag);
              writeChunk(destination, shellTimeRuntimeScript);
              writeChunkAndReturn(destination, endInlineScript);
            }
          }
          writeBootstrap(destination, renderState$jscomp$0);
        }
        var renderState$jscomp$1 = request.renderState;
        completedRootSegment = 0;
        var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
        for (completedRootSegment = 0; completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
          writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);
        viewportChunks$jscomp$0.length = 0;
        renderState$jscomp$1.preconnects.forEach(flushResource, destination);
        renderState$jscomp$1.preconnects.clear();
        renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
        renderState$jscomp$1.fontPreloads.clear();
        renderState$jscomp$1.highImagePreloads.forEach(
          flushResource,
          destination
        );
        renderState$jscomp$1.highImagePreloads.clear();
        renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
        renderState$jscomp$1.scripts.forEach(flushResource, destination);
        renderState$jscomp$1.scripts.clear();
        renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
        renderState$jscomp$1.bulkPreloads.clear();
        var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
        for (completedRootSegment = 0; completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
          writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);
        hoistableChunks$jscomp$0.length = 0;
        var clientRenderedBoundaries = request.clientRenderedBoundaries;
        for (i2 = 0; i2 < clientRenderedBoundaries.length; i2++) {
          var boundary = clientRenderedBoundaries[i2];
          renderState$jscomp$1 = destination;
          var resumableState$jscomp$1 = request.resumableState, renderState$jscomp$2 = request.renderState, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest;
          writeChunk(
            renderState$jscomp$1,
            renderState$jscomp$2.startInlineScript
          );
          writeChunk(renderState$jscomp$1, endOfStartTag);
          0 === (resumableState$jscomp$1.instructions & 4) ? (resumableState$jscomp$1.instructions |= 4, writeChunk(renderState$jscomp$1, clientRenderScript1Full)) : writeChunk(renderState$jscomp$1, clientRenderScript1Partial);
          writeChunk(renderState$jscomp$1, renderState$jscomp$2.boundaryPrefix);
          writeChunk(renderState$jscomp$1, stringToChunk(id.toString(16)));
          writeChunk(renderState$jscomp$1, clientRenderScript1A);
          errorDigest && (writeChunk(
            renderState$jscomp$1,
            clientRenderErrorScriptArgInterstitial
          ), writeChunk(
            renderState$jscomp$1,
            stringToChunk(
              escapeJSStringsForInstructionScripts(errorDigest || "")
            )
          ));
          var JSCompiler_inline_result = writeChunkAndReturn(
            renderState$jscomp$1,
            clientRenderScriptEnd
          );
          if (!JSCompiler_inline_result) {
            request.destination = null;
            i2++;
            clientRenderedBoundaries.splice(0, i2);
            return;
          }
        }
        clientRenderedBoundaries.splice(0, i2);
        var completedBoundaries = request.completedBoundaries;
        for (i2 = 0; i2 < completedBoundaries.length; i2++)
          if (!flushCompletedBoundary(request, destination, completedBoundaries[i2])) {
            request.destination = null;
            i2++;
            completedBoundaries.splice(0, i2);
            return;
          }
        completedBoundaries.splice(0, i2);
        completeWriting(destination);
        currentView = new Uint8Array(2048);
        writtenBytes = 0;
        flushingPartialBoundaries = true;
        var partialBoundaries = request.partialBoundaries;
        for (i2 = 0; i2 < partialBoundaries.length; i2++) {
          var boundary$70 = partialBoundaries[i2];
          a: {
            clientRenderedBoundaries = request;
            boundary = destination;
            flushedByteSize = boundary$70.byteSize;
            var completedSegments = boundary$70.completedSegments;
            for (JSCompiler_inline_result = 0; JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
              if (!flushPartiallyCompletedSegment(
                clientRenderedBoundaries,
                boundary,
                boundary$70,
                completedSegments[JSCompiler_inline_result]
              )) {
                JSCompiler_inline_result++;
                completedSegments.splice(0, JSCompiler_inline_result);
                var JSCompiler_inline_result$jscomp$0 = false;
                break a;
              }
            completedSegments.splice(0, JSCompiler_inline_result);
            var row = boundary$70.row;
            null !== row && row.together && 1 === boundary$70.pendingTasks && (1 === row.pendingTasks ? unblockSuspenseListRow(
              clientRenderedBoundaries,
              row,
              row.hoistables
            ) : row.pendingTasks--);
            JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(
              boundary,
              boundary$70.contentState,
              clientRenderedBoundaries.renderState
            );
          }
          if (!JSCompiler_inline_result$jscomp$0) {
            request.destination = null;
            i2++;
            partialBoundaries.splice(0, i2);
            return;
          }
        }
        partialBoundaries.splice(0, i2);
        flushingPartialBoundaries = false;
        var largeBoundaries = request.completedBoundaries;
        for (i2 = 0; i2 < largeBoundaries.length; i2++)
          if (!flushCompletedBoundary(request, destination, largeBoundaries[i2])) {
            request.destination = null;
            i2++;
            largeBoundaries.splice(0, i2);
            return;
          }
        largeBoundaries.splice(0, i2);
      }
    } finally {
      flushingPartialBoundaries = false, 0 === request.allPendingTasks && 0 === request.clientRenderedBoundaries.length && 0 === request.completedBoundaries.length ? (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && writeChunk(destination, endChunkForTag("body")), i2.hasHtml && writeChunk(destination, endChunkForTag("html")), completeWriting(destination), request.status = 14, destination.close(), request.destination = null) : completeWriting(destination);
    }
  }
  __name(flushCompletedQueues, "flushCompletedQueues");
  function startWork(request) {
    request.flushScheduled = null !== request.destination;
    scheduleMicrotask(function() {
      return performWork(request);
    });
    scheduleWork(function() {
      10 === request.status && (request.status = 11);
      null === request.trackedPostpones && safelyEmitEarlyPreloads(request, 0 === request.pendingRootTasks);
    });
  }
  __name(startWork, "startWork");
  function enqueueFlush(request) {
    false === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = true, scheduleWork(function() {
      var destination = request.destination;
      destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
    }));
  }
  __name(enqueueFlush, "enqueueFlush");
  function startFlowing(request, destination) {
    if (13 === request.status)
      request.status = 14, closeWithError(destination, request.fatalError);
    else if (14 !== request.status && null === request.destination) {
      request.destination = destination;
      try {
        flushCompletedQueues(request, destination);
      } catch (error5) {
        logRecoverableError(request, error5, {}), fatalError(request, error5);
      }
    }
  }
  __name(startFlowing, "startFlowing");
  function abort3(request, reason) {
    if (11 === request.status || 10 === request.status) request.status = 12;
    try {
      var abortableTasks = request.abortableTasks;
      if (0 < abortableTasks.size) {
        var error5 = void 0 === reason ? Error(formatProdErrorMessage(432)) : "object" === typeof reason && null !== reason && "function" === typeof reason.then ? Error(formatProdErrorMessage(530)) : reason;
        request.fatalError = error5;
        abortableTasks.forEach(function(task) {
          return abortTask(task, request, error5);
        });
        abortableTasks.clear();
      }
      null !== request.destination && flushCompletedQueues(request, request.destination);
    } catch (error$72) {
      logRecoverableError(request, error$72, {}), fatalError(request, error$72);
    }
  }
  __name(abort3, "abort");
  function addToReplayParent(node, parentKeyPath, trackedPostpones) {
    if (null === parentKeyPath) trackedPostpones.rootNodes.push(node);
    else {
      var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
      void 0 === parentNode && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
      parentNode[2].push(node);
    }
  }
  __name(addToReplayParent, "addToReplayParent");
  function getPostponedState(request) {
    var trackedPostpones = request.trackedPostpones;
    if (null === trackedPostpones || 0 === trackedPostpones.rootNodes.length && null === trackedPostpones.rootSlots)
      return request.trackedPostpones = null;
    if (null === request.completedRootSegment || 5 !== request.completedRootSegment.status && null !== request.completedPreambleSegments) {
      var nextSegmentId = request.nextSegmentId;
      var replaySlots = trackedPostpones.rootSlots;
      var resumableState = request.resumableState;
      resumableState.bootstrapScriptContent = void 0;
      resumableState.bootstrapScripts = void 0;
      resumableState.bootstrapModules = void 0;
    } else {
      nextSegmentId = 0;
      replaySlots = -1;
      resumableState = request.resumableState;
      var renderState = request.renderState;
      resumableState.nextFormID = 0;
      resumableState.hasBody = false;
      resumableState.hasHtml = false;
      resumableState.unknownResources = { font: renderState.resets.font };
      resumableState.dnsResources = renderState.resets.dns;
      resumableState.connectResources = renderState.resets.connect;
      resumableState.imageResources = renderState.resets.image;
      resumableState.styleResources = renderState.resets.style;
      resumableState.scriptResources = {};
      resumableState.moduleUnknownResources = {};
      resumableState.moduleScriptResources = {};
      resumableState.instructions = 0;
    }
    return {
      nextSegmentId,
      rootFormatContext: request.rootFormatContext,
      progressiveChunkSize: request.progressiveChunkSize,
      resumableState: request.resumableState,
      replayNodes: trackedPostpones.rootNodes,
      replaySlots
    };
  }
  __name(getPostponedState, "getPostponedState");
  function ensureCorrectIsomorphicReactVersion() {
    var isomorphicReactPackageVersion = React2.version;
    if ("19.2.3" !== isomorphicReactPackageVersion)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion,
          "19.2.3"
        )
      );
  }
  __name(ensureCorrectIsomorphicReactVersion, "ensureCorrectIsomorphicReactVersion");
  ensureCorrectIsomorphicReactVersion();
  ensureCorrectIsomorphicReactVersion();
  reactDomServer_browser_production.prerender = function(children, options) {
    return new Promise(function(resolve, reject) {
      var onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
      onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {
        onHeaders(new Headers(headersDescriptor));
      }, "onHeadersImpl"));
      var resources = createResumableState(
        options ? options.identifierPrefix : void 0,
        options ? options.unstable_externalRuntimeSrc : void 0,
        options ? options.bootstrapScriptContent : void 0,
        options ? options.bootstrapScripts : void 0,
        options ? options.bootstrapModules : void 0
      ), request = createPrerenderRequest(
        children,
        resources,
        createRenderState(
          resources,
          void 0,
          options ? options.unstable_externalRuntimeSrc : void 0,
          options ? options.importMap : void 0,
          onHeadersImpl,
          options ? options.maxHeadersLength : void 0
        ),
        createRootFormatContext(options ? options.namespaceURI : void 0),
        options ? options.progressiveChunkSize : void 0,
        options ? options.onError : void 0,
        function() {
          var stream = new ReadableStream(
            {
              type: "bytes",
              pull: /* @__PURE__ */ __name(function(controller) {
                startFlowing(request, controller);
              }, "pull"),
              cancel: /* @__PURE__ */ __name(function(reason) {
                request.destination = null;
                abort3(request, reason);
              }, "cancel")
            },
            { highWaterMark: 0 }
          );
          stream = { postponed: getPostponedState(request), prelude: stream };
          resolve(stream);
        },
        void 0,
        void 0,
        reject,
        options ? options.onPostpone : void 0
      );
      if (options && options.signal) {
        var signal = options.signal;
        if (signal.aborted) abort3(request, signal.reason);
        else {
          var listener = /* @__PURE__ */ __name(function() {
            abort3(request, signal.reason);
            signal.removeEventListener("abort", listener);
          }, "listener");
          signal.addEventListener("abort", listener);
        }
      }
      startWork(request);
    });
  };
  reactDomServer_browser_production.renderToReadableStream = function(children, options) {
    return new Promise(function(resolve, reject) {
      var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
        onAllReady = res;
        onFatalError = rej;
      }), onHeaders = options ? options.onHeaders : void 0, onHeadersImpl;
      onHeaders && (onHeadersImpl = /* @__PURE__ */ __name(function(headersDescriptor) {
        onHeaders(new Headers(headersDescriptor));
      }, "onHeadersImpl"));
      var resumableState = createResumableState(
        options ? options.identifierPrefix : void 0,
        options ? options.unstable_externalRuntimeSrc : void 0,
        options ? options.bootstrapScriptContent : void 0,
        options ? options.bootstrapScripts : void 0,
        options ? options.bootstrapModules : void 0
      ), request = createRequest2(
        children,
        resumableState,
        createRenderState(
          resumableState,
          options ? options.nonce : void 0,
          options ? options.unstable_externalRuntimeSrc : void 0,
          options ? options.importMap : void 0,
          onHeadersImpl,
          options ? options.maxHeadersLength : void 0
        ),
        createRootFormatContext(options ? options.namespaceURI : void 0),
        options ? options.progressiveChunkSize : void 0,
        options ? options.onError : void 0,
        onAllReady,
        function() {
          var stream = new ReadableStream(
            {
              type: "bytes",
              pull: /* @__PURE__ */ __name(function(controller) {
                startFlowing(request, controller);
              }, "pull"),
              cancel: /* @__PURE__ */ __name(function(reason) {
                request.destination = null;
                abort3(request, reason);
              }, "cancel")
            },
            { highWaterMark: 0 }
          );
          stream.allReady = allReady;
          resolve(stream);
        },
        function(error5) {
          allReady.catch(function() {
          });
          reject(error5);
        },
        onFatalError,
        options ? options.onPostpone : void 0,
        options ? options.formState : void 0
      );
      if (options && options.signal) {
        var signal = options.signal;
        if (signal.aborted) abort3(request, signal.reason);
        else {
          var listener = /* @__PURE__ */ __name(function() {
            abort3(request, signal.reason);
            signal.removeEventListener("abort", listener);
          }, "listener");
          signal.addEventListener("abort", listener);
        }
      }
      startWork(request);
    });
  };
  reactDomServer_browser_production.resume = function(children, postponedState, options) {
    return new Promise(function(resolve, reject) {
      var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
        onAllReady = res;
        onFatalError = rej;
      }), request = resumeRequest(
        children,
        postponedState,
        createRenderState(
          postponedState.resumableState,
          options ? options.nonce : void 0,
          void 0,
          void 0,
          void 0,
          void 0
        ),
        options ? options.onError : void 0,
        onAllReady,
        function() {
          var stream = new ReadableStream(
            {
              type: "bytes",
              pull: /* @__PURE__ */ __name(function(controller) {
                startFlowing(request, controller);
              }, "pull"),
              cancel: /* @__PURE__ */ __name(function(reason) {
                request.destination = null;
                abort3(request, reason);
              }, "cancel")
            },
            { highWaterMark: 0 }
          );
          stream.allReady = allReady;
          resolve(stream);
        },
        function(error5) {
          allReady.catch(function() {
          });
          reject(error5);
        },
        onFatalError,
        options ? options.onPostpone : void 0
      );
      if (options && options.signal) {
        var signal = options.signal;
        if (signal.aborted) abort3(request, signal.reason);
        else {
          var listener = /* @__PURE__ */ __name(function() {
            abort3(request, signal.reason);
            signal.removeEventListener("abort", listener);
          }, "listener");
          signal.addEventListener("abort", listener);
        }
      }
      startWork(request);
    });
  };
  reactDomServer_browser_production.resumeAndPrerender = function(children, postponedState, options) {
    return new Promise(function(resolve, reject) {
      var request = resumeAndPrerenderRequest(
        children,
        postponedState,
        createRenderState(
          postponedState.resumableState,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0
        ),
        options ? options.onError : void 0,
        function() {
          var stream = new ReadableStream(
            {
              type: "bytes",
              pull: /* @__PURE__ */ __name(function(controller) {
                startFlowing(request, controller);
              }, "pull"),
              cancel: /* @__PURE__ */ __name(function(reason) {
                request.destination = null;
                abort3(request, reason);
              }, "cancel")
            },
            { highWaterMark: 0 }
          );
          stream = { postponed: getPostponedState(request), prelude: stream };
          resolve(stream);
        },
        void 0,
        void 0,
        reject,
        options ? options.onPostpone : void 0
      );
      if (options && options.signal) {
        var signal = options.signal;
        if (signal.aborted) abort3(request, signal.reason);
        else {
          var listener = /* @__PURE__ */ __name(function() {
            abort3(request, signal.reason);
            signal.removeEventListener("abort", listener);
          }, "listener");
          signal.addEventListener("abort", listener);
        }
      }
      startWork(request);
    });
  };
  reactDomServer_browser_production.version = "19.2.3";
  return reactDomServer_browser_production;
}
function requireServer_browser() {
  if (hasRequiredServer_browser) return server_browser;
  hasRequiredServer_browser = 1;
  var l, s2;
  {
    l = requireReactDomServerLegacy_browser_production();
    s2 = requireReactDomServer_browser_production();
  }
  server_browser.version = l.version;
  server_browser.renderToString = l.renderToString;
  server_browser.renderToStaticMarkup = l.renderToStaticMarkup;
  server_browser.renderToReadableStream = s2.renderToReadableStream;
  server_browser.resume = s2.resume;
  return server_browser;
}
function getContext(rendererContextResult) {
  if (contexts.has(rendererContextResult)) {
    return contexts.get(rendererContextResult);
  }
  const ctx = {
    currentIndex: 0,
    get id() {
      return ID_PREFIX + this.currentIndex.toString();
    }
  };
  contexts.set(rendererContextResult, ctx);
  return ctx;
}
function incrementId(rendererContextResult) {
  const ctx = getContext(rendererContextResult);
  const id = ctx.id;
  ctx.currentIndex++;
  return id;
}
async function check(Component, props, children) {
  if (typeof Component === "object") {
    return Component["$$typeof"].toString().slice("Symbol(".length).startsWith("react");
  }
  if (typeof Component !== "function") return false;
  if (Component.name === "QwikComponent") return false;
  if (typeof Component === "function" && Component["$$typeof"] === Symbol.for("react.forward_ref"))
    return false;
  if (Component.prototype != null && typeof Component.prototype.render === "function") {
    return React.Component.isPrototypeOf(Component) || React.PureComponent.isPrototypeOf(Component);
  }
  let isReactComponent = false;
  function Tester(...args) {
    try {
      const vnode = Component(...args);
      if (vnode && (vnode["$$typeof"] === reactTypeof || vnode["$$typeof"] === reactTransitionalTypeof)) {
        isReactComponent = true;
      }
    } catch {
    }
    return React.createElement("div");
  }
  __name(Tester, "Tester");
  await renderToStaticMarkup.call(this, Tester, props, children);
  return isReactComponent;
}
async function getNodeWritable() {
  let nodeStreamBuiltinModuleName = "node:stream";
  let { Writable: Writable3 } = await import(
    /* @vite-ignore */
    nodeStreamBuiltinModuleName
  );
  return Writable3;
}
function needsHydration(metadata) {
  return metadata?.astroStaticSlot ? !!metadata.hydrate : true;
}
async function renderToStaticMarkup(Component, props, { default: children, ...slotted }, metadata) {
  let prefix;
  if (this && this.result) {
    prefix = incrementId(this.result);
  }
  const attrs = { prefix };
  delete props["class"];
  const slots = {};
  for (const [key, value] of Object.entries(slotted)) {
    const name = slotName(key);
    slots[name] = React.createElement(static_html_default, {
      hydrate: needsHydration(metadata),
      value,
      name
    });
  }
  const newProps = {
    ...props,
    ...slots
  };
  const newChildren = children ?? props.children;
  if (newChildren != null) {
    newProps.children = React.createElement(static_html_default, {
      hydrate: needsHydration(metadata),
      value: newChildren
    });
  }
  const formState = this ? await getFormState(this) : void 0;
  if (formState) {
    attrs["data-action-result"] = JSON.stringify(formState[0]);
    attrs["data-action-key"] = formState[1];
    attrs["data-action-name"] = formState[2];
  }
  const vnode = React.createElement(Component, newProps);
  const renderOptions = {
    identifierPrefix: prefix,
    formState
  };
  let html;
  if ("renderToReadableStream" in ReactDOM) {
    html = await renderToReadableStreamAsync(vnode, renderOptions);
  } else {
    html = await renderToPipeableStreamAsync(vnode, renderOptions);
  }
  return { html, attrs };
}
async function getFormState({
  result
}) {
  const { request, actionResult } = result;
  if (!actionResult) return void 0;
  if (!isFormRequest(request.headers.get("content-type"))) return void 0;
  const { searchParams } = new URL(request.url);
  const formData = await request.clone().formData();
  const actionKey = formData.get("$ACTION_KEY")?.toString();
  const actionName = searchParams.get("_action");
  if (!actionKey || !actionName) return void 0;
  return [actionResult, actionKey, actionName];
}
async function renderToPipeableStreamAsync(vnode, options) {
  const Writable3 = await getNodeWritable();
  let html = "";
  return new Promise((resolve, reject) => {
    let error5 = void 0;
    let stream = ReactDOM.renderToPipeableStream(vnode, {
      ...options,
      onError(err) {
        error5 = err;
        reject(error5);
      },
      onAllReady() {
        stream.pipe(
          new Writable3({
            write(chunk, _encoding, callback) {
              html += chunk.toString("utf-8");
              callback();
            },
            destroy() {
              resolve(html);
            }
          })
        );
      }
    });
  });
}
async function readResult(stream) {
  const reader = stream.getReader();
  let result = "";
  const decoder4 = new TextDecoder("utf-8");
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      if (value) {
        result += decoder4.decode(value);
      } else {
        decoder4.decode(new Uint8Array());
      }
      return result;
    }
    result += decoder4.decode(value, { stream: true });
  }
}
async function renderToReadableStreamAsync(vnode, options) {
  return await readResult(await ReactDOM.renderToReadableStream(vnode, options));
}
function isFormRequest(contentType) {
  const type = contentType?.split(";")[0].toLowerCase();
  return formContentTypes.some((t2) => type === t2);
}
var MessagePort4, MessageChannelPolyfill3, react, react_production, hasRequiredReact_production, hasRequiredReact, reactExports, React, server_browser, reactDomServerLegacy_browser_production, reactDom, reactDom_production, hasRequiredReactDom_production, hasRequiredReactDom, hasRequiredReactDomServerLegacy_browser_production, reactDomServer_browser_production, hasRequiredReactDomServer_browser_production, hasRequiredServer_browser, server_browserExports, ReactDOM, contexts, ID_PREFIX, StaticHtml, static_html_default, slotName, reactTypeof, reactTransitionalTypeof, formContentTypes, renderer, server_default, renderers;
var init_renderers = __esm({
  ".wrangler/tmp/pages-AQW1MV/renderers.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    react = { exports: {} };
    react_production = {};
    __name(requireReact_production, "requireReact_production");
    __name(requireReact, "requireReact");
    reactExports = requireReact();
    React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    server_browser = {};
    reactDomServerLegacy_browser_production = {};
    reactDom = { exports: {} };
    reactDom_production = {};
    __name(requireReactDom_production, "requireReactDom_production");
    __name(requireReactDom, "requireReactDom");
    __name(requireReactDomServerLegacy_browser_production, "requireReactDomServerLegacy_browser_production");
    reactDomServer_browser_production = {};
    __name(requireReactDomServer_browser_production, "requireReactDomServer_browser_production");
    __name(requireServer_browser, "requireServer_browser");
    server_browserExports = requireServer_browser();
    ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(server_browserExports);
    contexts = /* @__PURE__ */ new WeakMap();
    ID_PREFIX = "r";
    __name(getContext, "getContext");
    __name(incrementId, "incrementId");
    StaticHtml = /* @__PURE__ */ __name(({
      value,
      name,
      hydrate = true
    }) => {
      if (!value) return null;
      const tagName = hydrate ? "astro-slot" : "astro-static-slot";
      return reactExports.createElement(tagName, {
        name,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: { __html: value }
      });
    }, "StaticHtml");
    StaticHtml.shouldComponentUpdate = () => false;
    static_html_default = StaticHtml;
    slotName = /* @__PURE__ */ __name((str) => str.trim().replace(/[-_]([a-z])/g, (_, w) => w.toUpperCase()), "slotName");
    reactTypeof = Symbol.for("react.element");
    reactTransitionalTypeof = Symbol.for("react.transitional.element");
    __name(check, "check");
    __name(getNodeWritable, "getNodeWritable");
    __name(needsHydration, "needsHydration");
    __name(renderToStaticMarkup, "renderToStaticMarkup");
    __name(getFormState, "getFormState");
    __name(renderToPipeableStreamAsync, "renderToPipeableStreamAsync");
    __name(readResult, "readResult");
    __name(renderToReadableStreamAsync, "renderToReadableStreamAsync");
    formContentTypes = ["application/x-www-form-urlencoded", "multipart/form-data"];
    __name(isFormRequest, "isFormRequest");
    renderer = {
      name: "@astrojs/react",
      check,
      renderToStaticMarkup,
      supportsAstroStaticSlot: true
    };
    server_default = renderer;
    renderers = [Object.assign({ "name": "@astrojs/react", "clientEntrypoint": "@astrojs/react/client.js", "serverEntrypoint": "@astrojs/react/server.js" }, { ssr: server_default })];
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/path_BA-Tke6N.mjs
function appendForwardSlash(path3) {
  return path3.endsWith("/") ? path3 : path3 + "/";
}
function prependForwardSlash(path3) {
  return path3[0] === "/" ? path3 : "/" + path3;
}
function collapseDuplicateTrailingSlashes(path3, trailingSlash) {
  if (!path3) {
    return path3;
  }
  return path3.replace(MANY_TRAILING_SLASHES, trailingSlash ? "/" : "") || "/";
}
function removeTrailingForwardSlash(path3) {
  return path3.endsWith("/") ? path3.slice(0, path3.length - 1) : path3;
}
function removeLeadingForwardSlash(path3) {
  return path3.startsWith("/") ? path3.substring(1) : path3;
}
function trimSlashes(path3) {
  return path3.replace(/^\/|\/$/g, "");
}
function isString(path3) {
  return typeof path3 === "string" || path3 instanceof String;
}
function isInternalPath(path3) {
  return INTERNAL_PREFIXES.has(path3.slice(0, 2)) && !JUST_SLASHES.test(path3);
}
function joinPaths(...paths) {
  return paths.filter(isString).map((path3, i2) => {
    if (i2 === 0) {
      return removeTrailingForwardSlash(path3);
    } else if (i2 === paths.length - 1) {
      return removeLeadingForwardSlash(path3);
    } else {
      return trimSlashes(path3);
    }
  }).join("/");
}
function isRemotePath(src) {
  if (!src) return false;
  const trimmed = src.trim();
  if (!trimmed) return false;
  let decoded = trimmed;
  let previousDecoded = "";
  let maxIterations = 10;
  while (decoded !== previousDecoded && maxIterations > 0) {
    previousDecoded = decoded;
    try {
      decoded = decodeURIComponent(decoded);
    } catch {
      break;
    }
    maxIterations--;
  }
  if (/^[a-zA-Z]:/.test(decoded)) {
    return false;
  }
  if (decoded[0] === "/" && decoded[1] !== "/" && decoded[1] !== "\\") {
    return false;
  }
  if (decoded[0] === "\\") {
    return true;
  }
  if (decoded.startsWith("//")) {
    return true;
  }
  try {
    const url = new URL(decoded, "http://n");
    if (url.username || url.password) {
      return true;
    }
    if (decoded.includes("@") && !url.pathname.includes("@") && !url.search.includes("@")) {
      return true;
    }
    if (url.origin !== "http://n") {
      const protocol = url.protocol.toLowerCase();
      if (protocol === "file:") {
        return false;
      }
      return true;
    }
    if (URL.canParse(decoded)) {
      return true;
    }
    return false;
  } catch {
    return true;
  }
}
function slash(path3) {
  return path3.replace(/\\/g, "/");
}
function fileExtension(path3) {
  const ext = path3.split(".").pop();
  return ext !== path3 ? `.${ext}` : "";
}
function hasFileExtension(path3) {
  return WITH_FILE_EXT.test(path3);
}
var MessagePort4, MessageChannelPolyfill3, MANY_TRAILING_SLASHES, INTERNAL_PREFIXES, JUST_SLASHES, WITH_FILE_EXT;
var init_path_BA_Tke6N = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/path_BA-Tke6N.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(appendForwardSlash, "appendForwardSlash");
    __name(prependForwardSlash, "prependForwardSlash");
    MANY_TRAILING_SLASHES = /\/{2,}$/g;
    __name(collapseDuplicateTrailingSlashes, "collapseDuplicateTrailingSlashes");
    __name(removeTrailingForwardSlash, "removeTrailingForwardSlash");
    __name(removeLeadingForwardSlash, "removeLeadingForwardSlash");
    __name(trimSlashes, "trimSlashes");
    __name(isString, "isString");
    INTERNAL_PREFIXES = /* @__PURE__ */ new Set(["/_", "/@", "/.", "//"]);
    JUST_SLASHES = /^\/{2,}$/;
    __name(isInternalPath, "isInternalPath");
    __name(joinPaths, "joinPaths");
    __name(isRemotePath, "isRemotePath");
    __name(slash, "slash");
    __name(fileExtension, "fileExtension");
    WITH_FILE_EXT = /\/[^/]+\.\w+$/;
    __name(hasFileExtension, "hasFileExtension");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/remote_DLFRGwa-.mjs
function matchPattern(url, remotePattern) {
  return matchProtocol(url, remotePattern.protocol) && matchHostname(url, remotePattern.hostname, true) && matchPort(url, remotePattern.port) && matchPathname(url, remotePattern.pathname, true);
}
function matchPort(url, port) {
  return !port || port === url.port;
}
function matchProtocol(url, protocol) {
  return !protocol || protocol === url.protocol.slice(0, -1);
}
function matchHostname(url, hostname, allowWildcard = false) {
  if (!hostname) {
    return true;
  } else if (!allowWildcard || !hostname.startsWith("*")) {
    return hostname === url.hostname;
  } else if (hostname.startsWith("**.")) {
    const slicedHostname = hostname.slice(2);
    return slicedHostname !== url.hostname && url.hostname.endsWith(slicedHostname);
  } else if (hostname.startsWith("*.")) {
    const slicedHostname = hostname.slice(1);
    if (!url.hostname.endsWith(slicedHostname)) {
      return false;
    }
    const subdomainWithDot = url.hostname.slice(0, -(slicedHostname.length - 1));
    return subdomainWithDot.endsWith(".") && !subdomainWithDot.slice(0, -1).includes(".");
  }
  return false;
}
function matchPathname(url, pathname, allowWildcard = false) {
  if (!pathname) {
    return true;
  } else if (!allowWildcard || !pathname.endsWith("*")) {
    return pathname === url.pathname;
  } else if (pathname.endsWith("/**")) {
    const slicedPathname = pathname.slice(0, -2);
    return slicedPathname !== url.pathname && url.pathname.startsWith(slicedPathname);
  } else if (pathname.endsWith("/*")) {
    const slicedPathname = pathname.slice(0, -1);
    const additionalPathChunks = url.pathname.replace(slicedPathname, "").split("/").filter(Boolean);
    return additionalPathChunks.length === 1;
  }
  return false;
}
function isRemoteAllowed(src, {
  domains,
  remotePatterns
}) {
  if (!URL.canParse(src)) {
    return false;
  }
  const url = new URL(src);
  if (!["http:", "https:", "data:"].includes(url.protocol)) {
    return false;
  }
  return domains.some((domain3) => matchHostname(url, domain3)) || remotePatterns.some((remotePattern) => matchPattern(url, remotePattern));
}
var MessagePort4, MessageChannelPolyfill3;
var init_remote_DLFRGwa = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/remote_DLFRGwa-.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(matchPattern, "matchPattern");
    __name(matchPort, "matchPort");
    __name(matchProtocol, "matchProtocol");
    __name(matchHostname, "matchHostname");
    __name(matchPathname, "matchPathname");
    __name(isRemoteAllowed, "isRemoteAllowed");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/astro-designed-error-pages_B6wD2ieN.mjs
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i2) + replacement;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    binaryString += String.fromCharCode(dv.getUint8(i2));
  }
  return binaryToAscii(binaryString);
}
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    dv.setUint8(i2, binaryString.charCodeAt(i2));
  }
  return arraybuffer;
}
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i2]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
function binaryToAscii(str) {
  let out = "";
  for (let i2 = 0; i2 < str.length; i2 += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i2) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i2) & 3) << 4;
    if (str.length > i2 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i2 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i2 + 1) & 15) << 2;
    }
    if (str.length > i2 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i2 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i2 + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index2, standalone = false) {
    if (index2 === UNDEFINED) return void 0;
    if (index2 === NAN) return NaN;
    if (index2 === POSITIVE_INFINITY) return Infinity;
    if (index2 === NEGATIVE_INFINITY) return -Infinity;
    if (index2 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index2 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index2 in hydrated) return hydrated[index2];
    const value = values[index2];
    if (!value || typeof value !== "object") {
      hydrated[index2] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers && Object.hasOwn(revivers, type) ? revivers[type] : void 0;
        if (reviver) {
          let i2 = value[1];
          if (typeof i2 !== "number") {
            i2 = values.push(value[1]) - 1;
          }
          return hydrated[index2] = reviver(hydrate(i2));
        }
        switch (type) {
          case "Date":
            hydrated[index2] = new Date(value[1]);
            break;
          case "Set":
            const set = /* @__PURE__ */ new Set();
            hydrated[index2] = set;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set.add(hydrate(value[i2]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index2] = map;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map.set(hydrate(value[i2]), hydrate(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index2] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index2] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index2] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index2] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate(value[i2 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index2] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index2] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index2] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index2] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index2] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array = new Array(value.length);
        hydrated[index2] = array;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n2 = value[i2];
          if (n2 === HOLE) continue;
          array[i2] = hydrate(n2);
        }
      }
    } else {
      const object = {};
      hydrated[index2] = object;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n2 = value[key];
        object[key] = hydrate(n2);
      }
    }
    return hydrated[index2];
  }
  __name(hydrate, "hydrate");
  return hydrate(0);
}
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key, fn: reducers[key] });
    }
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index3 = p++;
    indexes.set(thing, index3);
    for (const { key, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index3] = `["${key}",${flatten(value2)}]`;
        return index3;
      }
    }
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys, thing, value);
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0) str += ",";
            if (i2 in thing) {
              keys.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`
            );
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a2 = thing.byteOffset;
          const b = a2 + thing.byteLength;
          if (a2 > 0 || b !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a2 / m},${b / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys,
              thing,
              value
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys,
              thing,
              value
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index3] = str;
    return index3;
  }
  __name(flatten, "flatten");
  const index2 = flatten(value);
  if (index2 < 0) return `${index2}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
function isActionError(error5) {
  return typeof error5 === "object" && error5 != null && "type" in error5 && error5.type === "AstroActionError";
}
function isInputError(error5) {
  return typeof error5 === "object" && error5 != null && "type" in error5 && error5.type === "AstroActionInputError" && "issues" in error5 && Array.isArray(error5.issues);
}
function getActionQueryString(name) {
  const searchParams = new URLSearchParams({ [ACTION_QUERY_PARAMS$1.actionName]: name });
  return `?${searchParams.toString()}`;
}
function serializeActionResult(res) {
  if (res.error) {
    if (Object.assign(__vite_import_meta_env__, {})?.DEV) {
      actionResultErrorStack.set(res.error.stack);
    }
    let body2;
    if (res.error instanceof ActionInputError) {
      body2 = {
        type: res.error.type,
        issues: res.error.issues,
        fields: res.error.fields
      };
    } else {
      body2 = {
        ...res.error,
        message: res.error.message
      };
    }
    return {
      type: "error",
      status: res.error.status,
      contentType: "application/json",
      body: JSON.stringify(body2)
    };
  }
  if (res.data === void 0) {
    return {
      type: "empty",
      status: 204
    };
  }
  let body;
  try {
    body = stringify(res.data, {
      // Add support for URL objects
      URL: /* @__PURE__ */ __name((value) => value instanceof URL && value.href, "URL")
    });
  } catch (e2) {
    let hint = ActionsReturnedInvalidDataError.hint;
    if (res.data instanceof Response) {
      hint = REDIRECT_STATUS_CODES.includes(res.data.status) ? "If you need to redirect when the action succeeds, trigger a redirect where the action is called. See the Actions guide for server and client redirect examples: https://docs.astro.build/en/guides/actions." : "If you need to return a Response object, try using a server endpoint instead. See https://docs.astro.build/en/guides/endpoints/#server-endpoints-api-routes";
    }
    throw new AstroError({
      ...ActionsReturnedInvalidDataError,
      message: ActionsReturnedInvalidDataError.message(String(e2)),
      hint
    });
  }
  return {
    type: "data",
    status: 200,
    contentType: "application/json+devalue",
    body
  };
}
function deserializeActionResult(res) {
  if (res.type === "error") {
    let json;
    try {
      json = JSON.parse(res.body);
    } catch {
      return {
        data: void 0,
        error: new ActionError({
          message: res.body,
          code: "INTERNAL_SERVER_ERROR"
        })
      };
    }
    if (Object.assign(__vite_import_meta_env__, {})?.PROD) {
      return { error: ActionError.fromJson(json), data: void 0 };
    } else {
      const error5 = ActionError.fromJson(json);
      error5.stack = actionResultErrorStack.get();
      return {
        error: error5,
        data: void 0
      };
    }
  }
  if (res.type === "empty") {
    return { data: void 0, error: void 0 };
  }
  return {
    data: parse(res.body, {
      URL: /* @__PURE__ */ __name((href) => new URL(href), "URL")
    }),
    error: void 0
  };
}
function template({
  title: title3,
  pathname,
  statusCode = 404,
  tabTitle,
  body
}) {
  return `<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>${tabTitle}</title>
		<style>
			:root {
				--gray-10: hsl(258, 7%, 10%);
				--gray-20: hsl(258, 7%, 20%);
				--gray-30: hsl(258, 7%, 30%);
				--gray-40: hsl(258, 7%, 40%);
				--gray-50: hsl(258, 7%, 50%);
				--gray-60: hsl(258, 7%, 60%);
				--gray-70: hsl(258, 7%, 70%);
				--gray-80: hsl(258, 7%, 80%);
				--gray-90: hsl(258, 7%, 90%);
				--black: #13151A;
				--accent-light: #E0CCFA;
			}

			* {
				box-sizing: border-box;
			}

			html {
				background: var(--black);
				color-scheme: dark;
				accent-color: var(--accent-light);
			}

			body {
				background-color: var(--gray-10);
				color: var(--gray-80);
				font-family: ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;
				line-height: 1.5;
				margin: 0;
			}

			a {
				color: var(--accent-light);
			}

			.center {
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				height: 100vh;
				width: 100vw;
			}

			h1 {
				margin-bottom: 8px;
				color: white;
				font-family: system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
				font-weight: 700;
				margin-top: 1rem;
				margin-bottom: 0;
			}

			.statusCode {
				color: var(--accent-light);
			}

			.astro-icon {
				height: 124px;
				width: 124px;
			}

			pre, code {
				padding: 2px 8px;
				background: rgba(0,0,0, 0.25);
				border: 1px solid rgba(255,255,255, 0.25);
				border-radius: 4px;
				font-size: 1.2em;
				margin-top: 0;
				max-width: 60em;
			}
		</style>
	</head>
	<body>
		<main class="center">
			<svg class="astro-icon" xmlns="http://www.w3.org/2000/svg" width="64" height="80" viewBox="0 0 64 80" fill="none"> <path d="M20.5253 67.6322C16.9291 64.3531 15.8793 57.4632 17.3776 52.4717C19.9755 55.6188 23.575 56.6157 27.3035 57.1784C33.0594 58.0468 38.7122 57.722 44.0592 55.0977C44.6709 54.7972 45.2362 54.3978 45.9045 53.9931C46.4062 55.4451 46.5368 56.9109 46.3616 58.4028C45.9355 62.0362 44.1228 64.8429 41.2397 66.9705C40.0868 67.8215 38.8669 68.5822 37.6762 69.3846C34.0181 71.8508 33.0285 74.7426 34.403 78.9491C34.4357 79.0516 34.4649 79.1541 34.5388 79.4042C32.6711 78.5705 31.3069 77.3565 30.2674 75.7604C29.1694 74.0757 28.6471 72.2121 28.6196 70.1957C28.6059 69.2144 28.6059 68.2244 28.4736 67.257C28.1506 64.8985 27.0406 63.8425 24.9496 63.7817C22.8036 63.7192 21.106 65.0426 20.6559 67.1268C20.6215 67.2865 20.5717 67.4446 20.5218 67.6304L20.5253 67.6322Z" fill="white"/> <path d="M20.5253 67.6322C16.9291 64.3531 15.8793 57.4632 17.3776 52.4717C19.9755 55.6188 23.575 56.6157 27.3035 57.1784C33.0594 58.0468 38.7122 57.722 44.0592 55.0977C44.6709 54.7972 45.2362 54.3978 45.9045 53.9931C46.4062 55.4451 46.5368 56.9109 46.3616 58.4028C45.9355 62.0362 44.1228 64.8429 41.2397 66.9705C40.0868 67.8215 38.8669 68.5822 37.6762 69.3846C34.0181 71.8508 33.0285 74.7426 34.403 78.9491C34.4357 79.0516 34.4649 79.1541 34.5388 79.4042C32.6711 78.5705 31.3069 77.3565 30.2674 75.7604C29.1694 74.0757 28.6471 72.2121 28.6196 70.1957C28.6059 69.2144 28.6059 68.2244 28.4736 67.257C28.1506 64.8985 27.0406 63.8425 24.9496 63.7817C22.8036 63.7192 21.106 65.0426 20.6559 67.1268C20.6215 67.2865 20.5717 67.4446 20.5218 67.6304L20.5253 67.6322Z" fill="url(#paint0_linear_738_686)"/> <path d="M0 51.6401C0 51.6401 10.6488 46.4654 21.3274 46.4654L29.3786 21.6102C29.6801 20.4082 30.5602 19.5913 31.5538 19.5913C32.5474 19.5913 33.4275 20.4082 33.7289 21.6102L41.7802 46.4654C54.4274 46.4654 63.1076 51.6401 63.1076 51.6401C63.1076 51.6401 45.0197 2.48776 44.9843 2.38914C44.4652 0.935933 43.5888 0 42.4073 0H20.7022C19.5206 0 18.6796 0.935933 18.1251 2.38914C18.086 2.4859 0 51.6401 0 51.6401Z" fill="white"/> <defs> <linearGradient id="paint0_linear_738_686" x1="31.554" y1="75.4423" x2="39.7462" y2="48.376" gradientUnits="userSpaceOnUse"> <stop stop-color="#D83333"/> <stop offset="1" stop-color="#F041FF"/> </linearGradient> </defs> </svg>
			<h1>${statusCode ? `<span class="statusCode">${statusCode}: </span> ` : ""}<span class="statusMessage">${title3}</span></h1>
			${body || `
				<pre>Path: ${escape(pathname)}</pre>
			`}
			</main>
	</body>
</html>`;
}
function ensure404Route(manifest2) {
  if (!manifest2.routes.some((route) => route.route === "/404")) {
    manifest2.routes.push(DEFAULT_404_ROUTE);
  }
  return manifest2;
}
async function default404Page({ pathname }) {
  return new Response(
    template({
      statusCode: 404,
      title: "Not found",
      tabTitle: "404: Not Found",
      pathname
    }),
    { status: 404, headers: { "Content-Type": "text/html" } }
  );
}
var MessagePort4, MessageChannelPolyfill3, ImportType, E, DevalueError, object_proto_names, is_identifier, KEY_STRING, UNDEFINED, HOLE, NAN, POSITIVE_INFINITY, NEGATIVE_INFINITY, NEGATIVE_ZERO, ACTION_QUERY_PARAMS$1, ACTION_RPC_ROUTE_PATTERN, __vite_import_meta_env__, ACTION_QUERY_PARAMS, codeToStatusMap, statusToCodeMap, ActionError, ActionInputError, actionResultErrorStack, DEFAULT_404_ROUTE, default404Instance;
var init_astro_designed_error_pages_B6wD2ieN = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/astro-designed-error-pages_B6wD2ieN.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    !(function(A) {
      A[A.Static = 1] = "Static", A[A.Dynamic = 2] = "Dynamic", A[A.ImportMeta = 3] = "ImportMeta", A[A.StaticSourcePhase = 4] = "StaticSourcePhase", A[A.DynamicSourcePhase = 5] = "DynamicSourcePhase", A[A.StaticDeferPhase = 6] = "StaticDeferPhase", A[A.DynamicDeferPhase = 7] = "DynamicDeferPhase";
    })(ImportType || (ImportType = {}));
    1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    E = /* @__PURE__ */ __name(() => {
      return A = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKzkQwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQuFDAEKf0EAQQAoArAKIgBBDGoiATYCsApBARApIQJBACgCsAohAwJAAkACQAJAAkACQAJAAkAgAkEuRw0AQQAgA0ECajYCsAoCQEEBECkiAkHkAEYNAAJAIAJB8wBGDQAgAkHtAEcNB0EAKAKwCiICQQJqQZwIQQYQLw0HAkBBACgCnAoiAxAqDQAgAy8BAEEuRg0ICyAAIAAgAkEIakEAKALUCRABDwtBACgCsAoiAkECakGiCEEKEC8NBgJAQQAoApwKIgMQKg0AIAMvAQBBLkYNBwtBACEEQQAgAkEMajYCsApBASEFQQUhBkEBECkhAkEAIQdBASEIDAILQQAoArAKIgIpAAJC5YCYg9CMgDlSDQUCQEEAKAKcCiIDECoNACADLwEAQS5GDQYLQQAhBEEAIAJBCmo2ArAKQQIhCEEHIQZBASEHQQEQKSECQQEhBQwBCwJAAkACQAJAIAJB8wBHDQAgAyABTQ0AIANBAmpBoghBChAvDQACQCADLwEMIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAgsgBEGgAUYNAQtBACEHQQchBkEBIQQgAkHkAEYNAQwCC0EAIQRBACADQQxqIgI2ArAKQQEhBUEBECkhCQJAQQAoArAKIgYgAkYNAEHmACECAkAgCUHmAEYNAEEFIQZBACEHQQEhCCAJIQIMBAtBACEHQQEhCCAGQQJqQawIQQYQLw0EIAYvAQgQIEUNBAtBACEHQQAgAzYCsApBByEGQQEhBEEAIQVBACEIIAkhAgwCCyADIABBCmpNDQBBACEIQeQAIQICQCADKQACQuWAmIPQjIA5Ug0AAkACQCADLwEKIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAQtBACEIIARBoAFHDQELQQAhBUEAIANBCmo2ArAKQSohAkEBIQdBAiEIQQEQKSIJQSpGDQRBACADNgKwCkEBIQRBACEHQQAhCCAJIQIMAgsgAyEGQQAhBwwCC0EAIQVBACEICwJAIAJBKEcNAEEAKAKkCkEALwGYCiICQQN0aiIDQQAoArAKNgIEQQAgAkEBajsBmAogA0EFNgIAQQAoApwKLwEAQS5GDQRBAEEAKAKwCiIDQQJqNgKwCkEBECkhAiAAQQAoArAKQQAgAxABAkACQCAFDQBBACgC8AkhAQwBC0EAKALwCSIBIAY2AhwLQQBBAC8BlgoiA0EBajsBlgpBACgCqAogA0ECdGogATYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKwCkF+ajYCsAoPCyACEBpBAEEAKAKwCkECaiICNgKwCgJAAkACQEEBEClBV2oOBAECAgACC0EAQQAoArAKQQJqNgKwCkEBECkaQQAoAvAJIgMgAjYCBCADQQE6ABggA0EAKAKwCiICNgIQQQAgAkF+ajYCsAoPC0EAKALwCSIDIAI2AgQgA0EBOgAYQQBBAC8BmApBf2o7AZgKIANBACgCsApBAmo2AgxBAEEALwGWCkF/ajsBlgoPC0EAQQAoArAKQX5qNgKwCg8LAkAgBEEBcyACQfsAR3INAEEAKAKwCiECQQAvAZgKDQUDQAJAAkACQCACQQAoArQKTw0AQQEQKSICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKwCkECajYCsAoLQQEQKSEDQQAoArAKIQICQCADQeYARw0AIAJBAmpBrAhBBhAvDQcLQQAgAkEIajYCsAoCQEEBECkiAkEiRg0AIAJBJ0cNBwsgACACQQAQKw8LIAIQGgtBAEEAKAKwCkECaiICNgKwCgwACwsCQAJAIAJBWWoOBAMBAQMACyACQSJGDQILQQAoArAKIQYLIAYgAUcNAEEAIABBCmo2ArAKDwsgAkEqRyAHcQ0DQQAvAZgKQf//A3ENA0EAKAKwCiECQQAoArQKIQEDQCACIAFPDQECQAJAIAIvAQAiA0EnRg0AIANBIkcNAQsgACADIAgQKw8LQQAgAkECaiICNgKwCgwACwsQJQsPC0EAIAJBfmo2ArAKDwtBAEEAKAKwCkF+ajYCsAoLRwEDf0EAKAKwCkECaiEAQQAoArQKIQECQANAIAAiAkF+aiABTw0BIAJBAmohACACLwEAQXZqDgQBAAABAAsLQQAgAjYCsAoLmAEBA39BAEEAKAKwCiIBQQJqNgKwCiABQQZqIQFBACgCtAohAgNAAkACQAJAIAFBfGogAk8NACABQX5qLwEAIQMCQAJAIAANACADQSpGDQEgA0F2ag4EAgQEAgQLIANBKkcNAwsgAS8BAEEvRw0CQQAgAUF+ajYCsAoMAQsgAUF+aiEBC0EAIAE2ArAKDwsgAUECaiEBDAALC4gBAQR/QQAoArAKIQFBACgCtAohAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoOBAIBAQIBCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArAKECUPC0EAIAE2ArAKC2wBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEEpRyAAQVhqQf//A3FBB0lxDQACQCAAQaV/ag4EAQAAAQALIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQsuAQF/QQEhAQJAIABBpglBBRAdDQAgAEGWCEEDEB0NACAAQbAJQQIQHSEBCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALcCSIFSQ0AIAAgASACEC8NAAJAIAAgBUcNAEEBDwsgBBAmIQMLIAMLgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQbwJQQYQHQ8LIABBfmovAQBBPUYPCyAAQX5qQbQJQQQQHQ8LIABBfmpByAlBAxAdDwtBACEBCyABC7QDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQAJAIAAvAQBBnH9qDhQAAQIJCQkJAwkJBAUJCQYJBwkJCAkLAkACQCAAQX5qLwEAQZd/ag4EAAoKAQoLIABBfGpByghBAhAdDwsgAEF8akHOCEEDEB0PCwJAAkACQCAAQX5qLwEAQY1/ag4DAAECCgsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCiAAQXpqQeUAECcPCyAAQXpqQeMAECcPCyAAQXxqQdQIQQQQHQ8LIABBfGpB3AhBBhAdDwsgAEF+ai8BAEHvAEcNBiAAQXxqLwEAQeUARw0GAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQcgAEF4akHoCEEGEB0PCyAAQXhqQfQIQQIQHQ8LIABBfmpB+AhBBBAdDwtBASEBIABBfmoiAEHpABAnDQQgAEGACUEFEB0PCyAAQX5qQeQAECcPCyAAQX5qQYoJQQcQHQ8LIABBfmpBmAlBBBAdDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECcPCyAAQXxqQaAJQQMQHSEBCyABCzQBAX9BASEBAkAgAEF3akH//wNxQQVJDQAgAEGAAXJBoAFGDQAgAEEuRyAAEChxIQELIAELMAEBfwJAAkAgAEF3aiIBQRdLDQBBASABdEGNgIAEcQ0BCyAAQaABRg0AQQAPC0EBC04BAn9BACEBAkACQCAALwEAIgJB5QBGDQAgAkHrAEcNASAAQX5qQfgIQQQQHQ8LIABBfmovAQBB9QBHDQAgAEF8akHcCEEGEB0hAQsgAQveAQEEf0EAKAKwCiEAQQAoArQKIQECQAJAAkADQCAAIgJBAmohACACIAFPDQECQAJAAkAgAC8BACIDQaR/ag4FAgMDAwEACyADQSRHDQIgAi8BBEH7AEcNAkEAIAJBBGoiADYCsApBAEEALwGYCiICQQFqOwGYCkEAKAKkCiACQQN0aiICQQQ2AgAgAiAANgIEDwtBACAANgKwCkEAQQAvAZgKQX9qIgA7AZgKQQAoAqQKIABB//8DcUEDdGooAgBBA0cNAwwECyACQQRqIQAMAAsLQQAgADYCsAoLECULC3ABAn8CQAJAA0BBAEEAKAKwCiIAQQJqIgE2ArAKIABBACgCtApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLhoMAQtBACAAQQRqNgKwCgwACwsQJQsLNQEBf0EAQQE6APwJQQAoArAKIQBBAEEAKAK0CkECajYCsApBACAAQQAoAtwJa0EBdTYCkAoLQwECf0EBIQECQCAALwEAIgJBd2pB//8DcUEFSQ0AIAJBgAFyQaABRg0AQQAhASACEChFDQAgAkEuRyAAECpyDwsgAQs9AQJ/QQAhAgJAQQAoAtwJIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQICECCyACC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC5wBAQN/QQAoArAKIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAYDAILIAAQGQwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQIUUNAwwBCyACQaABRw0CC0EAQQAoArAKIgNBAmoiATYCsAogA0EAKAK0CkkNAAsLIAILMQEBf0EAIQECQCAALwEAQS5HDQAgAEF+ai8BAEEuRw0AIABBfGovAQBBLkYhAQsgAQumBAEBfwJAIAFBIkYNACABQSdGDQAQJQ8LQQAoArAKIQMgARAaIAAgA0ECakEAKAKwCkEAKALQCRABAkAgAkEBSA0AQQAoAvAJQQRBBiACQQFGGzYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQIMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhAiABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIAJBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiACECA0BBACACQQJqNgKwCgJAAkACQEEBECkiAkEiRg0AIAJBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQIMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSECDAELIAIQLCECCwJAIAJBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAkEiRg0AIAJBJ0YNAEEAIAE2ArAKDwsgAhAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAkEsRg0AIAJB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiECDAELC0EAKALwCSIBIAA2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A, "base64") : Uint8Array.from(atob(A), ((A2) => A2.charCodeAt(0)));
      var A;
    }, "E");
    WebAssembly.compile(E()).then(WebAssembly.instantiate).then((({ exports: A }) => {
    }));
    DevalueError = class extends Error {
      static {
        __name(this, "DevalueError");
      }
      /**
       * @param {string} message
       * @param {string[]} keys
       * @param {any} [value] - The value that failed to be serialized
       * @param {any} [root] - The root value being serialized
       */
      constructor(message2, keys, value, root) {
        super(message2);
        this.name = "DevalueError";
        this.path = keys.join("");
        this.value = value;
        this.root = root;
      }
    };
    __name(is_primitive, "is_primitive");
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
    __name(is_plain_object, "is_plain_object");
    __name(get_type, "get_type");
    __name(get_escaped_char, "get_escaped_char");
    __name(stringify_string, "stringify_string");
    __name(enumerable_symbols, "enumerable_symbols");
    is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    __name(stringify_key, "stringify_key");
    __name(encode64, "encode64");
    __name(decode64, "decode64");
    KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    __name(asciiToBinary, "asciiToBinary");
    __name(binaryToAscii, "binaryToAscii");
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
    __name(parse, "parse");
    __name(unflatten, "unflatten");
    __name(stringify, "stringify");
    __name(stringify_primitive, "stringify_primitive");
    ACTION_QUERY_PARAMS$1 = {
      actionName: "_action"
    };
    ACTION_RPC_ROUTE_PATTERN = "/_actions/[...path]";
    __vite_import_meta_env__ = { "ASSETS_PREFIX": void 0, "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SITE": "https://localhost:4321", "SSR": true };
    ACTION_QUERY_PARAMS = ACTION_QUERY_PARAMS$1;
    codeToStatusMap = {
      // Implemented from IANA HTTP Status Code Registry
      // https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      CONTENT_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_CONTENT: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      NETWORK_AUTHENTICATION_REQUIRED: 511
    };
    statusToCodeMap = Object.entries(codeToStatusMap).reduce(
      // reverse the key-value pairs
      (acc, [key, value]) => ({ ...acc, [value]: key }),
      {}
    );
    ActionError = class _ActionError extends Error {
      static {
        __name(this, "ActionError");
      }
      type = "AstroActionError";
      code = "INTERNAL_SERVER_ERROR";
      status = 500;
      constructor(params) {
        super(params.message);
        this.code = params.code;
        this.status = _ActionError.codeToStatus(params.code);
        if (params.stack) {
          this.stack = params.stack;
        }
      }
      static codeToStatus(code) {
        return codeToStatusMap[code];
      }
      static statusToCode(status) {
        return statusToCodeMap[status] ?? "INTERNAL_SERVER_ERROR";
      }
      static fromJson(body) {
        if (isInputError(body)) {
          return new ActionInputError(body.issues);
        }
        if (isActionError(body)) {
          return new _ActionError(body);
        }
        return new _ActionError({
          code: "INTERNAL_SERVER_ERROR"
        });
      }
    };
    __name(isActionError, "isActionError");
    __name(isInputError, "isInputError");
    ActionInputError = class extends ActionError {
      static {
        __name(this, "ActionInputError");
      }
      type = "AstroActionInputError";
      // We don't expose all ZodError properties.
      // Not all properties will serialize from server to client,
      // and we don't want to import the full ZodError object into the client.
      issues;
      fields;
      constructor(issues) {
        super({
          message: `Failed to validate: ${JSON.stringify(issues, null, 2)}`,
          code: "BAD_REQUEST"
        });
        this.issues = issues;
        this.fields = {};
        for (const issue of issues) {
          if (issue.path.length > 0) {
            const key = issue.path[0].toString();
            this.fields[key] ??= [];
            this.fields[key]?.push(issue.message);
          }
        }
      }
    };
    __name(getActionQueryString, "getActionQueryString");
    __name(serializeActionResult, "serializeActionResult");
    __name(deserializeActionResult, "deserializeActionResult");
    actionResultErrorStack = /* @__PURE__ */ (/* @__PURE__ */ __name((function actionResultErrorStackFn() {
      let errorStack;
      return {
        set(stack) {
          errorStack = stack;
        },
        get() {
          return errorStack;
        }
      };
    }), "actionResultErrorStackFn"))();
    __name(template, "template");
    DEFAULT_404_ROUTE = {
      component: DEFAULT_404_COMPONENT,
      generate: /* @__PURE__ */ __name(() => "", "generate"),
      params: [],
      pattern: /^\/404\/?$/,
      prerender: false,
      pathname: "/404",
      segments: [[{ content: "404", dynamic: false, spread: false }]],
      type: "page",
      route: "/404",
      fallbackRoutes: [],
      isIndex: false,
      origin: "internal"
    };
    __name(ensure404Route, "ensure404Route");
    __name(default404Page, "default404Page");
    default404Page.isAstroComponentFactory = true;
    default404Instance = {
      default: default404Page
    };
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/index_DjxFTAWA.mjs
function hasContentType(contentType, expected) {
  const type = contentType.split(";")[0].toLowerCase();
  return expected.some((t2) => type === t2);
}
function hasActionPayload(locals) {
  return "_actionPayload" in locals;
}
function createGetActionResult(locals) {
  return (actionFn) => {
    if (!hasActionPayload(locals) || actionFn.toString() !== getActionQueryString(locals._actionPayload.actionName)) {
      return void 0;
    }
    return deserializeActionResult(locals._actionPayload.actionResult);
  };
}
function createCallAction(context3) {
  return (baseAction, input) => {
    Reflect.set(context3, ACTION_API_CONTEXT_SYMBOL, true);
    const action = baseAction.bind(context3);
    return action(input);
  };
}
function shouldAppendForwardSlash(trailingSlash, buildFormat) {
  switch (trailingSlash) {
    case "always":
      return true;
    case "never":
      return false;
    case "ignore": {
      switch (buildFormat) {
        case "directory":
          return true;
        case "preserve":
        case "file":
          return false;
      }
    }
  }
}
function redirectIsExternal(redirect) {
  if (typeof redirect === "string") {
    return redirect.startsWith("http://") || redirect.startsWith("https://");
  } else {
    return redirect.destination.startsWith("http://") || redirect.destination.startsWith("https://");
  }
}
async function renderRedirect(renderContext) {
  const {
    request: { method },
    routeData
  } = renderContext;
  const { redirect, redirectRoute } = routeData;
  const status = redirectRoute && typeof redirect === "object" ? redirect.status : method === "GET" ? 301 : 308;
  const headers = { location: encodeURI(redirectRouteGenerate(renderContext)) };
  if (redirect && redirectIsExternal(redirect)) {
    if (typeof redirect === "string") {
      return Response.redirect(redirect, status);
    } else {
      return Response.redirect(redirect.destination, status);
    }
  }
  return new Response(null, { status, headers });
}
function redirectRouteGenerate(renderContext) {
  const {
    params,
    routeData: { redirect, redirectRoute }
  } = renderContext;
  if (typeof redirectRoute !== "undefined") {
    return redirectRoute?.generate(params) || redirectRoute?.pathname || "/";
  } else if (typeof redirect === "string") {
    if (redirectIsExternal(redirect)) {
      return redirect;
    } else {
      let target = redirect;
      for (const param of Object.keys(params)) {
        const paramValue = params[param];
        target = target.replace(`[${param}]`, paramValue).replace(`[...${param}]`, paramValue);
      }
      return target;
    }
  } else if (typeof redirect === "undefined") {
    return "/";
  }
  return redirect.destination;
}
function badRequest(reason) {
  return new Response(null, {
    status: 400,
    statusText: "Bad request: " + reason
  });
}
async function getRequestData(request) {
  switch (request.method) {
    case "GET": {
      const url = new URL(request.url);
      const params = url.searchParams;
      if (!params.has("s") || !params.has("e") || !params.has("p")) {
        return badRequest("Missing required query parameters.");
      }
      const encryptedSlots = params.get("s");
      return {
        componentExport: params.get("e"),
        encryptedProps: params.get("p"),
        encryptedSlots
      };
    }
    case "POST": {
      try {
        const raw = await request.text();
        const data = JSON.parse(raw);
        if ("slots" in data && typeof data.slots === "object") {
          return badRequest("Plaintext slots are not allowed. Slots must be encrypted.");
        }
        return data;
      } catch (e2) {
        if (e2 instanceof SyntaxError) {
          return badRequest("Request format is invalid.");
        }
        throw e2;
      }
    }
    default: {
      return new Response(null, { status: 405 });
    }
  }
}
function createEndpoint(manifest2) {
  const page62 = /* @__PURE__ */ __name(async (result) => {
    const params = result.params;
    if (!params.name) {
      return new Response(null, {
        status: 400,
        statusText: "Bad request"
      });
    }
    const componentId = params.name;
    const data = await getRequestData(result.request);
    if (data instanceof Response) {
      return data;
    }
    const imp = manifest2.serverIslandMap?.get(componentId);
    if (!imp) {
      return new Response(null, {
        status: 404,
        statusText: "Not found"
      });
    }
    const key = await manifest2.key;
    const encryptedProps = data.encryptedProps;
    let props = {};
    if (encryptedProps !== "") {
      try {
        const propString = await decryptString(key, encryptedProps);
        props = JSON.parse(propString);
      } catch (_e) {
        return badRequest("Encrypted props value is invalid.");
      }
    }
    let decryptedSlots = {};
    const encryptedSlots = data.encryptedSlots;
    if (encryptedSlots !== "") {
      try {
        const slotsString = await decryptString(key, encryptedSlots);
        decryptedSlots = JSON.parse(slotsString);
      } catch (_e) {
        return badRequest("Encrypted slots value is invalid.");
      }
    }
    const componentModule = await imp();
    let Component = componentModule[data.componentExport];
    const slots = {};
    for (const prop in decryptedSlots) {
      slots[prop] = createSlotValueFromString(decryptedSlots[prop]);
    }
    result.response.headers.set("X-Robots-Tag", "noindex");
    if (isAstroComponentFactory(Component)) {
      const ServerIsland = Component;
      Component = /* @__PURE__ */ __name(function(...args) {
        return ServerIsland.apply(this, args);
      }, "Component");
      Object.assign(Component, ServerIsland);
      Component.propagation = "self";
    }
    return renderTemplate`${renderComponent(result, "Component", Component, props, slots)}`;
  }, "page");
  page62.isAstroComponentFactory = true;
  const instance = {
    default: page62,
    partial: true
  };
  return instance;
}
function matchRoute(pathname, manifest2) {
  return manifest2.routes.find((route) => {
    return route.pattern.test(pathname) || route.fallbackRoutes.some((fallbackRoute) => fallbackRoute.pattern.test(pathname));
  });
}
function isRoute404(route) {
  return ROUTE404_RE.test(route);
}
function isRoute500(route) {
  return ROUTE500_RE.test(route);
}
function isRoute404or500(route) {
  return isRoute404(route.route) || isRoute500(route.route);
}
function isRouteServerIsland(route) {
  return route.component === SERVER_ISLAND_COMPONENT;
}
function isRequestServerIsland(request, base = "") {
  const url = new URL(request.url);
  const pathname = base === "/" ? url.pathname.slice(base.length) : url.pathname.slice(base.length + 1);
  return pathname.startsWith(SERVER_ISLAND_BASE_PREFIX);
}
function requestIs404Or500(request, base = "") {
  const url = new URL(request.url);
  const pathname = url.pathname.slice(base.length);
  return isRoute404(pathname) || isRoute500(pathname);
}
function isRouteExternalRedirect(route) {
  return !!(route.type === "redirect" && route.redirect && redirectIsExternal(route.redirect));
}
function requestHasLocale(locales) {
  return function(context3) {
    return pathHasLocale(context3.url.pathname, locales);
  };
}
function pathHasLocale(path3, locales) {
  const segments = path3.split("/").map(normalizeThePath);
  for (const segment of segments) {
    for (const locale of locales) {
      if (typeof locale === "string") {
        if (normalizeTheLocale(segment) === normalizeTheLocale(locale)) {
          return true;
        }
      } else if (segment === locale.path) {
        return true;
      }
    }
  }
  return false;
}
function getPathByLocale(locale, locales) {
  for (const loopLocale of locales) {
    if (typeof loopLocale === "string") {
      if (loopLocale === locale) {
        return loopLocale;
      }
    } else {
      for (const code of loopLocale.codes) {
        if (code === locale) {
          return loopLocale.path;
        }
      }
    }
  }
  throw new AstroError(i18nNoLocaleFoundInPath);
}
function normalizeTheLocale(locale) {
  return locale.replaceAll("_", "-").toLowerCase();
}
function normalizeThePath(path3) {
  return path3.endsWith(".html") ? path3.slice(0, -5) : path3;
}
function getAllCodes(locales) {
  const result = [];
  for (const loopLocale of locales) {
    if (typeof loopLocale === "string") {
      result.push(loopLocale);
    } else {
      result.push(...loopLocale.codes);
    }
  }
  return result;
}
function redirectToDefaultLocale({
  trailingSlash,
  format,
  base,
  defaultLocale
}) {
  return function(context3, statusCode) {
    if (shouldAppendForwardSlash(trailingSlash, format)) {
      return context3.redirect(`${appendForwardSlash(joinPaths(base, defaultLocale))}`, statusCode);
    } else {
      return context3.redirect(`${joinPaths(base, defaultLocale)}`, statusCode);
    }
  };
}
function notFound({ base, locales, fallback }) {
  return function(context3, response) {
    if (response?.headers.get(REROUTE_DIRECTIVE_HEADER) === "no" && typeof fallback === "undefined") {
      return response;
    }
    const url = context3.url;
    const isRoot = url.pathname === base + "/" || url.pathname === base;
    if (!(isRoot || pathHasLocale(url.pathname, locales))) {
      if (response) {
        response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
        return new Response(response.body, {
          status: 404,
          headers: response.headers
        });
      } else {
        return new Response(null, {
          status: 404,
          headers: {
            [REROUTE_DIRECTIVE_HEADER]: "no"
          }
        });
      }
    }
    return void 0;
  };
}
function redirectToFallback({
  fallback,
  locales,
  defaultLocale,
  strategy,
  base,
  fallbackType
}) {
  return async function(context3, response) {
    if (response.status >= 300 && fallback) {
      const fallbackKeys = fallback ? Object.keys(fallback) : [];
      const segments = context3.url.pathname.split("/");
      const urlLocale = segments.find((segment) => {
        for (const locale of locales) {
          if (typeof locale === "string") {
            if (locale === segment) {
              return true;
            }
          } else if (locale.path === segment) {
            return true;
          }
        }
        return false;
      });
      if (urlLocale && fallbackKeys.includes(urlLocale)) {
        const fallbackLocale = fallback[urlLocale];
        const pathFallbackLocale = getPathByLocale(fallbackLocale, locales);
        let newPathname;
        if (pathFallbackLocale === defaultLocale && strategy === "pathname-prefix-other-locales") {
          if (context3.url.pathname.includes(`${base}`)) {
            newPathname = context3.url.pathname.replace(`/${urlLocale}`, ``);
            if (newPathname === "") {
              newPathname = "/";
            }
          } else {
            newPathname = context3.url.pathname.replace(`/${urlLocale}`, `/`);
          }
        } else {
          newPathname = context3.url.pathname.replace(`/${urlLocale}`, `/${pathFallbackLocale}`);
        }
        if (fallbackType === "rewrite") {
          return await context3.rewrite(newPathname + context3.url.search);
        } else {
          return context3.redirect(newPathname + context3.url.search);
        }
      }
    }
    return response;
  };
}
function parseLocale(header) {
  if (header === "*") {
    return [{ locale: header, qualityValue: void 0 }];
  }
  const result = [];
  const localeValues = header.split(",").map((str) => str.trim());
  for (const localeValue of localeValues) {
    const split = localeValue.split(";").map((str) => str.trim());
    const localeName = split[0];
    const qualityValue = split[1];
    if (!split) {
      continue;
    }
    if (qualityValue && qualityValue.startsWith("q=")) {
      const qualityValueAsFloat = Number.parseFloat(qualityValue.slice("q=".length));
      if (Number.isNaN(qualityValueAsFloat) || qualityValueAsFloat > 1) {
        result.push({
          locale: localeName,
          qualityValue: void 0
        });
      } else {
        result.push({
          locale: localeName,
          qualityValue: qualityValueAsFloat
        });
      }
    } else {
      result.push({
        locale: localeName,
        qualityValue: void 0
      });
    }
  }
  return result;
}
function sortAndFilterLocales(browserLocaleList, locales) {
  const normalizedLocales = getAllCodes(locales).map(normalizeTheLocale);
  return browserLocaleList.filter((browserLocale) => {
    if (browserLocale.locale !== "*") {
      return normalizedLocales.includes(normalizeTheLocale(browserLocale.locale));
    }
    return true;
  }).sort((a2, b) => {
    if (a2.qualityValue && b.qualityValue) {
      return Math.sign(b.qualityValue - a2.qualityValue);
    }
    return 0;
  });
}
function computePreferredLocale(request, locales) {
  const acceptHeader = request.headers.get("Accept-Language");
  let result = void 0;
  if (acceptHeader) {
    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);
    const firstResult = browserLocaleList.at(0);
    if (firstResult && firstResult.locale !== "*") {
      for (const currentLocale of locales) {
        if (typeof currentLocale === "string") {
          if (normalizeTheLocale(currentLocale) === normalizeTheLocale(firstResult.locale)) {
            result = currentLocale;
            break;
          }
        } else {
          for (const currentCode of currentLocale.codes) {
            if (normalizeTheLocale(currentCode) === normalizeTheLocale(firstResult.locale)) {
              result = currentCode;
              break;
            }
          }
        }
      }
    }
  }
  return result;
}
function computePreferredLocaleList(request, locales) {
  const acceptHeader = request.headers.get("Accept-Language");
  let result = [];
  if (acceptHeader) {
    const browserLocaleList = sortAndFilterLocales(parseLocale(acceptHeader), locales);
    if (browserLocaleList.length === 1 && browserLocaleList.at(0).locale === "*") {
      return getAllCodes(locales);
    } else if (browserLocaleList.length > 0) {
      for (const browserLocale of browserLocaleList) {
        for (const loopLocale of locales) {
          if (typeof loopLocale === "string") {
            if (normalizeTheLocale(loopLocale) === normalizeTheLocale(browserLocale.locale)) {
              result.push(loopLocale);
            }
          } else {
            for (const code of loopLocale.codes) {
              if (code === browserLocale.locale) {
                result.push(code);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
function computeCurrentLocale(pathname, locales, defaultLocale) {
  for (const segment of pathname.split("/").map(normalizeThePath)) {
    for (const locale of locales) {
      if (typeof locale === "string") {
        if (!segment.includes(locale)) continue;
        if (normalizeTheLocale(locale) === normalizeTheLocale(segment)) {
          return locale;
        }
      } else {
        if (locale.path === segment) {
          return locale.codes.at(0);
        } else {
          for (const code of locale.codes) {
            if (normalizeTheLocale(code) === normalizeTheLocale(segment)) {
              return code;
            }
          }
        }
      }
    }
  }
  for (const locale of locales) {
    if (typeof locale === "string") {
      if (locale === defaultLocale) {
        return locale;
      }
    } else {
      if (locale.path === defaultLocale) {
        return locale.codes.at(0);
      }
    }
  }
}
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.parseCookie = parseCookie;
  dist.parse = parseCookie;
  dist.stringifyCookie = stringifyCookie;
  dist.stringifySetCookie = stringifySetCookie;
  dist.serialize = stringifySetCookie;
  dist.parseSetCookie = parseSetCookie;
  dist.stringifySetCookie = stringifySetCookie;
  dist.serialize = stringifySetCookie;
  const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  const maxAgeRegExp = /^-?\d+$/;
  const __toString = Object.prototype.toString;
  const NullObject = /* @__PURE__ */ (() => {
    const C = /* @__PURE__ */ __name(function() {
    }, "C");
    C.prototype = /* @__PURE__ */ Object.create(null);
    return C;
  })();
  function parseCookie(str, options) {
    const obj = new NullObject();
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode2;
    let index2 = 0;
    do {
      const eqIdx = eqIndex(str, index2, len);
      if (eqIdx === -1)
        break;
      const endIdx = endIndex(str, index2, len);
      if (eqIdx > endIdx) {
        index2 = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const key = valueSlice(str, index2, eqIdx);
      if (obj[key] === void 0) {
        obj[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
      }
      index2 = endIdx + 1;
    } while (index2 < len);
    return obj;
  }
  __name(parseCookie, "parseCookie");
  function stringifyCookie(cookie, options) {
    const enc = options?.encode || encodeURIComponent;
    const cookieStrings = [];
    for (const name of Object.keys(cookie)) {
      const val = cookie[name];
      if (val === void 0)
        continue;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`cookie name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`cookie val is invalid: ${val}`);
      }
      cookieStrings.push(`${name}=${value}`);
    }
    return cookieStrings.join("; ");
  }
  __name(stringifyCookie, "stringifyCookie");
  function stringifySetCookie(_name, _val, _opts) {
    const cookie = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
    const options = typeof _val === "object" ? _val : _opts;
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(cookie.name)) {
      throw new TypeError(`argument name is invalid: ${cookie.name}`);
    }
    const value = cookie.value ? enc(cookie.value) : "";
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${cookie.value}`);
    }
    let str = cookie.name + "=" + value;
    if (cookie.maxAge !== void 0) {
      if (!Number.isInteger(cookie.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);
      }
      str += "; Max-Age=" + cookie.maxAge;
    }
    if (cookie.domain) {
      if (!domainValueRegExp.test(cookie.domain)) {
        throw new TypeError(`option domain is invalid: ${cookie.domain}`);
      }
      str += "; Domain=" + cookie.domain;
    }
    if (cookie.path) {
      if (!pathValueRegExp.test(cookie.path)) {
        throw new TypeError(`option path is invalid: ${cookie.path}`);
      }
      str += "; Path=" + cookie.path;
    }
    if (cookie.expires) {
      if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${cookie.expires}`);
      }
      str += "; Expires=" + cookie.expires.toUTCString();
    }
    if (cookie.httpOnly) {
      str += "; HttpOnly";
    }
    if (cookie.secure) {
      str += "; Secure";
    }
    if (cookie.partitioned) {
      str += "; Partitioned";
    }
    if (cookie.priority) {
      const priority = typeof cookie.priority === "string" ? cookie.priority.toLowerCase() : void 0;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${cookie.priority}`);
      }
    }
    if (cookie.sameSite) {
      const sameSite = typeof cookie.sameSite === "string" ? cookie.sameSite.toLowerCase() : cookie.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);
      }
    }
    return str;
  }
  __name(stringifySetCookie, "stringifySetCookie");
  function parseSetCookie(str, options) {
    const dec = options?.decode || decode2;
    const len = str.length;
    const endIdx = endIndex(str, 0, len);
    const eqIdx = eqIndex(str, 0, endIdx);
    const setCookie = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
      name: valueSlice(str, 0, eqIdx),
      value: dec(valueSlice(str, eqIdx + 1, endIdx))
    };
    let index2 = endIdx + 1;
    while (index2 < len) {
      const endIdx2 = endIndex(str, index2, len);
      const eqIdx2 = eqIndex(str, index2, endIdx2);
      const attr = eqIdx2 === -1 ? valueSlice(str, index2, endIdx2) : valueSlice(str, index2, eqIdx2);
      const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
      switch (attr.toLowerCase()) {
        case "httponly":
          setCookie.httpOnly = true;
          break;
        case "secure":
          setCookie.secure = true;
          break;
        case "partitioned":
          setCookie.partitioned = true;
          break;
        case "domain":
          setCookie.domain = val;
          break;
        case "path":
          setCookie.path = val;
          break;
        case "max-age":
          if (val && maxAgeRegExp.test(val))
            setCookie.maxAge = Number(val);
          break;
        case "expires":
          if (!val)
            break;
          const date = new Date(val);
          if (Number.isFinite(date.valueOf()))
            setCookie.expires = date;
          break;
        case "priority":
          if (!val)
            break;
          const priority = val.toLowerCase();
          if (priority === "low" || priority === "medium" || priority === "high") {
            setCookie.priority = priority;
          }
          break;
        case "samesite":
          if (!val)
            break;
          const sameSite = val.toLowerCase();
          if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
            setCookie.sameSite = sameSite;
          }
          break;
      }
      index2 = endIdx2 + 1;
    }
    return setCookie;
  }
  __name(parseSetCookie, "parseSetCookie");
  function endIndex(str, min, len) {
    const index2 = str.indexOf(";", min);
    return index2 === -1 ? len : index2;
  }
  __name(endIndex, "endIndex");
  function eqIndex(str, min, max) {
    const index2 = str.indexOf("=", min);
    return index2 < max ? index2 : -1;
  }
  __name(eqIndex, "eqIndex");
  function valueSlice(str, min, max) {
    let start = min;
    let end = max;
    do {
      const code = str.charCodeAt(start);
      if (code !== 32 && code !== 9)
        break;
    } while (++start < end);
    while (end > start) {
      const code = str.charCodeAt(end - 1);
      if (code !== 32 && code !== 9)
        break;
      end--;
    }
    return str.slice(start, end);
  }
  __name(valueSlice, "valueSlice");
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e2) {
      return str;
    }
  }
  __name(decode2, "decode");
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
  __name(isDate, "isDate");
  return dist;
}
function attachCookiesToResponse(response, cookies) {
  Reflect.set(response, astroCookiesSymbol, cookies);
}
function getCookiesFromResponse(response) {
  let cookies = Reflect.get(response, astroCookiesSymbol);
  if (cookies != null) {
    return cookies;
  } else {
    return void 0;
  }
}
function* getSetCookiesFromResponse(response) {
  const cookies = getCookiesFromResponse(response);
  if (!cookies) {
    return [];
  }
  for (const headerValue of AstroCookies.consume(cookies)) {
    yield headerValue;
  }
  return [];
}
function createRequest({
  url,
  headers,
  method = "GET",
  body = void 0,
  logger,
  isPrerendered = false,
  routePattern,
  init
}) {
  const headersObj = isPrerendered ? void 0 : headers instanceof Headers ? headers : new Headers(
    // Filter out HTTP/2 pseudo-headers. These are internally-generated headers added to all HTTP/2 requests with trusted metadata about the request.
    // Examples include `:method`, `:scheme`, `:authority`, and `:path`.
    // They are always prefixed with a colon to distinguish them from other headers, and it is an error to add the to a Headers object manually.
    // See https://httpwg.org/specs/rfc7540.html#HttpRequest
    Object.entries(headers).filter(([name]) => !name.startsWith(":"))
  );
  if (typeof url === "string") url = new URL(url);
  if (isPrerendered) {
    url.search = "";
  }
  const request = new Request(url, {
    method,
    headers: headersObj,
    // body is made available only if the request is for a page that will be on-demand rendered
    body: isPrerendered ? null : body,
    ...init
  });
  if (isPrerendered) {
    let _headers = request.headers;
    const { value, writable, ...headersDesc } = Object.getOwnPropertyDescriptor(request, "headers") || {};
    Object.defineProperty(request, "headers", {
      ...headersDesc,
      get() {
        logger.warn(
          null,
          `\`Astro.request.headers\` was used when rendering the route \`${routePattern}'\`. \`Astro.request.headers\` is not available on prerendered pages. If you need access to request headers, make sure that the page is server-rendered using \`export const prerender = false;\` or by setting \`output\` to \`"server"\` in your Astro config to make all your pages server-rendered by default.`
        );
        return _headers;
      },
      set(newHeaders) {
        _headers = newHeaders;
      }
    });
  }
  return request;
}
function findRouteToRewrite({
  payload,
  routes: routes2,
  request,
  trailingSlash,
  buildFormat,
  base,
  outDir
}) {
  let newUrl = void 0;
  if (payload instanceof URL) {
    newUrl = payload;
  } else if (payload instanceof Request) {
    newUrl = new URL(payload.url);
  } else {
    newUrl = new URL(payload, new URL(request.url).origin);
  }
  let pathname = newUrl.pathname;
  const shouldAppendSlash = shouldAppendForwardSlash(trailingSlash, buildFormat);
  if (base !== "/") {
    const isBasePathRequest = newUrl.pathname === base || newUrl.pathname === removeTrailingForwardSlash(base);
    if (isBasePathRequest) {
      pathname = shouldAppendSlash ? "/" : "";
    } else if (newUrl.pathname.startsWith(base)) {
      pathname = shouldAppendSlash ? appendForwardSlash(newUrl.pathname) : removeTrailingForwardSlash(newUrl.pathname);
      pathname = pathname.slice(base.length);
    }
  }
  if (!pathname.startsWith("/") && shouldAppendSlash && newUrl.pathname.endsWith("/")) {
    pathname = prependForwardSlash(pathname);
  }
  if (pathname === "/" && base !== "/" && !shouldAppendSlash) {
    pathname = "";
  }
  if (buildFormat === "file") {
    pathname = pathname.replace(/\.html$/, "");
  }
  if (base !== "/" && (pathname === "" || pathname === "/") && !shouldAppendSlash) {
    newUrl.pathname = removeTrailingForwardSlash(base);
  } else {
    newUrl.pathname = joinPaths(...[base, pathname].filter(Boolean));
  }
  const decodedPathname = decodeURI(pathname);
  let foundRoute;
  for (const route of routes2) {
    if (route.pattern.test(decodedPathname)) {
      if (route.params && route.params.length !== 0 && route.distURL && route.distURL.length !== 0) {
        if (!route.distURL.find(
          (url) => url.href.replace(outDir.toString(), "").replace(/(?:\/index\.html|\.html)$/, "") == trimSlashes(decodedPathname)
        )) {
          continue;
        }
      }
      foundRoute = route;
      break;
    }
  }
  if (foundRoute) {
    return {
      routeData: foundRoute,
      newUrl,
      pathname: decodedPathname
    };
  } else {
    const custom404 = routes2.find((route) => route.route === "/404");
    if (custom404) {
      return { routeData: custom404, newUrl, pathname };
    } else {
      return { routeData: DEFAULT_404_ROUTE, newUrl, pathname };
    }
  }
}
function copyRequest(newUrl, oldRequest, isPrerendered, logger, routePattern) {
  if (oldRequest.bodyUsed) {
    throw new AstroError(RewriteWithBodyUsed);
  }
  return createRequest({
    url: newUrl,
    method: oldRequest.method,
    body: oldRequest.body,
    isPrerendered,
    logger,
    headers: isPrerendered ? {} : oldRequest.headers,
    routePattern,
    init: {
      referrer: oldRequest.referrer,
      referrerPolicy: oldRequest.referrerPolicy,
      mode: oldRequest.mode,
      credentials: oldRequest.credentials,
      cache: oldRequest.cache,
      redirect: oldRequest.redirect,
      integrity: oldRequest.integrity,
      signal: oldRequest.signal,
      keepalive: oldRequest.keepalive,
      // https://fetch.spec.whatwg.org/#dom-request-duplex
      // @ts-expect-error It isn't part of the types, but undici accepts it and it allows to carry over the body to a new request
      duplex: "half"
    }
  });
}
function setOriginPathname(request, pathname, trailingSlash, buildFormat) {
  if (!pathname) {
    pathname = "/";
  }
  const shouldAppendSlash = shouldAppendForwardSlash(trailingSlash, buildFormat);
  let finalPathname;
  if (pathname === "/") {
    finalPathname = "/";
  } else if (shouldAppendSlash) {
    finalPathname = appendForwardSlash(pathname);
  } else {
    finalPathname = removeTrailingForwardSlash(pathname);
  }
  Reflect.set(request, originPathnameSymbol, encodeURIComponent(finalPathname));
}
function getOriginPathname(request) {
  const origin = Reflect.get(request, originPathnameSymbol);
  if (origin) {
    return decodeURIComponent(origin);
  }
  return new URL(request.url).pathname;
}
function validateGetStaticPathsParameter([key, value], route) {
  if (!VALID_PARAM_TYPES.includes(typeof value)) {
    throw new AstroError({
      ...GetStaticPathsInvalidRouteParam,
      message: GetStaticPathsInvalidRouteParam.message(key, value, typeof value),
      location: {
        file: route
      }
    });
  }
}
function validateDynamicRouteModule(mod, {
  ssr,
  route
}) {
  if ((!ssr || route.prerender) && !mod.getStaticPaths) {
    throw new AstroError({
      ...GetStaticPathsRequired,
      location: { file: route.component }
    });
  }
}
function validateGetStaticPathsResult(result, logger, route) {
  if (!Array.isArray(result)) {
    throw new AstroError({
      ...InvalidGetStaticPathsReturn,
      message: InvalidGetStaticPathsReturn.message(typeof result),
      location: {
        file: route.component
      }
    });
  }
  result.forEach((pathObject) => {
    if (typeof pathObject === "object" && Array.isArray(pathObject) || pathObject === null) {
      throw new AstroError({
        ...InvalidGetStaticPathsEntry,
        message: InvalidGetStaticPathsEntry.message(
          Array.isArray(pathObject) ? "array" : typeof pathObject
        )
      });
    }
    if (pathObject.params === void 0 || pathObject.params === null || pathObject.params && Object.keys(pathObject.params).length === 0) {
      throw new AstroError({
        ...GetStaticPathsExpectedParams,
        location: {
          file: route.component
        }
      });
    }
    for (const [key, val] of Object.entries(pathObject.params)) {
      if (!(typeof val === "undefined" || typeof val === "string" || typeof val === "number")) {
        logger.warn(
          "router",
          `getStaticPaths() returned an invalid path param: "${key}". A string, number or undefined value was expected, but got \`${JSON.stringify(
            val
          )}\`.`
        );
      }
      if (typeof val === "string" && val === "") {
        logger.warn(
          "router",
          `getStaticPaths() returned an invalid path param: "${key}". \`undefined\` expected for an optional param, but got empty string.`
        );
      }
    }
  });
}
function stringifyParams(params, route) {
  const validatedParams = Object.entries(params).reduce((acc, next) => {
    validateGetStaticPathsParameter(next, route.component);
    const [key, value] = next;
    if (value !== void 0) {
      acc[key] = typeof value === "string" ? trimSlashes(value) : value.toString();
    }
    return acc;
  }, {});
  return route.generate(validatedParams);
}
function generatePaginateFunction(routeMatch, base) {
  return /* @__PURE__ */ __name(function paginateUtility(data, args = {}) {
    let { pageSize: _pageSize, params: _params, props: _props } = args;
    const pageSize = _pageSize || 10;
    const paramName = "page";
    const additionalParams = _params || {};
    const additionalProps = _props || {};
    let includesFirstPageNumber;
    if (routeMatch.params.includes(`...${paramName}`)) {
      includesFirstPageNumber = false;
    } else if (routeMatch.params.includes(`${paramName}`)) {
      includesFirstPageNumber = true;
    } else {
      throw new AstroError({
        ...PageNumberParamNotFound,
        message: PageNumberParamNotFound.message(paramName)
      });
    }
    const lastPage = Math.max(1, Math.ceil(data.length / pageSize));
    const result = [...Array(lastPage).keys()].map((num) => {
      const pageNum = num + 1;
      const start = pageSize === Infinity ? 0 : (pageNum - 1) * pageSize;
      const end = Math.min(start + pageSize, data.length);
      const params = {
        ...additionalParams,
        [paramName]: includesFirstPageNumber || pageNum > 1 ? String(pageNum) : void 0
      };
      const current = addRouteBase(routeMatch.generate({ ...params }), base);
      const next = pageNum === lastPage ? void 0 : addRouteBase(routeMatch.generate({ ...params, page: String(pageNum + 1) }), base);
      const prev = pageNum === 1 ? void 0 : addRouteBase(
        routeMatch.generate({
          ...params,
          page: !includesFirstPageNumber && pageNum - 1 === 1 ? void 0 : String(pageNum - 1)
        }),
        base
      );
      const first = pageNum === 1 ? void 0 : addRouteBase(
        routeMatch.generate({
          ...params,
          page: includesFirstPageNumber ? "1" : void 0
        }),
        base
      );
      const last = pageNum === lastPage ? void 0 : addRouteBase(routeMatch.generate({ ...params, page: String(lastPage) }), base);
      return {
        params,
        props: {
          ...additionalProps,
          page: {
            data: data.slice(start, end),
            start,
            end: end - 1,
            size: pageSize,
            total: data.length,
            currentPage: pageNum,
            lastPage,
            url: { current, next, prev, first, last }
          }
        }
      };
    });
    return result;
  }, "paginateUtility");
}
function addRouteBase(route, base) {
  let routeWithBase = joinPaths(base, route);
  if (routeWithBase === "") routeWithBase = "/";
  return routeWithBase;
}
async function callGetStaticPaths({
  mod,
  route,
  routeCache,
  logger,
  ssr,
  base
}) {
  const cached = routeCache.get(route);
  if (!mod) {
    throw new Error("This is an error caused by Astro and not your code. Please file an issue.");
  }
  if (cached?.staticPaths) {
    return cached.staticPaths;
  }
  validateDynamicRouteModule(mod, { ssr, route });
  if (ssr && !route.prerender) {
    const entry = Object.assign([], { keyed: /* @__PURE__ */ new Map() });
    routeCache.set(route, { ...cached, staticPaths: entry });
    return entry;
  }
  let staticPaths = [];
  if (!mod.getStaticPaths) {
    throw new Error("Unexpected Error.");
  }
  staticPaths = await mod.getStaticPaths({
    // Q: Why the cast?
    // A: So users downstream can have nicer typings, we have to make some sacrifice in our internal typings, which necessitate a cast here
    paginate: generatePaginateFunction(route, base),
    routePattern: route.route
  });
  validateGetStaticPathsResult(staticPaths, logger, route);
  const keyedStaticPaths = staticPaths;
  keyedStaticPaths.keyed = /* @__PURE__ */ new Map();
  for (const sp of keyedStaticPaths) {
    const paramsKey = stringifyParams(sp.params, route);
    keyedStaticPaths.keyed.set(paramsKey, sp);
  }
  routeCache.set(route, { ...cached, staticPaths: keyedStaticPaths });
  return keyedStaticPaths;
}
function findPathItemByKey(staticPaths, params, route, logger) {
  const paramsKey = stringifyParams(params, route);
  const matchedStaticPath = staticPaths.keyed.get(paramsKey);
  if (matchedStaticPath) {
    return matchedStaticPath;
  }
  logger.debug("router", `findPathItemByKey() - Unexpected cache miss looking for ${paramsKey}`);
}
function routeIsRedirect(route) {
  return route?.type === "redirect";
}
function routeIsFallback(route) {
  return route?.type === "fallback";
}
async function getProps(opts) {
  const { logger, mod, routeData: route, routeCache, pathname, serverLike, base } = opts;
  if (!route || route.pathname) {
    return {};
  }
  if (routeIsRedirect(route) || routeIsFallback(route) || route.component === DEFAULT_404_COMPONENT) {
    return {};
  }
  const staticPaths = await callGetStaticPaths({
    mod,
    route,
    routeCache,
    logger,
    ssr: serverLike,
    base
  });
  const params = getParams(route, pathname);
  const matchedStaticPath = findPathItemByKey(staticPaths, params, route, logger);
  if (!matchedStaticPath && (serverLike ? route.prerender : true)) {
    throw new AstroError({
      ...NoMatchingStaticPathFound,
      message: NoMatchingStaticPathFound.message(pathname),
      hint: NoMatchingStaticPathFound.hint([route.component])
    });
  }
  if (mod) {
    validatePrerenderEndpointCollision(route, mod, params);
  }
  const props = matchedStaticPath?.props ? { ...matchedStaticPath.props } : {};
  return props;
}
function getParams(route, pathname) {
  if (!route.params.length) return {};
  const paramsMatch = route.pattern.exec(pathname) || route.fallbackRoutes.map((fallbackRoute) => fallbackRoute.pattern.exec(pathname)).find((x) => x);
  if (!paramsMatch) return {};
  const params = {};
  route.params.forEach((key, i2) => {
    if (key.startsWith("...")) {
      params[key.slice(3)] = paramsMatch[i2 + 1] ? paramsMatch[i2 + 1] : void 0;
    } else {
      params[key] = paramsMatch[i2 + 1];
    }
  });
  return params;
}
function validatePrerenderEndpointCollision(route, mod, params) {
  if (route.type === "endpoint" && mod.getStaticPaths) {
    const lastSegment = route.segments[route.segments.length - 1];
    const paramValues = Object.values(params);
    const lastParam = paramValues[paramValues.length - 1];
    if (lastSegment.length === 1 && lastSegment[0].dynamic && lastParam === void 0) {
      throw new AstroError({
        ...PrerenderDynamicEndpointPathCollide,
        message: PrerenderDynamicEndpointPathCollide.message(route.route),
        hint: PrerenderDynamicEndpointPathCollide.hint(route.component),
        location: {
          file: route.component
        }
      });
    }
  }
}
function getFunctionExpression(slot) {
  if (!slot) return;
  const expressions = slot?.expressions?.filter((e2) => isRenderInstruction(e2) === false);
  if (expressions?.length !== 1) return;
  return expressions[0];
}
function getActionContext(context3) {
  const callerInfo = getCallerInfo(context3);
  const actionResultAlreadySet = Boolean(context3.locals._actionPayload);
  let action = void 0;
  if (callerInfo && context3.request.method === "POST" && !actionResultAlreadySet) {
    action = {
      calledFrom: callerInfo.from,
      name: callerInfo.name,
      handler: /* @__PURE__ */ __name(async () => {
        const pipeline = Reflect.get(context3, apiContextRoutesSymbol);
        const callerInfoName = shouldAppendForwardSlash(
          pipeline.manifest.trailingSlash,
          pipeline.manifest.buildFormat
        ) ? removeTrailingForwardSlash(callerInfo.name) : callerInfo.name;
        let baseAction;
        try {
          baseAction = await pipeline.getAction(callerInfoName);
        } catch (error5) {
          if (error5 instanceof Error && "name" in error5 && typeof error5.name === "string" && error5.name === ActionNotFoundError.name) {
            return { data: void 0, error: new ActionError({ code: "NOT_FOUND" }) };
          }
          throw error5;
        }
        let input;
        try {
          input = await parseRequestBody(context3.request);
        } catch (e2) {
          if (e2 instanceof TypeError) {
            return { data: void 0, error: new ActionError({ code: "UNSUPPORTED_MEDIA_TYPE" }) };
          }
          throw e2;
        }
        const omitKeys = ["props", "getActionResult", "callAction", "redirect"];
        const actionAPIContext = Object.create(
          Object.getPrototypeOf(context3),
          Object.fromEntries(
            Object.entries(Object.getOwnPropertyDescriptors(context3)).filter(
              ([key]) => !omitKeys.includes(key)
            )
          )
        );
        Reflect.set(actionAPIContext, ACTION_API_CONTEXT_SYMBOL, true);
        const handler = baseAction.bind(actionAPIContext);
        return handler(input);
      }, "handler")
    };
  }
  function setActionResult(actionName, actionResult) {
    context3.locals._actionPayload = {
      actionResult,
      actionName
    };
  }
  __name(setActionResult, "setActionResult");
  return {
    action,
    setActionResult,
    serializeActionResult,
    deserializeActionResult
  };
}
function getCallerInfo(ctx) {
  if (ctx.routePattern === ACTION_RPC_ROUTE_PATTERN) {
    return { from: "rpc", name: ctx.url.pathname.replace(/^.*\/_actions\//, "") };
  }
  const queryParam = ctx.url.searchParams.get(ACTION_QUERY_PARAMS.actionName);
  if (queryParam) {
    return { from: "form", name: queryParam };
  }
  return void 0;
}
async function parseRequestBody(request) {
  const contentType = request.headers.get("content-type");
  const contentLength = request.headers.get("Content-Length");
  if (!contentType) return void 0;
  if (hasContentType(contentType, formContentTypes2)) {
    return await request.clone().formData();
  }
  if (hasContentType(contentType, ["application/json"])) {
    return contentLength === "0" ? void 0 : await request.clone().json();
  }
  throw new TypeError("Unsupported content type");
}
function deduplicateDirectiveValues(existingDirective, newDirective) {
  const [directiveName, ...existingValues] = existingDirective.split(/\s+/).filter(Boolean);
  const [newDirectiveName, ...newValues] = newDirective.split(/\s+/).filter(Boolean);
  if (directiveName !== newDirectiveName) {
    return void 0;
  }
  const finalDirectives = Array.from(/* @__PURE__ */ new Set([...existingValues, ...newValues]));
  return `${directiveName} ${finalDirectives.join(" ")}`;
}
function pushDirective(directives, newDirective) {
  let deduplicated = false;
  if (directives.length === 0) {
    return [newDirective];
  }
  const finalDirectives = [];
  for (const directive of directives) {
    if (deduplicated) {
      finalDirectives.push(directive);
      continue;
    }
    const result = deduplicateDirectiveValues(directive, newDirective);
    if (result) {
      finalDirectives.push(result);
      deduplicated = true;
    } else {
      finalDirectives.push(directive);
      finalDirectives.push(newDirective);
    }
  }
  return finalDirectives;
}
async function callMiddleware(onRequest2, apiContext, responseFunction) {
  let nextCalled = false;
  let responseFunctionPromise = void 0;
  const next = /* @__PURE__ */ __name(async (payload) => {
    nextCalled = true;
    responseFunctionPromise = responseFunction(apiContext, payload);
    return responseFunctionPromise;
  }, "next");
  let middlewarePromise = onRequest2(apiContext, next);
  return await Promise.resolve(middlewarePromise).then(async (value) => {
    if (nextCalled) {
      if (typeof value !== "undefined") {
        if (value instanceof Response === false) {
          throw new AstroError(MiddlewareNotAResponse);
        }
        return value;
      } else {
        if (responseFunctionPromise) {
          return responseFunctionPromise;
        } else {
          throw new AstroError(MiddlewareNotAResponse);
        }
      }
    } else if (typeof value === "undefined") {
      throw new AstroError(MiddlewareNoDataOrNextCalled);
    } else if (value instanceof Response === false) {
      throw new AstroError(MiddlewareNotAResponse);
    } else {
      return value;
    }
  });
}
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error5) {
    if (options.strict) {
      throw error5;
    }
    return value;
  }
}
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error5) {
    return Promise.reject(error5);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify$1(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify$1(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c) => c.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
  return normalizeKey(keys.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index2 = key.indexOf(":");
  while (index2 > -1) {
    substrCount++;
    index2 = key.indexOf(":", index2 + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}
function defineDriver(factory) {
  return factory;
}
function createStorage(options = {}) {
  const context3 = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = /* @__PURE__ */ __name((key) => {
    for (const base of context3.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context3.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context3.mounts[""]
    };
  }, "getMount");
  const getMounts = /* @__PURE__ */ __name((base, includeParent) => {
    return context3.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context3.mounts[mountpoint]
    }));
  }, "getMounts");
  const onChange = /* @__PURE__ */ __name((event, key) => {
    if (!context3.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context3.watchListeners) {
      listener(event, key);
    }
  }, "onChange");
  const startWatch = /* @__PURE__ */ __name(async () => {
    if (context3.watching) {
      return;
    }
    context3.watching = true;
    for (const mountpoint in context3.mounts) {
      context3.unwatch[mountpoint] = await watch(
        context3.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  }, "startWatch");
  const stopWatch = /* @__PURE__ */ __name(async () => {
    if (!context3.watching) {
      return;
    }
    for (const mountpoint in context3.unwatch) {
      await context3.unwatch[mountpoint]();
    }
    context3.unwatch = {};
    context3.watching = false;
  }, "stopWatch");
  const runBatch = /* @__PURE__ */ __name((items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = /* @__PURE__ */ __name((mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    }, "getBatch");
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  }, "runBatch");
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify$1(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify$1(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify$1(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!mount.driver.flags?.maxDepth) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p) => fullKey.startsWith(p))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m) => {
          if (m.driver.clear) {
            return asyncCall(m.driver.clear, m.relativeBase, opts);
          }
          if (m.driver.removeItem) {
            const keys = await m.driver.getKeys(m.relativeBase || "", opts);
            return Promise.all(
              keys.map((key) => m.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context3.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context3.watchListeners.push(callback);
      return async () => {
        context3.watchListeners = context3.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context3.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context3.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context3.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context3.mountpoints.push(base);
        context3.mountpoints.sort((a2, b) => b.length - a2.length);
      }
      context3.mounts[base] = driver;
      if (context3.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context3.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context3.mounts[base]) {
        return;
      }
      if (context3.watching && base in context3.unwatch) {
        context3.unwatch[base]?.();
        delete context3.unwatch[base];
      }
      if (_dispose) {
        await dispose(context3.mounts[base]);
      }
      context3.mountpoints = context3.mountpoints.filter((key) => key !== base);
      delete context3.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m = getMount(key);
      return {
        driver: m.driver,
        base: m.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m) => ({
        driver: m.driver,
        base: m.mountpoint
      }));
    },
    // Aliases
    keys: /* @__PURE__ */ __name((base, opts = {}) => storage.getKeys(base, opts), "keys"),
    get: /* @__PURE__ */ __name((key, opts = {}) => storage.getItem(key, opts), "get"),
    set: /* @__PURE__ */ __name((key, value, opts = {}) => storage.setItem(key, value, opts), "set"),
    has: /* @__PURE__ */ __name((key, opts = {}) => storage.hasItem(key, opts), "has"),
    del: /* @__PURE__ */ __name((key, opts = {}) => storage.removeItem(key, opts), "del"),
    remove: /* @__PURE__ */ __name((key, opts = {}) => storage.removeItem(key, opts), "remove")
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}
function resolveSessionDriverName(driver) {
  if (!driver) {
    return null;
  }
  try {
    if (driver === "fs") {
      return builtinDrivers.fsLite;
    }
    if (driver in builtinDrivers) {
      return builtinDrivers[driver];
    }
  } catch {
    return null;
  }
  return driver;
}
function validateAndDecodePathname(pathname) {
  let decoded;
  try {
    decoded = decodeURI(pathname);
  } catch (_e) {
    throw new Error("Invalid URL encoding");
  }
  const hasDecoding = decoded !== pathname;
  const decodedStillHasEncoding = /%[0-9a-fA-F]{2}/.test(decoded);
  if (hasDecoding && decodedStillHasEncoding) {
    throw new Error("Multi-level URL encoding is not allowed");
  }
  return decoded;
}
function sequence(...handlers2) {
  const filtered = handlers2.filter((h) => !!h);
  const length = filtered.length;
  if (!length) {
    return defineMiddleware((_context, next) => {
      return next();
    });
  }
  return defineMiddleware((context3, next) => {
    let carriedPayload = void 0;
    return applyHandle(0, context3);
    function applyHandle(i2, handleContext) {
      const handle2 = filtered[i2];
      const result = handle2(handleContext, async (payload) => {
        if (i2 < length - 1) {
          if (payload) {
            let newRequest;
            if (payload instanceof Request) {
              newRequest = payload;
            } else if (payload instanceof URL) {
              newRequest = new Request(payload, handleContext.request.clone());
            } else {
              newRequest = new Request(
                new URL(payload, handleContext.url.origin),
                handleContext.request.clone()
              );
            }
            const oldPathname = handleContext.url.pathname;
            const pipeline = Reflect.get(handleContext, apiContextRoutesSymbol);
            const { routeData, pathname } = await pipeline.tryRewrite(
              payload,
              handleContext.request
            );
            if (pipeline.serverLike === true && handleContext.isPrerendered === false && routeData.prerender === true) {
              throw new AstroError({
                ...ForbiddenRewrite,
                message: ForbiddenRewrite.message(
                  handleContext.url.pathname,
                  pathname,
                  routeData.component
                ),
                hint: ForbiddenRewrite.hint(routeData.component)
              });
            }
            carriedPayload = payload;
            handleContext.request = newRequest;
            handleContext.url = new URL(newRequest.url);
            handleContext.params = getParams(routeData, pathname);
            handleContext.routePattern = routeData.route;
            setOriginPathname(
              handleContext.request,
              oldPathname,
              pipeline.manifest.trailingSlash,
              pipeline.manifest.buildFormat
            );
          }
          return applyHandle(i2 + 1, handleContext);
        } else {
          return next(payload ?? carriedPayload);
        }
      });
      return result;
    }
    __name(applyHandle, "applyHandle");
  });
}
function defineMiddleware(fn) {
  return fn;
}
var MessagePort4, MessageChannelPolyfill3, ACTION_API_CONTEXT_SYMBOL, formContentTypes2, SERVER_ISLAND_ROUTE, SERVER_ISLAND_COMPONENT, SERVER_ISLAND_BASE_PREFIX, ROUTE404_RE, ROUTE500_RE, dist, hasRequiredDist, distExports, DELETED_EXPIRATION, DELETED_VALUE, responseSentSymbol2, identity, AstroCookie, AstroCookies, astroCookiesSymbol, VALID_PARAM_TYPES, RouteCache, Slots, suspectProtoRx, suspectConstructorRx, JsonSigRx, BASE64_PREFIX, DRIVER_NAME, memory, builtinDrivers, PERSIST_SYMBOL, DEFAULT_COOKIE_NAME, VALID_COOKIE_REGEX, unflatten2, stringify2, AstroSession, apiContextRoutesSymbol, RenderContext;
var init_index_DjxFTAWA = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/index_DjxFTAWA.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_astro_designed_error_pages_B6wD2ieN();
    init_path_BA_Tke6N();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    ACTION_API_CONTEXT_SYMBOL = Symbol.for("astro.actionAPIContext");
    formContentTypes2 = ["application/x-www-form-urlencoded", "multipart/form-data"];
    __name(hasContentType, "hasContentType");
    __name(hasActionPayload, "hasActionPayload");
    __name(createGetActionResult, "createGetActionResult");
    __name(createCallAction, "createCallAction");
    __name(shouldAppendForwardSlash, "shouldAppendForwardSlash");
    __name(redirectIsExternal, "redirectIsExternal");
    __name(renderRedirect, "renderRedirect");
    __name(redirectRouteGenerate, "redirectRouteGenerate");
    SERVER_ISLAND_ROUTE = "/_server-islands/[name]";
    SERVER_ISLAND_COMPONENT = "_server-islands.astro";
    SERVER_ISLAND_BASE_PREFIX = "_server-islands";
    __name(badRequest, "badRequest");
    __name(getRequestData, "getRequestData");
    __name(createEndpoint, "createEndpoint");
    __name(matchRoute, "matchRoute");
    ROUTE404_RE = /^\/404\/?$/;
    ROUTE500_RE = /^\/500\/?$/;
    __name(isRoute404, "isRoute404");
    __name(isRoute500, "isRoute500");
    __name(isRoute404or500, "isRoute404or500");
    __name(isRouteServerIsland, "isRouteServerIsland");
    __name(isRequestServerIsland, "isRequestServerIsland");
    __name(requestIs404Or500, "requestIs404Or500");
    __name(isRouteExternalRedirect, "isRouteExternalRedirect");
    __name(requestHasLocale, "requestHasLocale");
    __name(pathHasLocale, "pathHasLocale");
    __name(getPathByLocale, "getPathByLocale");
    __name(normalizeTheLocale, "normalizeTheLocale");
    __name(normalizeThePath, "normalizeThePath");
    __name(getAllCodes, "getAllCodes");
    __name(redirectToDefaultLocale, "redirectToDefaultLocale");
    __name(notFound, "notFound");
    __name(redirectToFallback, "redirectToFallback");
    __name(parseLocale, "parseLocale");
    __name(sortAndFilterLocales, "sortAndFilterLocales");
    __name(computePreferredLocale, "computePreferredLocale");
    __name(computePreferredLocaleList, "computePreferredLocaleList");
    __name(computeCurrentLocale, "computeCurrentLocale");
    dist = {};
    __name(requireDist, "requireDist");
    distExports = /* @__PURE__ */ requireDist();
    DELETED_EXPIRATION = /* @__PURE__ */ new Date(0);
    DELETED_VALUE = "deleted";
    responseSentSymbol2 = Symbol.for("astro.responseSent");
    identity = /* @__PURE__ */ __name((value) => value, "identity");
    AstroCookie = class {
      static {
        __name(this, "AstroCookie");
      }
      constructor(value) {
        this.value = value;
      }
      json() {
        if (this.value === void 0) {
          throw new Error(`Cannot convert undefined to an object.`);
        }
        return JSON.parse(this.value);
      }
      number() {
        return Number(this.value);
      }
      boolean() {
        if (this.value === "false") return false;
        if (this.value === "0") return false;
        return Boolean(this.value);
      }
    };
    AstroCookies = class {
      static {
        __name(this, "AstroCookies");
      }
      #request;
      #requestValues;
      #outgoing;
      #consumed;
      constructor(request) {
        this.#request = request;
        this.#requestValues = null;
        this.#outgoing = null;
        this.#consumed = false;
      }
      /**
       * Astro.cookies.delete(key) is used to delete a cookie. Using this method will result
       * in a Set-Cookie header added to the response.
       * @param key The cookie to delete
       * @param options Options related to this deletion, such as the path of the cookie.
       */
      delete(key, options) {
        const {
          // @ts-expect-error
          maxAge: _ignoredMaxAge,
          // @ts-expect-error
          expires: _ignoredExpires,
          ...sanitizedOptions
        } = options || {};
        const serializeOptions = {
          expires: DELETED_EXPIRATION,
          ...sanitizedOptions
        };
        this.#ensureOutgoingMap().set(key, [
          DELETED_VALUE,
          distExports.serialize(key, DELETED_VALUE, serializeOptions),
          false
        ]);
      }
      /**
       * Astro.cookies.get(key) is used to get a cookie value. The cookie value is read from the
       * request. If you have set a cookie via Astro.cookies.set(key, value), the value will be taken
       * from that set call, overriding any values already part of the request.
       * @param key The cookie to get.
       * @returns An object containing the cookie value as well as convenience methods for converting its value.
       */
      get(key, options = void 0) {
        if (this.#outgoing?.has(key)) {
          let [serializedValue, , isSetValue] = this.#outgoing.get(key);
          if (isSetValue) {
            return new AstroCookie(serializedValue);
          } else {
            return void 0;
          }
        }
        const decode2 = options?.decode ?? decodeURIComponent;
        const values = this.#ensureParsed();
        if (key in values) {
          const value = values[key];
          if (value) {
            let decodedValue;
            try {
              decodedValue = decode2(value);
            } catch (_error) {
              decodedValue = value;
            }
            return new AstroCookie(decodedValue);
          }
        }
      }
      /**
       * Astro.cookies.has(key) returns a boolean indicating whether this cookie is either
       * part of the initial request or set via Astro.cookies.set(key)
       * @param key The cookie to check for.
       * @param _options This parameter is no longer used.
       * @returns
       */
      has(key, _options) {
        if (this.#outgoing?.has(key)) {
          let [, , isSetValue] = this.#outgoing.get(key);
          return isSetValue;
        }
        const values = this.#ensureParsed();
        return values[key] !== void 0;
      }
      /**
       * Astro.cookies.set(key, value) is used to set a cookie's value. If provided
       * an object it will be stringified via JSON.stringify(value). Additionally you
       * can provide options customizing how this cookie will be set, such as setting httpOnly
       * in order to prevent the cookie from being read in client-side JavaScript.
       * @param key The name of the cookie to set.
       * @param value A value, either a string or other primitive or an object.
       * @param options Options for the cookie, such as the path and security settings.
       */
      set(key, value, options) {
        if (this.#consumed) {
          const warning = new Error(
            "Astro.cookies.set() was called after the cookies had already been sent to the browser.\nThis may have happened if this method was called in an imported component.\nPlease make sure that Astro.cookies.set() is only called in the frontmatter of the main page."
          );
          warning.name = "Warning";
          console.warn(warning);
        }
        let serializedValue;
        if (typeof value === "string") {
          serializedValue = value;
        } else {
          let toStringValue = value.toString();
          if (toStringValue === Object.prototype.toString.call(value)) {
            serializedValue = JSON.stringify(value);
          } else {
            serializedValue = toStringValue;
          }
        }
        const serializeOptions = {};
        if (options) {
          Object.assign(serializeOptions, options);
        }
        this.#ensureOutgoingMap().set(key, [
          serializedValue,
          distExports.serialize(key, serializedValue, serializeOptions),
          true
        ]);
        if (this.#request[responseSentSymbol2]) {
          throw new AstroError({
            ...ResponseSentError
          });
        }
      }
      /**
       * Merges a new AstroCookies instance into the current instance. Any new cookies
       * will be added to the current instance, overwriting any existing cookies with the same name.
       */
      merge(cookies) {
        const outgoing = cookies.#outgoing;
        if (outgoing) {
          for (const [key, value] of outgoing) {
            this.#ensureOutgoingMap().set(key, value);
          }
        }
      }
      /**
       * Astro.cookies.header() returns an iterator for the cookies that have previously
       * been set by either Astro.cookies.set() or Astro.cookies.delete().
       * This method is primarily used by adapters to set the header on outgoing responses.
       * @returns
       */
      *headers() {
        if (this.#outgoing == null) return;
        for (const [, value] of this.#outgoing) {
          yield value[1];
        }
      }
      /**
       * Behaves the same as AstroCookies.prototype.headers(),
       * but allows a warning when cookies are set after the instance is consumed.
       */
      static consume(cookies) {
        cookies.#consumed = true;
        return cookies.headers();
      }
      #ensureParsed() {
        if (!this.#requestValues) {
          this.#parse();
        }
        if (!this.#requestValues) {
          this.#requestValues = {};
        }
        return this.#requestValues;
      }
      #ensureOutgoingMap() {
        if (!this.#outgoing) {
          this.#outgoing = /* @__PURE__ */ new Map();
        }
        return this.#outgoing;
      }
      #parse() {
        const raw = this.#request.headers.get("cookie");
        if (!raw) {
          return;
        }
        this.#requestValues = distExports.parse(raw, { decode: identity });
      }
    };
    astroCookiesSymbol = Symbol.for("astro.cookies");
    __name(attachCookiesToResponse, "attachCookiesToResponse");
    __name(getCookiesFromResponse, "getCookiesFromResponse");
    __name(getSetCookiesFromResponse, "getSetCookiesFromResponse");
    __name(createRequest, "createRequest");
    __name(findRouteToRewrite, "findRouteToRewrite");
    __name(copyRequest, "copyRequest");
    __name(setOriginPathname, "setOriginPathname");
    __name(getOriginPathname, "getOriginPathname");
    VALID_PARAM_TYPES = ["string", "number", "undefined"];
    __name(validateGetStaticPathsParameter, "validateGetStaticPathsParameter");
    __name(validateDynamicRouteModule, "validateDynamicRouteModule");
    __name(validateGetStaticPathsResult, "validateGetStaticPathsResult");
    __name(stringifyParams, "stringifyParams");
    __name(generatePaginateFunction, "generatePaginateFunction");
    __name(addRouteBase, "addRouteBase");
    __name(callGetStaticPaths, "callGetStaticPaths");
    RouteCache = class {
      static {
        __name(this, "RouteCache");
      }
      logger;
      cache = {};
      runtimeMode;
      constructor(logger, runtimeMode = "production") {
        this.logger = logger;
        this.runtimeMode = runtimeMode;
      }
      /** Clear the cache. */
      clearAll() {
        this.cache = {};
      }
      set(route, entry) {
        const key = this.key(route);
        if (this.runtimeMode === "production" && this.cache[key]?.staticPaths) {
          this.logger.warn(null, `Internal Warning: route cache overwritten. (${key})`);
        }
        this.cache[key] = entry;
      }
      get(route) {
        return this.cache[this.key(route)];
      }
      key(route) {
        return `${route.route}_${route.component}`;
      }
    };
    __name(findPathItemByKey, "findPathItemByKey");
    __name(routeIsRedirect, "routeIsRedirect");
    __name(routeIsFallback, "routeIsFallback");
    __name(getProps, "getProps");
    __name(getParams, "getParams");
    __name(validatePrerenderEndpointCollision, "validatePrerenderEndpointCollision");
    __name(getFunctionExpression, "getFunctionExpression");
    Slots = class {
      static {
        __name(this, "Slots");
      }
      #result;
      #slots;
      #logger;
      constructor(result, slots, logger) {
        this.#result = result;
        this.#slots = slots;
        this.#logger = logger;
        if (slots) {
          for (const key of Object.keys(slots)) {
            if (this[key] !== void 0) {
              throw new AstroError({
                ...ReservedSlotName,
                message: ReservedSlotName.message(key)
              });
            }
            Object.defineProperty(this, key, {
              get() {
                return true;
              },
              enumerable: true
            });
          }
        }
      }
      has(name) {
        if (!this.#slots) return false;
        return Boolean(this.#slots[name]);
      }
      async render(name, args = []) {
        if (!this.#slots || !this.has(name)) return;
        const result = this.#result;
        if (!Array.isArray(args)) {
          this.#logger.warn(
            null,
            `Expected second parameter to be an array, received a ${typeof args}. If you're trying to pass an array as a single argument and getting unexpected results, make sure you're passing your array as a item of an array. Ex: Astro.slots.render('default', [["Hello", "World"]])`
          );
        } else if (args.length > 0) {
          const slotValue = this.#slots[name];
          const component = typeof slotValue === "function" ? await slotValue(result) : await slotValue;
          const expression = getFunctionExpression(component);
          if (expression) {
            const slot = /* @__PURE__ */ __name(async () => typeof expression === "function" ? expression(...args) : expression, "slot");
            return await renderSlotToString(result, slot).then((res) => {
              return res;
            });
          }
          if (typeof component === "function") {
            return await renderJSX(result, component(...args)).then(
              (res) => res != null ? String(res) : res
            );
          }
        }
        const content = await renderSlotToString(result, this.#slots[name]);
        const outHTML = chunkToString(result, content);
        return outHTML;
      }
    };
    __name(getActionContext, "getActionContext");
    __name(getCallerInfo, "getCallerInfo");
    __name(parseRequestBody, "parseRequestBody");
    __name(deduplicateDirectiveValues, "deduplicateDirectiveValues");
    __name(pushDirective, "pushDirective");
    __name(callMiddleware, "callMiddleware");
    suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
    suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    __name(jsonParseTransform, "jsonParseTransform");
    __name(warnKeyDropped, "warnKeyDropped");
    __name(destr, "destr");
    __name(wrapToPromise, "wrapToPromise");
    __name(asyncCall, "asyncCall");
    __name(isPrimitive, "isPrimitive");
    __name(isPureObject, "isPureObject");
    __name(stringify$1, "stringify$1");
    BASE64_PREFIX = "base64:";
    __name(serializeRaw, "serializeRaw");
    __name(deserializeRaw, "deserializeRaw");
    __name(base64Decode, "base64Decode");
    __name(base64Encode, "base64Encode");
    __name(normalizeKey, "normalizeKey");
    __name(joinKeys, "joinKeys");
    __name(normalizeBaseKey, "normalizeBaseKey");
    __name(filterKeyByDepth, "filterKeyByDepth");
    __name(filterKeyByBase, "filterKeyByBase");
    __name(defineDriver, "defineDriver");
    DRIVER_NAME = "memory";
    memory = defineDriver(() => {
      const data = /* @__PURE__ */ new Map();
      return {
        name: DRIVER_NAME,
        getInstance: /* @__PURE__ */ __name(() => data, "getInstance"),
        hasItem(key) {
          return data.has(key);
        },
        getItem(key) {
          return data.get(key) ?? null;
        },
        getItemRaw(key) {
          return data.get(key) ?? null;
        },
        setItem(key, value) {
          data.set(key, value);
        },
        setItemRaw(key, value) {
          data.set(key, value);
        },
        removeItem(key) {
          data.delete(key);
        },
        getKeys() {
          return [...data.keys()];
        },
        clear() {
          data.clear();
        },
        dispose() {
          data.clear();
        }
      };
    });
    __name(createStorage, "createStorage");
    __name(watch, "watch");
    __name(dispose, "dispose");
    builtinDrivers = {
      "azure-app-configuration": "unstorage/drivers/azure-app-configuration",
      "azureAppConfiguration": "unstorage/drivers/azure-app-configuration",
      "azure-cosmos": "unstorage/drivers/azure-cosmos",
      "azureCosmos": "unstorage/drivers/azure-cosmos",
      "azure-key-vault": "unstorage/drivers/azure-key-vault",
      "azureKeyVault": "unstorage/drivers/azure-key-vault",
      "azure-storage-blob": "unstorage/drivers/azure-storage-blob",
      "azureStorageBlob": "unstorage/drivers/azure-storage-blob",
      "azure-storage-table": "unstorage/drivers/azure-storage-table",
      "azureStorageTable": "unstorage/drivers/azure-storage-table",
      "capacitor-preferences": "unstorage/drivers/capacitor-preferences",
      "capacitorPreferences": "unstorage/drivers/capacitor-preferences",
      "cloudflare-kv-binding": "unstorage/drivers/cloudflare-kv-binding",
      "cloudflareKVBinding": "unstorage/drivers/cloudflare-kv-binding",
      "cloudflare-kv-http": "unstorage/drivers/cloudflare-kv-http",
      "cloudflareKVHttp": "unstorage/drivers/cloudflare-kv-http",
      "cloudflare-r2-binding": "unstorage/drivers/cloudflare-r2-binding",
      "cloudflareR2Binding": "unstorage/drivers/cloudflare-r2-binding",
      "db0": "unstorage/drivers/db0",
      "deno-kv-node": "unstorage/drivers/deno-kv-node",
      "denoKVNode": "unstorage/drivers/deno-kv-node",
      "deno-kv": "unstorage/drivers/deno-kv",
      "denoKV": "unstorage/drivers/deno-kv",
      "fs-lite": "unstorage/drivers/fs-lite",
      "fsLite": "unstorage/drivers/fs-lite",
      "fs": "unstorage/drivers/fs",
      "github": "unstorage/drivers/github",
      "http": "unstorage/drivers/http",
      "indexedb": "unstorage/drivers/indexedb",
      "localstorage": "unstorage/drivers/localstorage",
      "lru-cache": "unstorage/drivers/lru-cache",
      "lruCache": "unstorage/drivers/lru-cache",
      "memory": "unstorage/drivers/memory",
      "mongodb": "unstorage/drivers/mongodb",
      "netlify-blobs": "unstorage/drivers/netlify-blobs",
      "netlifyBlobs": "unstorage/drivers/netlify-blobs",
      "null": "unstorage/drivers/null",
      "overlay": "unstorage/drivers/overlay",
      "planetscale": "unstorage/drivers/planetscale",
      "redis": "unstorage/drivers/redis",
      "s3": "unstorage/drivers/s3",
      "session-storage": "unstorage/drivers/session-storage",
      "sessionStorage": "unstorage/drivers/session-storage",
      "uploadthing": "unstorage/drivers/uploadthing",
      "upstash": "unstorage/drivers/upstash",
      "vercel-blob": "unstorage/drivers/vercel-blob",
      "vercelBlob": "unstorage/drivers/vercel-blob",
      "vercel-kv": "unstorage/drivers/vercel-kv",
      "vercelKV": "unstorage/drivers/vercel-kv",
      "vercel-runtime-cache": "unstorage/drivers/vercel-runtime-cache",
      "vercelRuntimeCache": "unstorage/drivers/vercel-runtime-cache"
    };
    PERSIST_SYMBOL = Symbol();
    DEFAULT_COOKIE_NAME = "astro-session";
    VALID_COOKIE_REGEX = /^[\w-]+$/;
    unflatten2 = /* @__PURE__ */ __name((parsed, _) => {
      return unflatten(parsed, {
        URL: /* @__PURE__ */ __name((href) => new URL(href), "URL")
      });
    }, "unflatten");
    stringify2 = /* @__PURE__ */ __name((data, _) => {
      return stringify(data, {
        // Support URL objects
        URL: /* @__PURE__ */ __name((val) => val instanceof URL && val.href, "URL")
      });
    }, "stringify");
    AstroSession = class _AstroSession {
      static {
        __name(this, "AstroSession");
      }
      // The cookies object.
      #cookies;
      // The session configuration.
      #config;
      // The cookie config
      #cookieConfig;
      // The cookie name
      #cookieName;
      // The unstorage object for the session driver.
      #storage;
      #data;
      // The session ID. A v4 UUID.
      #sessionID;
      // Sessions to destroy. Needed because we won't have the old session ID after it's destroyed locally.
      #toDestroy = /* @__PURE__ */ new Set();
      // Session keys to delete. Used for partial data sets to avoid overwriting the deleted value.
      #toDelete = /* @__PURE__ */ new Set();
      // Whether the session is dirty and needs to be saved.
      #dirty = false;
      // Whether the session cookie has been set.
      #cookieSet = false;
      // The local data is "partial" if it has not been loaded from storage yet and only
      // contains values that have been set or deleted in-memory locally.
      // We do this to avoid the need to block on loading data when it is only being set.
      // When we load the data from storage, we need to merge it with the local partial data,
      // preserving in-memory changes and deletions.
      #partial = true;
      static #sharedStorage = /* @__PURE__ */ new Map();
      constructor(cookies, {
        cookie: cookieConfig = DEFAULT_COOKIE_NAME,
        ...config3
      }, runtimeMode) {
        const { driver } = config3;
        if (!driver) {
          throw new AstroError({
            ...SessionStorageInitError,
            message: SessionStorageInitError.message(
              "No driver was defined in the session configuration and the adapter did not provide a default driver."
            )
          });
        }
        this.#cookies = cookies;
        let cookieConfigObject;
        if (typeof cookieConfig === "object") {
          const { name = DEFAULT_COOKIE_NAME, ...rest } = cookieConfig;
          this.#cookieName = name;
          cookieConfigObject = rest;
        } else {
          this.#cookieName = cookieConfig || DEFAULT_COOKIE_NAME;
        }
        this.#cookieConfig = {
          sameSite: "lax",
          secure: runtimeMode === "production",
          path: "/",
          ...cookieConfigObject,
          httpOnly: true
        };
        this.#config = { ...config3, driver };
      }
      /**
       * Gets a session value. Returns `undefined` if the session or value does not exist.
       */
      async get(key) {
        return (await this.#ensureData()).get(key)?.data;
      }
      /**
       * Checks if a session value exists.
       */
      async has(key) {
        return (await this.#ensureData()).has(key);
      }
      /**
       * Gets all session values.
       */
      async keys() {
        return (await this.#ensureData()).keys();
      }
      /**
       * Gets all session values.
       */
      async values() {
        return [...(await this.#ensureData()).values()].map((entry) => entry.data);
      }
      /**
       * Gets all session entries.
       */
      async entries() {
        return [...(await this.#ensureData()).entries()].map(([key, entry]) => [key, entry.data]);
      }
      /**
       * Deletes a session value.
       */
      delete(key) {
        this.#data?.delete(key);
        if (this.#partial) {
          this.#toDelete.add(key);
        }
        this.#dirty = true;
      }
      /**
       * Sets a session value. The session is created if it does not exist.
       */
      set(key, value, { ttl } = {}) {
        if (!key) {
          throw new AstroError({
            ...SessionStorageSaveError,
            message: "The session key was not provided."
          });
        }
        let cloned;
        try {
          cloned = unflatten2(JSON.parse(stringify2(value)));
        } catch (err) {
          throw new AstroError(
            {
              ...SessionStorageSaveError,
              message: `The session data for ${key} could not be serialized.`,
              hint: "See the devalue library for all supported types: https://github.com/rich-harris/devalue"
            },
            { cause: err }
          );
        }
        if (!this.#cookieSet) {
          this.#setCookie();
          this.#cookieSet = true;
        }
        this.#data ??= /* @__PURE__ */ new Map();
        const lifetime = ttl ?? this.#config.ttl;
        const expires = typeof lifetime === "number" ? Date.now() + lifetime * 1e3 : lifetime;
        this.#data.set(key, {
          data: cloned,
          expires
        });
        this.#dirty = true;
      }
      /**
       * Destroys the session, clearing the cookie and storage if it exists.
       */
      destroy() {
        const sessionId = this.#sessionID ?? this.#cookies.get(this.#cookieName)?.value;
        if (sessionId) {
          this.#toDestroy.add(sessionId);
        }
        this.#cookies.delete(this.#cookieName, this.#cookieConfig);
        this.#sessionID = void 0;
        this.#data = void 0;
        this.#dirty = true;
      }
      /**
       * Regenerates the session, creating a new session ID. The existing session data is preserved.
       */
      async regenerate() {
        let data = /* @__PURE__ */ new Map();
        try {
          data = await this.#ensureData();
        } catch (err) {
          console.error("Failed to load session data during regeneration:", err);
        }
        const oldSessionId = this.#sessionID;
        this.#sessionID = crypto.randomUUID();
        this.#data = data;
        await this.#setCookie();
        if (oldSessionId && this.#storage) {
          this.#storage.removeItem(oldSessionId).catch((err) => {
            console.error("Failed to remove old session data:", err);
          });
        }
      }
      // Persists the session data to storage.
      // This is called automatically at the end of the request.
      // Uses a symbol to prevent users from calling it directly.
      async [PERSIST_SYMBOL]() {
        if (!this.#dirty && !this.#toDestroy.size) {
          return;
        }
        const storage = await this.#ensureStorage();
        if (this.#dirty && this.#data) {
          const data = await this.#ensureData();
          this.#toDelete.forEach((key2) => data.delete(key2));
          const key = this.#ensureSessionID();
          let serialized;
          try {
            serialized = stringify2(data);
          } catch (err) {
            throw new AstroError(
              {
                ...SessionStorageSaveError,
                message: SessionStorageSaveError.message(
                  "The session data could not be serialized.",
                  this.#config.driver
                )
              },
              { cause: err }
            );
          }
          await storage.setItem(key, serialized);
          this.#dirty = false;
        }
        if (this.#toDestroy.size > 0) {
          const cleanupPromises = [...this.#toDestroy].map(
            (sessionId) => storage.removeItem(sessionId).catch((err) => {
              console.error(`Failed to clean up session ${sessionId}:`, err);
            })
          );
          await Promise.all(cleanupPromises);
          this.#toDestroy.clear();
        }
      }
      get sessionID() {
        return this.#sessionID;
      }
      /**
       * Loads a session from storage with the given ID, and replaces the current session.
       * Any changes made to the current session will be lost.
       * This is not normally needed, as the session is automatically loaded using the cookie.
       * However it can be used to restore a session where the ID has been recorded somewhere
       * else (e.g. in a database).
       */
      async load(sessionID) {
        this.#sessionID = sessionID;
        this.#data = void 0;
        await this.#setCookie();
        await this.#ensureData();
      }
      /**
       * Sets the session cookie.
       */
      async #setCookie() {
        if (!VALID_COOKIE_REGEX.test(this.#cookieName)) {
          throw new AstroError({
            ...SessionStorageSaveError,
            message: "Invalid cookie name. Cookie names can only contain letters, numbers, and dashes."
          });
        }
        const value = this.#ensureSessionID();
        this.#cookies.set(this.#cookieName, value, this.#cookieConfig);
      }
      /**
       * Attempts to load the session data from storage, or creates a new data object if none exists.
       * If there is existing partial data, it will be merged into the new data object.
       */
      async #ensureData() {
        const storage = await this.#ensureStorage();
        if (this.#data && !this.#partial) {
          return this.#data;
        }
        this.#data ??= /* @__PURE__ */ new Map();
        const raw = await storage.get(this.#ensureSessionID());
        if (!raw) {
          return this.#data;
        }
        try {
          const storedMap = unflatten2(raw);
          if (!(storedMap instanceof Map)) {
            await this.destroy();
            throw new AstroError({
              ...SessionStorageInitError,
              message: SessionStorageInitError.message(
                "The session data was an invalid type.",
                this.#config.driver
              )
            });
          }
          const now = Date.now();
          for (const [key, value] of storedMap) {
            const expired = typeof value.expires === "number" && value.expires < now;
            if (!this.#data.has(key) && !this.#toDelete.has(key) && !expired) {
              this.#data.set(key, value);
            }
          }
          this.#partial = false;
          return this.#data;
        } catch (err) {
          await this.destroy();
          if (err instanceof AstroError) {
            throw err;
          }
          throw new AstroError(
            {
              ...SessionStorageInitError,
              message: SessionStorageInitError.message(
                "The session data could not be parsed.",
                this.#config.driver
              )
            },
            { cause: err }
          );
        }
      }
      /**
       * Returns the session ID, generating a new one if it does not exist.
       */
      #ensureSessionID() {
        this.#sessionID ??= this.#cookies.get(this.#cookieName)?.value ?? crypto.randomUUID();
        return this.#sessionID;
      }
      /**
       * Ensures the storage is initialized.
       * This is called automatically when a storage operation is needed.
       */
      async #ensureStorage() {
        if (this.#storage) {
          return this.#storage;
        }
        if (_AstroSession.#sharedStorage.has(this.#config.driver)) {
          this.#storage = _AstroSession.#sharedStorage.get(this.#config.driver);
          return this.#storage;
        }
        if (this.#config.driver === "test") {
          this.#storage = this.#config.options.mockStorage;
          return this.#storage;
        }
        if (this.#config.driver === "fs" || this.#config.driver === "fsLite" || this.#config.driver === "fs-lite") {
          this.#config.options ??= {};
          this.#config.driver = "fs-lite";
          this.#config.options.base ??= ".astro/session";
        }
        let driver = null;
        try {
          if (this.#config.driverModule) {
            driver = (await this.#config.driverModule()).default;
          } else if (this.#config.driver) {
            const driverName = resolveSessionDriverName(this.#config.driver);
            if (driverName) {
              driver = (await import(driverName)).default;
            }
          }
        } catch (err) {
          if (err.code === "ERR_MODULE_NOT_FOUND") {
            throw new AstroError(
              {
                ...SessionStorageInitError,
                message: SessionStorageInitError.message(
                  err.message.includes(`Cannot find package`) ? "The driver module could not be found." : err.message,
                  this.#config.driver
                )
              },
              { cause: err }
            );
          }
          throw err;
        }
        if (!driver) {
          throw new AstroError({
            ...SessionStorageInitError,
            message: SessionStorageInitError.message(
              "The module did not export a driver.",
              this.#config.driver
            )
          });
        }
        try {
          this.#storage = createStorage({
            driver: driver(this.#config.options)
          });
          _AstroSession.#sharedStorage.set(this.#config.driver, this.#storage);
          return this.#storage;
        } catch (err) {
          throw new AstroError(
            {
              ...SessionStorageInitError,
              message: SessionStorageInitError.message("Unknown error", this.#config.driver)
            },
            { cause: err }
          );
        }
      }
    };
    __name(resolveSessionDriverName, "resolveSessionDriverName");
    __name(validateAndDecodePathname, "validateAndDecodePathname");
    apiContextRoutesSymbol = Symbol.for("context.routes");
    RenderContext = class _RenderContext {
      static {
        __name(this, "RenderContext");
      }
      constructor(pipeline, locals, middleware, actions, pathname, request, routeData, status, clientAddress, cookies = new AstroCookies(request), params = getParams(routeData, pathname), url = _RenderContext.#createNormalizedUrl(request.url), props = {}, partial = void 0, shouldInjectCspMetaTags = !!pipeline.manifest.csp, session = pipeline.manifest.sessionConfig ? new AstroSession(cookies, pipeline.manifest.sessionConfig, pipeline.runtimeMode) : void 0) {
        this.pipeline = pipeline;
        this.locals = locals;
        this.middleware = middleware;
        this.actions = actions;
        this.pathname = pathname;
        this.request = request;
        this.routeData = routeData;
        this.status = status;
        this.clientAddress = clientAddress;
        this.cookies = cookies;
        this.params = params;
        this.url = url;
        this.props = props;
        this.partial = partial;
        this.shouldInjectCspMetaTags = shouldInjectCspMetaTags;
        this.session = session;
      }
      static #createNormalizedUrl(requestUrl) {
        const url = new URL(requestUrl);
        try {
          url.pathname = validateAndDecodePathname(url.pathname);
        } catch {
          try {
            url.pathname = decodeURI(url.pathname);
          } catch {
          }
        }
        return url;
      }
      /**
       * A flag that tells the render content if the rewriting was triggered
       */
      isRewriting = false;
      /**
       * A safety net in case of loops
       */
      counter = 0;
      result = void 0;
      static async create({
        locals = {},
        middleware,
        pathname,
        pipeline,
        request,
        routeData,
        clientAddress,
        status = 200,
        props,
        partial = void 0,
        actions,
        shouldInjectCspMetaTags
      }) {
        const pipelineMiddleware = await pipeline.getMiddleware();
        const pipelineActions = actions ?? await pipeline.getActions();
        setOriginPathname(
          request,
          pathname,
          pipeline.manifest.trailingSlash,
          pipeline.manifest.buildFormat
        );
        return new _RenderContext(
          pipeline,
          locals,
          sequence(...pipeline.internalMiddleware, middleware ?? pipelineMiddleware),
          pipelineActions,
          pathname,
          request,
          routeData,
          status,
          clientAddress,
          void 0,
          void 0,
          void 0,
          props,
          partial,
          shouldInjectCspMetaTags ?? !!pipeline.manifest.csp
        );
      }
      /**
       * The main function of the RenderContext.
       *
       * Use this function to render any route known to Astro.
       * It attempts to render a route. A route can be a:
       *
       * - page
       * - redirect
       * - endpoint
       * - fallback
       */
      async render(componentInstance, slots = {}) {
        const { middleware, pipeline } = this;
        const { logger, serverLike, streaming, manifest: manifest2 } = pipeline;
        const props = Object.keys(this.props).length > 0 ? this.props : await getProps({
          mod: componentInstance,
          routeData: this.routeData,
          routeCache: this.pipeline.routeCache,
          pathname: this.pathname,
          logger,
          serverLike,
          base: manifest2.base
        });
        const actionApiContext = this.createActionAPIContext();
        const apiContext = this.createAPIContext(props, actionApiContext);
        this.counter++;
        if (this.counter === 4) {
          return new Response("Loop Detected", {
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508
            status: 508,
            statusText: "Astro detected a loop where you tried to call the rewriting logic more than four times."
          });
        }
        const lastNext = /* @__PURE__ */ __name(async (ctx, payload) => {
          if (payload) {
            const oldPathname = this.pathname;
            pipeline.logger.debug("router", "Called rewriting to:", payload);
            const {
              routeData,
              componentInstance: newComponent,
              pathname,
              newUrl
            } = await pipeline.tryRewrite(payload, this.request);
            if (this.pipeline.serverLike === true && this.routeData.prerender === false && routeData.prerender === true) {
              throw new AstroError({
                ...ForbiddenRewrite,
                message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
                hint: ForbiddenRewrite.hint(routeData.component)
              });
            }
            this.routeData = routeData;
            componentInstance = newComponent;
            if (payload instanceof Request) {
              this.request = payload;
            } else {
              this.request = copyRequest(
                newUrl,
                this.request,
                // need to send the flag of the previous routeData
                routeData.prerender,
                this.pipeline.logger,
                this.routeData.route
              );
            }
            this.isRewriting = true;
            this.url = _RenderContext.#createNormalizedUrl(this.request.url);
            this.params = getParams(routeData, pathname);
            this.pathname = pathname;
            this.status = 200;
            setOriginPathname(
              this.request,
              oldPathname,
              this.pipeline.manifest.trailingSlash,
              this.pipeline.manifest.buildFormat
            );
          }
          let response2;
          if (!ctx.isPrerendered) {
            const { action, setActionResult, serializeActionResult: serializeActionResult2 } = getActionContext(ctx);
            if (action?.calledFrom === "form") {
              const actionResult = await action.handler();
              setActionResult(action.name, serializeActionResult2(actionResult));
            }
          }
          switch (this.routeData.type) {
            case "endpoint": {
              response2 = await renderEndpoint(
                componentInstance,
                ctx,
                this.routeData.prerender,
                logger
              );
              break;
            }
            case "redirect":
              return renderRedirect(this);
            case "page": {
              this.result = await this.createResult(componentInstance, actionApiContext);
              try {
                response2 = await renderPage(
                  this.result,
                  componentInstance?.default,
                  props,
                  slots,
                  streaming,
                  this.routeData
                );
              } catch (e2) {
                this.result.cancelled = true;
                throw e2;
              }
              response2.headers.set(ROUTE_TYPE_HEADER, "page");
              if (this.routeData.route === "/404" || this.routeData.route === "/500") {
                response2.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
              }
              if (this.isRewriting) {
                response2.headers.set(REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE);
              }
              break;
            }
            case "fallback": {
              return new Response(null, { status: 500, headers: { [ROUTE_TYPE_HEADER]: "fallback" } });
            }
          }
          const responseCookies = getCookiesFromResponse(response2);
          if (responseCookies) {
            this.cookies.merge(responseCookies);
          }
          return response2;
        }, "lastNext");
        if (isRouteExternalRedirect(this.routeData)) {
          return renderRedirect(this);
        }
        const response = await callMiddleware(middleware, apiContext, lastNext);
        if (response.headers.get(ROUTE_TYPE_HEADER)) {
          response.headers.delete(ROUTE_TYPE_HEADER);
        }
        attachCookiesToResponse(response, this.cookies);
        return response;
      }
      createAPIContext(props, context3) {
        const redirect = /* @__PURE__ */ __name((path3, status = 302) => new Response(null, { status, headers: { Location: path3 } }), "redirect");
        Reflect.set(context3, apiContextRoutesSymbol, this.pipeline);
        return Object.assign(context3, {
          props,
          redirect,
          getActionResult: createGetActionResult(context3.locals),
          callAction: createCallAction(context3)
        });
      }
      async #executeRewrite(reroutePayload) {
        this.pipeline.logger.debug("router", "Calling rewrite: ", reroutePayload);
        const oldPathname = this.pathname;
        const { routeData, componentInstance, newUrl, pathname } = await this.pipeline.tryRewrite(
          reroutePayload,
          this.request
        );
        const isI18nFallback = routeData.fallbackRoutes && routeData.fallbackRoutes.length > 0;
        if (this.pipeline.serverLike && !this.routeData.prerender && routeData.prerender && !isI18nFallback) {
          throw new AstroError({
            ...ForbiddenRewrite,
            message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
            hint: ForbiddenRewrite.hint(routeData.component)
          });
        }
        this.routeData = routeData;
        if (reroutePayload instanceof Request) {
          this.request = reroutePayload;
        } else {
          this.request = copyRequest(
            newUrl,
            this.request,
            // need to send the flag of the previous routeData
            routeData.prerender,
            this.pipeline.logger,
            this.routeData.route
          );
        }
        this.url = _RenderContext.#createNormalizedUrl(this.request.url);
        const newCookies = new AstroCookies(this.request);
        if (this.cookies) {
          newCookies.merge(this.cookies);
        }
        this.cookies = newCookies;
        this.params = getParams(routeData, pathname);
        this.pathname = pathname;
        this.isRewriting = true;
        this.status = 200;
        setOriginPathname(
          this.request,
          oldPathname,
          this.pipeline.manifest.trailingSlash,
          this.pipeline.manifest.buildFormat
        );
        return await this.render(componentInstance);
      }
      createActionAPIContext() {
        const renderContext = this;
        const { params, pipeline, url } = this;
        const generator = `Astro v${ASTRO_VERSION}`;
        const rewrite = /* @__PURE__ */ __name(async (reroutePayload) => {
          return await this.#executeRewrite(reroutePayload);
        }, "rewrite");
        return {
          // Don't allow reassignment of cookies because it doesn't work
          get cookies() {
            return renderContext.cookies;
          },
          routePattern: this.routeData.route,
          isPrerendered: this.routeData.prerender,
          get clientAddress() {
            return renderContext.getClientAddress();
          },
          get currentLocale() {
            return renderContext.computeCurrentLocale();
          },
          generator,
          get locals() {
            return renderContext.locals;
          },
          set locals(_) {
            throw new AstroError(LocalsReassigned);
          },
          params,
          get preferredLocale() {
            return renderContext.computePreferredLocale();
          },
          get preferredLocaleList() {
            return renderContext.computePreferredLocaleList();
          },
          rewrite,
          request: this.request,
          site: pipeline.site,
          url,
          get originPathname() {
            return getOriginPathname(renderContext.request);
          },
          get session() {
            if (this.isPrerendered) {
              pipeline.logger.warn(
                "session",
                `context.session was used when rendering the route ${s.green(this.routePattern)}, but it is not available on prerendered routes. If you need access to sessions, make sure that the route is server-rendered using \`export const prerender = false;\` or by setting \`output\` to \`"server"\` in your Astro config to make all your routes server-rendered by default. For more information, see https://docs.astro.build/en/guides/sessions/`
              );
              return void 0;
            }
            if (!renderContext.session) {
              pipeline.logger.warn(
                "session",
                `context.session was used when rendering the route ${s.green(this.routePattern)}, but no storage configuration was provided. Either configure the storage manually or use an adapter that provides session storage. For more information, see https://docs.astro.build/en/guides/sessions/`
              );
              return void 0;
            }
            return renderContext.session;
          },
          get csp() {
            return {
              insertDirective(payload) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                if (renderContext?.result?.directives) {
                  renderContext.result.directives = pushDirective(
                    renderContext.result.directives,
                    payload
                  );
                } else {
                  renderContext?.result?.directives.push(payload);
                }
              },
              insertScriptResource(resource) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.scriptResources.push(resource);
              },
              insertStyleResource(resource) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.styleResources.push(resource);
              },
              insertStyleHash(hash2) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.styleHashes.push(hash2);
              },
              insertScriptHash(hash2) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.scriptHashes.push(hash2);
              }
            };
          }
        };
      }
      async createResult(mod, ctx) {
        const { cookies, pathname, pipeline, routeData, status } = this;
        const { clientDirectives, inlinedScripts, compressHTML, manifest: manifest2, renderers: renderers2, resolve } = pipeline;
        const { links, scripts, styles } = await pipeline.headElements(routeData);
        const extraStyleHashes = [];
        const extraScriptHashes = [];
        const shouldInjectCspMetaTags = this.shouldInjectCspMetaTags;
        const cspAlgorithm = manifest2.csp?.algorithm ?? "SHA-256";
        if (shouldInjectCspMetaTags) {
          for (const style of styles) {
            extraStyleHashes.push(await generateCspDigest(style.children, cspAlgorithm));
          }
          for (const script of scripts) {
            extraScriptHashes.push(await generateCspDigest(script.children, cspAlgorithm));
          }
        }
        const componentMetadata = await pipeline.componentMetadata(routeData) ?? manifest2.componentMetadata;
        const headers = new Headers({ "Content-Type": "text/html" });
        const partial = typeof this.partial === "boolean" ? this.partial : Boolean(mod.partial);
        const actionResult = hasActionPayload(this.locals) ? deserializeActionResult(this.locals._actionPayload.actionResult) : void 0;
        const response = {
          status: actionResult?.error ? actionResult?.error.status : status,
          statusText: actionResult?.error ? actionResult?.error.type : "OK",
          get headers() {
            return headers;
          },
          // Disallow `Astro.response.headers = new Headers`
          set headers(_) {
            throw new AstroError(AstroResponseHeadersReassigned);
          }
        };
        const result = {
          base: manifest2.base,
          userAssetsBase: manifest2.userAssetsBase,
          cancelled: false,
          clientDirectives,
          inlinedScripts,
          componentMetadata,
          compressHTML,
          cookies,
          /** This function returns the `Astro` faux-global */
          createAstro: /* @__PURE__ */ __name((astroGlobal, props, slots) => this.createAstro(result, astroGlobal, props, slots, ctx), "createAstro"),
          links,
          params: this.params,
          partial,
          pathname,
          renderers: renderers2,
          resolve,
          response,
          request: this.request,
          scripts,
          styles,
          actionResult,
          serverIslandNameMap: manifest2.serverIslandNameMap ?? /* @__PURE__ */ new Map(),
          key: manifest2.key,
          trailingSlash: manifest2.trailingSlash,
          _metadata: {
            hasHydrationScript: false,
            rendererSpecificHydrationScripts: /* @__PURE__ */ new Set(),
            hasRenderedHead: false,
            renderedScripts: /* @__PURE__ */ new Set(),
            hasDirectives: /* @__PURE__ */ new Set(),
            hasRenderedServerIslandRuntime: false,
            headInTree: false,
            extraHead: [],
            extraStyleHashes,
            extraScriptHashes,
            propagators: /* @__PURE__ */ new Set()
          },
          cspDestination: manifest2.csp?.cspDestination ?? (routeData.prerender ? "meta" : "header"),
          shouldInjectCspMetaTags,
          cspAlgorithm,
          // The following arrays must be cloned, otherwise they become mutable across routes.
          scriptHashes: manifest2.csp?.scriptHashes ? [...manifest2.csp.scriptHashes] : [],
          scriptResources: manifest2.csp?.scriptResources ? [...manifest2.csp.scriptResources] : [],
          styleHashes: manifest2.csp?.styleHashes ? [...manifest2.csp.styleHashes] : [],
          styleResources: manifest2.csp?.styleResources ? [...manifest2.csp.styleResources] : [],
          directives: manifest2.csp?.directives ? [...manifest2.csp.directives] : [],
          isStrictDynamic: manifest2.csp?.isStrictDynamic ?? false,
          internalFetchHeaders: manifest2.internalFetchHeaders
        };
        return result;
      }
      #astroPagePartial;
      /**
       * The Astro global is sourced in 3 different phases:
       * - **Static**: `.generator` and `.glob` is printed by the compiler, instantiated once per process per astro file
       * - **Page-level**: `.request`, `.cookies`, `.locals` etc. These remain the same for the duration of the request.
       * - **Component-level**: `.props`, `.slots`, and `.self` are unique to each _use_ of each component.
       *
       * The page level partial is used as the prototype of the user-visible `Astro` global object, which is instantiated once per use of a component.
       */
      createAstro(result, astroStaticPartial, props, slotValues, apiContext) {
        let astroPagePartial;
        if (this.isRewriting) {
          astroPagePartial = this.#astroPagePartial = this.createAstroPagePartial(
            result,
            astroStaticPartial,
            apiContext
          );
        } else {
          astroPagePartial = this.#astroPagePartial ??= this.createAstroPagePartial(
            result,
            astroStaticPartial,
            apiContext
          );
        }
        const astroComponentPartial = { props, self: null };
        const Astro = Object.assign(
          Object.create(astroPagePartial),
          astroComponentPartial
        );
        let _slots;
        Object.defineProperty(Astro, "slots", {
          get: /* @__PURE__ */ __name(() => {
            if (!_slots) {
              _slots = new Slots(
                result,
                slotValues,
                this.pipeline.logger
              );
            }
            return _slots;
          }, "get")
        });
        return Astro;
      }
      createAstroPagePartial(result, astroStaticPartial, apiContext) {
        const renderContext = this;
        const { cookies, locals, params, pipeline, url } = this;
        const { response } = result;
        const redirect = /* @__PURE__ */ __name((path3, status = 302) => {
          if (this.request[responseSentSymbol]) {
            throw new AstroError({
              ...ResponseSentError
            });
          }
          return new Response(null, { status, headers: { Location: path3 } });
        }, "redirect");
        const rewrite = /* @__PURE__ */ __name(async (reroutePayload) => {
          return await this.#executeRewrite(reroutePayload);
        }, "rewrite");
        const callAction = createCallAction(apiContext);
        return {
          generator: astroStaticPartial.generator,
          glob: astroStaticPartial.glob,
          routePattern: this.routeData.route,
          isPrerendered: this.routeData.prerender,
          cookies,
          get session() {
            if (this.isPrerendered) {
              pipeline.logger.warn(
                "session",
                `Astro.session was used when rendering the route ${s.green(this.routePattern)}, but it is not available on prerendered pages. If you need access to sessions, make sure that the page is server-rendered using \`export const prerender = false;\` or by setting \`output\` to \`"server"\` in your Astro config to make all your pages server-rendered by default. For more information, see https://docs.astro.build/en/guides/sessions/`
              );
              return void 0;
            }
            if (!renderContext.session) {
              pipeline.logger.warn(
                "session",
                `Astro.session was used when rendering the route ${s.green(this.routePattern)}, but no storage configuration was provided. Either configure the storage manually or use an adapter that provides session storage. For more information, see https://docs.astro.build/en/guides/sessions/`
              );
              return void 0;
            }
            return renderContext.session;
          },
          get clientAddress() {
            return renderContext.getClientAddress();
          },
          get currentLocale() {
            return renderContext.computeCurrentLocale();
          },
          params,
          get preferredLocale() {
            return renderContext.computePreferredLocale();
          },
          get preferredLocaleList() {
            return renderContext.computePreferredLocaleList();
          },
          locals,
          redirect,
          rewrite,
          request: this.request,
          response,
          site: pipeline.site,
          getActionResult: createGetActionResult(locals),
          get callAction() {
            return callAction;
          },
          url,
          get originPathname() {
            return getOriginPathname(renderContext.request);
          },
          get csp() {
            return {
              insertDirective(payload) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                if (renderContext?.result?.directives) {
                  renderContext.result.directives = pushDirective(
                    renderContext.result.directives,
                    payload
                  );
                } else {
                  renderContext?.result?.directives.push(payload);
                }
              },
              insertScriptResource(resource) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.scriptResources.push(resource);
              },
              insertStyleResource(resource) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.styleResources.push(resource);
              },
              insertStyleHash(hash2) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.styleHashes.push(hash2);
              },
              insertScriptHash(hash2) {
                if (!pipeline.manifest.csp) {
                  throw new AstroError(CspNotEnabled);
                }
                renderContext.result?.scriptHashes.push(hash2);
              }
            };
          }
        };
      }
      getClientAddress() {
        const { pipeline, request, routeData, clientAddress } = this;
        if (routeData.prerender) {
          throw new AstroError({
            ...PrerenderClientAddressNotAvailable,
            message: PrerenderClientAddressNotAvailable.message(routeData.component)
          });
        }
        if (clientAddress) {
          return clientAddress;
        }
        if (clientAddressSymbol in request) {
          return Reflect.get(request, clientAddressSymbol);
        }
        if (pipeline.adapterName) {
          throw new AstroError({
            ...ClientAddressNotAvailable,
            message: ClientAddressNotAvailable.message(pipeline.adapterName)
          });
        }
        throw new AstroError(StaticClientAddressNotAvailable);
      }
      /**
       * API Context may be created multiple times per request, i18n data needs to be computed only once.
       * So, it is computed and saved here on creation of the first APIContext and reused for later ones.
       */
      #currentLocale;
      computeCurrentLocale() {
        const {
          url,
          pipeline: { i18n },
          routeData
        } = this;
        if (!i18n) return;
        const { defaultLocale, locales, strategy } = i18n;
        const fallbackTo = strategy === "pathname-prefix-other-locales" || strategy === "domains-prefix-other-locales" ? defaultLocale : void 0;
        if (this.#currentLocale) {
          return this.#currentLocale;
        }
        let computedLocale;
        if (isRouteServerIsland(routeData)) {
          let referer = this.request.headers.get("referer");
          if (referer) {
            if (URL.canParse(referer)) {
              referer = new URL(referer).pathname;
            }
            computedLocale = computeCurrentLocale(referer, locales, defaultLocale);
          }
        } else {
          let pathname = routeData.pathname;
          if (!routeData.pattern.test(url.pathname)) {
            for (const fallbackRoute of routeData.fallbackRoutes) {
              if (fallbackRoute.pattern.test(url.pathname)) {
                pathname = fallbackRoute.pathname;
                break;
              }
            }
          }
          pathname = pathname && !isRoute404or500(routeData) ? pathname : url.pathname;
          computedLocale = computeCurrentLocale(pathname, locales, defaultLocale);
        }
        this.#currentLocale = computedLocale ?? fallbackTo;
        return this.#currentLocale;
      }
      #preferredLocale;
      computePreferredLocale() {
        const {
          pipeline: { i18n },
          request
        } = this;
        if (!i18n) return;
        return this.#preferredLocale ??= computePreferredLocale(request, i18n.locales);
      }
      #preferredLocaleList;
      computePreferredLocaleList() {
        const {
          pipeline: { i18n },
          request
        } = this;
        if (!i18n) return;
        return this.#preferredLocaleList ??= computePreferredLocaleList(request, i18n.locales);
      }
    };
    __name(sequence, "sequence");
    __name(defineMiddleware, "defineMiddleware");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/cloudflare-kv-binding_BA_YU2bU.mjs
var cloudflare_kv_binding_BA_YU2bU_exports = {};
__export(cloudflare_kv_binding_BA_YU2bU_exports, {
  default: () => cloudflareKvBinding
});
function defineDriver2(factory) {
  return factory;
}
function normalizeKey2(key, sep = ":") {
  if (!key) {
    return "";
  }
  return key.replace(/[:/\\]/g, sep).replace(/^[:/\\]|[:/\\]$/g, "");
}
function joinKeys2(...keys) {
  return keys.map((key) => normalizeKey2(key)).filter(Boolean).join(":");
}
function createError(driver, message2, opts) {
  const err = new Error(`[unstorage] [${driver}] ${message2}`, opts);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, createError);
  }
  return err;
}
function getBinding(binding3) {
  let bindingName = "[binding]";
  if (typeof binding3 === "string") {
    bindingName = binding3;
    binding3 = globalThis[bindingName] || globalThis.__env__?.[bindingName];
  }
  if (!binding3) {
    throw createError(
      "cloudflare",
      `Invalid binding \`${bindingName}\`: \`${binding3}\``
    );
  }
  for (const key of ["get", "put", "delete"]) {
    if (!(key in binding3)) {
      throw createError(
        "cloudflare",
        `Invalid binding \`${bindingName}\`: \`${key}\` key is missing`
      );
    }
  }
  return binding3;
}
function getKVBinding(binding3 = "STORAGE") {
  return getBinding(binding3);
}
var MessagePort4, MessageChannelPolyfill3, DRIVER_NAME2, cloudflareKvBinding;
var init_cloudflare_kv_binding_BA_YU2bU = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/cloudflare-kv-binding_BA_YU2bU.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(defineDriver2, "defineDriver");
    __name(normalizeKey2, "normalizeKey");
    __name(joinKeys2, "joinKeys");
    __name(createError, "createError");
    __name(getBinding, "getBinding");
    __name(getKVBinding, "getKVBinding");
    DRIVER_NAME2 = "cloudflare-kv-binding";
    cloudflareKvBinding = defineDriver2((opts) => {
      const r2 = /* @__PURE__ */ __name((key = "") => opts.base ? joinKeys2(opts.base, key) : key, "r");
      async function getKeys(base = "") {
        base = r2(base);
        const binding3 = getKVBinding(opts.binding);
        const keys = [];
        let cursor = void 0;
        do {
          const kvList = await binding3.list({ prefix: base || void 0, cursor });
          keys.push(...kvList.keys);
          cursor = kvList.list_complete ? void 0 : kvList.cursor;
        } while (cursor);
        return keys.map((key) => key.name);
      }
      __name(getKeys, "getKeys");
      return {
        name: DRIVER_NAME2,
        options: opts,
        getInstance: /* @__PURE__ */ __name(() => getKVBinding(opts.binding), "getInstance"),
        async hasItem(key) {
          key = r2(key);
          const binding3 = getKVBinding(opts.binding);
          return await binding3.get(key) !== null;
        },
        getItem(key) {
          key = r2(key);
          const binding3 = getKVBinding(opts.binding);
          return binding3.get(key);
        },
        setItem(key, value, topts) {
          key = r2(key);
          const binding3 = getKVBinding(opts.binding);
          return binding3.put(
            key,
            value,
            topts ? {
              expirationTtl: topts?.ttl ? Math.max(topts.ttl, opts.minTTL ?? 60) : void 0,
              ...topts
            } : void 0
          );
        },
        removeItem(key) {
          key = r2(key);
          const binding3 = getKVBinding(opts.binding);
          return binding3.delete(key);
        },
        getKeys(base) {
          return getKeys(base).then(
            (keys) => keys.map((key) => opts.base ? key.slice(opts.base.length) : key)
          );
        },
        async clear(base) {
          const binding3 = getKVBinding(opts.binding);
          const keys = await getKeys(base);
          await Promise.all(keys.map((key) => binding3.delete(key)));
        }
      };
    });
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/sharp_DscWmDXI.mjs
var sharp_DscWmDXI_exports = {};
__export(sharp_DscWmDXI_exports, {
  default: () => sharp_default
});
async function loadSharp() {
  let sharpImport;
  try {
    sharpImport = (await import("sharp")).default;
  } catch {
    throw new AstroError(MissingSharp);
  }
  sharpImport.cache(false);
  return sharpImport;
}
var MessagePort4, MessageChannelPolyfill3, sharp, qualityTable, fitMap, sharpService, sharp_default;
var init_sharp_DscWmDXI = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/sharp_DscWmDXI.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_image_endpoint_D6uoC0U6();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    qualityTable = {
      low: 25,
      mid: 50,
      high: 80,
      max: 100
    };
    __name(loadSharp, "loadSharp");
    fitMap = {
      fill: "fill",
      contain: "inside",
      cover: "cover",
      none: "outside",
      "scale-down": "inside",
      outside: "outside",
      inside: "inside"
    };
    sharpService = {
      validateOptions: baseService.validateOptions,
      getURL: baseService.getURL,
      parseURL: baseService.parseURL,
      getHTMLAttributes: baseService.getHTMLAttributes,
      getSrcSet: baseService.getSrcSet,
      async transform(inputBuffer, transformOptions, config3) {
        if (!sharp) sharp = await loadSharp();
        const transform = transformOptions;
        if (transform.format === "svg") return { data: inputBuffer, format: "svg" };
        const result = sharp(inputBuffer, {
          failOnError: false,
          pages: -1,
          limitInputPixels: config3.service.config.limitInputPixels
        });
        result.rotate();
        const withoutEnlargement = Boolean(transform.fit);
        if (transform.width && transform.height && transform.fit) {
          const fit = fitMap[transform.fit] ?? "inside";
          result.resize({
            width: Math.round(transform.width),
            height: Math.round(transform.height),
            fit,
            position: transform.position,
            withoutEnlargement
          });
        } else if (transform.height && !transform.width) {
          result.resize({
            height: Math.round(transform.height),
            withoutEnlargement
          });
        } else if (transform.width) {
          result.resize({
            width: Math.round(transform.width),
            withoutEnlargement
          });
        }
        if (transform.format) {
          let quality = void 0;
          if (transform.quality) {
            const parsedQuality = parseQuality(transform.quality);
            if (typeof parsedQuality === "number") {
              quality = parsedQuality;
            } else {
              quality = transform.quality in qualityTable ? qualityTable[transform.quality] : void 0;
            }
          }
          const isGifInput = inputBuffer[0] === 71 && // 'G'
          inputBuffer[1] === 73 && // 'I'
          inputBuffer[2] === 70 && // 'F'
          inputBuffer[3] === 56 && // '8'
          (inputBuffer[4] === 57 || inputBuffer[4] === 55) && // '9' or '7'
          inputBuffer[5] === 97;
          if (transform.format === "webp" && isGifInput) {
            result.webp({ quality: typeof quality === "number" ? quality : void 0, loop: 0 });
          } else {
            result.toFormat(transform.format, { quality });
          }
        }
        const { data, info: info5 } = await result.toBuffer({ resolveWithObject: true });
        const needsCopy = "buffer" in data && data.buffer instanceof SharedArrayBuffer;
        return {
          data: needsCopy ? new Uint8Array(data) : data,
          format: info5.format
        };
      }
    };
    sharp_default = sharpService;
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/image-endpoint_D6uoC0U6.mjs
function isESMImportedImage(src) {
  return typeof src === "object" || typeof src === "function" && "src" in src;
}
function isRemoteImage(src) {
  return typeof src === "string";
}
async function resolveSrc(src) {
  if (typeof src === "object" && "then" in src) {
    const resource = await src;
    return resource.default ?? resource;
  }
  return src;
}
function isLocalService(service) {
  if (!service) {
    return false;
  }
  return "transform" in service;
}
function parseQuality(quality) {
  let result = parseInt(quality);
  if (Number.isNaN(result)) {
    return quality;
  }
  return result;
}
function verifyOptions(options) {
  if (!options.src || !isRemoteImage(options.src) && !isESMImportedImage(options.src)) {
    throw new AstroError({
      ...ExpectedImage,
      message: ExpectedImage.message(
        JSON.stringify(options.src),
        typeof options.src,
        JSON.stringify(options, (_, v) => v === void 0 ? null : v)
      )
    });
  }
  if (!isESMImportedImage(options.src)) {
    if (options.src.startsWith("/@fs/") || !isRemotePath(options.src) && !options.src.startsWith("/")) {
      throw new AstroError({
        ...LocalImageUsedWrongly,
        message: LocalImageUsedWrongly.message(options.src)
      });
    }
    let missingDimension;
    if (!options.width && !options.height) {
      missingDimension = "both";
    } else if (!options.width && options.height) {
      missingDimension = "width";
    } else if (options.width && !options.height) {
      missingDimension = "height";
    }
    if (missingDimension) {
      throw new AstroError({
        ...MissingImageDimension,
        message: MissingImageDimension.message(missingDimension, options.src)
      });
    }
  } else {
    if (!VALID_SUPPORTED_FORMATS.includes(options.src.format)) {
      throw new AstroError({
        ...UnsupportedImageFormat,
        message: UnsupportedImageFormat.message(
          options.src.format,
          options.src.src,
          VALID_SUPPORTED_FORMATS
        )
      });
    }
    if (options.widths && options.densities) {
      throw new AstroError(IncompatibleDescriptorOptions);
    }
    if (options.src.format === "svg" && options.format !== "svg" || options.src.format !== "svg" && options.format === "svg") {
      throw new AstroError(UnsupportedImageConversion);
    }
  }
}
function getTargetDimensions(options) {
  let targetWidth = options.width;
  let targetHeight = options.height;
  if (isESMImportedImage(options.src)) {
    const aspectRatio = options.src.width / options.src.height;
    if (targetHeight && !targetWidth) {
      targetWidth = Math.round(targetHeight * aspectRatio);
    } else if (targetWidth && !targetHeight) {
      targetHeight = Math.round(targetWidth / aspectRatio);
    } else if (!targetWidth && !targetHeight) {
      targetWidth = options.src.width;
      targetHeight = options.src.height;
    }
  }
  return {
    targetWidth,
    targetHeight
  };
}
function isImageMetadata(src) {
  return src.fsPath && !("fsPath" in src);
}
function addCSSVarsToStyle(vars, styles) {
  const cssVars = Object.entries(vars).filter(([_, value]) => value !== void 0 && value !== false).map(([key, value]) => `--${key}: ${value};`).join(" ");
  if (!styles) {
    return cssVars;
  }
  const style = typeof styles === "string" ? styles : toStyleString(styles);
  return `${cssVars} ${style}`;
}
function readUInt(input, bits, offset, isBigEndian) {
  offset = offset || 0;
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = "readUInt" + bits + endian;
  return methods[methodName](input, offset);
}
function readBox(buffer, offset) {
  if (buffer.length - offset < 4) return;
  const boxSize = readUInt32BE(buffer, offset);
  if (buffer.length - offset < boxSize) return;
  return {
    name: toUTF8String(buffer, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(buffer, boxName, offset) {
  while (offset < buffer.length) {
    const box = readBox(buffer, offset);
    if (!box) break;
    if (box.name === boxName) return box;
    offset += box.size;
  }
}
function getSizeFromOffset(input, offset) {
  const value = input[offset];
  return value === 0 ? 256 : value;
}
function getImageSize$1(input, imageIndex) {
  const offset = SIZE_HEADER$1 + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
function detectBrands(buffer, start, end) {
  let brandsDetected = {};
  for (let i2 = start; i2 <= end; i2 += 4) {
    const brand = toUTF8String(buffer, i2, i2 + 4);
    if (brand in brandMap) {
      brandsDetected[brand] = 1;
    }
  }
  if ("avif" in brandsDetected || "avis" in brandsDetected) {
    return "avif";
  } else if ("heic" in brandsDetected || "heix" in brandsDetected || "hevc" in brandsDetected || "hevx" in brandsDetected) {
    return "heic";
  } else if ("mif1" in brandsDetected || "msf1" in brandsDetected) {
    return "heif";
  }
}
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize(type) {
  const size = ICON_TYPE_SIZE[type];
  return { width: size, height: size, type };
}
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index2) {
  return {
    height: readUInt16BE(input, index2),
    width: readUInt16BE(input, index2 + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end = start + IDF_ENTRY_BYTES;
    if (start > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start, end);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index2) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index2);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index2) {
  if (index2 > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = extractorRegExps.width.exec(root);
  const height = extractorRegExps.height.exec(root);
  const viewbox = extractorRegExps.viewbox.exec(root);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
function readIFD(input, isBigEndian) {
  const ifdOffset = readUInt(input, 32, 4, isBigEndian);
  return input.slice(ifdOffset + 2);
}
function readValue(input, isBigEndian) {
  const low = readUInt(input, 16, 8, isBigEndian);
  const high = readUInt(input, 16, 10, isBigEndian);
  return (high << 16) + low;
}
function nextTag(input) {
  if (input.length > 24) {
    return input.slice(12);
  }
}
function extractTags(input, isBigEndian) {
  const tags2 = {};
  let temp = input;
  while (temp && temp.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type = readUInt(temp, 16, 2, isBigEndian);
    const length = readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) {
      break;
    } else {
      if (length === 1 && (type === 3 || type === 4)) {
        tags2[code] = readValue(temp, isBigEndian);
      }
      temp = nextTag(temp);
    }
  }
  return tags2;
}
function determineEndianness(input) {
  const signature = toUTF8String(input, 0, 2);
  if ("II" === signature) {
    return "LE";
  } else if ("MM" === signature) {
    return "BE";
  }
}
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
function detector(input) {
  const byte = input[0];
  const type = firstBytes.get(byte);
  if (type && typeHandlers.get(type).validate(input)) {
    return type;
  }
  return types.find((fileType) => typeHandlers.get(fileType).validate(input));
}
function lookup$1(input) {
  const type = detector(input);
  if (typeof type !== "undefined") {
    const size = typeHandlers.get(type).calculate(input);
    if (size !== void 0) {
      size.type = size.type ?? type;
      return size;
    }
  }
  throw new TypeError("unsupported file type: " + type);
}
async function imageMetadata(data, src) {
  let result;
  try {
    result = lookup$1(data);
  } catch {
    throw new AstroError({
      ...NoImageMetadata,
      message: NoImageMetadata.message(src)
    });
  }
  if (!result.height || !result.width || !result.type) {
    throw new AstroError({
      ...NoImageMetadata,
      message: NoImageMetadata.message(src)
    });
  }
  const { width, height, type, orientation } = result;
  const isPortrait = (orientation || 0) >= 5;
  return {
    width: isPortrait ? height : width,
    height: isPortrait ? width : height,
    format: type,
    orientation
  };
}
async function inferRemoteSize(url) {
  const response = await fetch(url);
  if (!response.body || !response.ok) {
    throw new AstroError({
      ...FailedToFetchRemoteImageDimensions,
      message: FailedToFetchRemoteImageDimensions.message(url)
    });
  }
  const reader = response.body.getReader();
  let done, value;
  let accumulatedChunks = new Uint8Array();
  while (!done) {
    const readResult2 = await reader.read();
    done = readResult2.done;
    if (done) break;
    if (readResult2.value) {
      value = readResult2.value;
      let tmp = new Uint8Array(accumulatedChunks.length + value.length);
      tmp.set(accumulatedChunks, 0);
      tmp.set(value, accumulatedChunks.length);
      accumulatedChunks = tmp;
      try {
        const dimensions = await imageMetadata(accumulatedChunks, url);
        if (dimensions) {
          await reader.cancel();
          return dimensions;
        }
      } catch {
      }
    }
  }
  throw new AstroError({
    ...NoImageMetadata,
    message: NoImageMetadata.message(url)
  });
}
function createPlaceholderURL(pathOrUrl) {
  return new URL(pathOrUrl, PLACEHOLDER_BASE);
}
function stringifyPlaceholderURL(url) {
  return url.href.replace(PLACEHOLDER_BASE, "");
}
async function getConfiguredImageService() {
  if (!globalThis?.astroAsset?.imageService) {
    const { default: service } = await Promise.resolve().then(() => (init_sharp_DscWmDXI(), sharp_DscWmDXI_exports)).catch((e2) => {
      const error5 = new AstroError(InvalidImageService);
      error5.cause = e2;
      throw error5;
    });
    if (!globalThis.astroAsset) globalThis.astroAsset = {};
    globalThis.astroAsset.imageService = service;
    return service;
  }
  return globalThis.astroAsset.imageService;
}
async function getImage$1(options, imageConfig2) {
  if (!options || typeof options !== "object") {
    throw new AstroError({
      ...ExpectedImageOptions,
      message: ExpectedImageOptions.message(JSON.stringify(options))
    });
  }
  if (typeof options.src === "undefined") {
    throw new AstroError({
      ...ExpectedImage,
      message: ExpectedImage.message(
        options.src,
        "undefined",
        JSON.stringify(options)
      )
    });
  }
  if (isImageMetadata(options)) {
    throw new AstroError(ExpectedNotESMImage);
  }
  const service = await getConfiguredImageService();
  const resolvedOptions = {
    ...options,
    src: await resolveSrc(options.src)
  };
  let originalWidth;
  let originalHeight;
  if (options.inferSize && isRemoteImage(resolvedOptions.src) && isRemotePath(resolvedOptions.src)) {
    const result = await inferRemoteSize(resolvedOptions.src);
    resolvedOptions.width ??= result.width;
    resolvedOptions.height ??= result.height;
    originalWidth = result.width;
    originalHeight = result.height;
    delete resolvedOptions.inferSize;
  }
  const originalFilePath = isESMImportedImage(resolvedOptions.src) ? resolvedOptions.src.fsPath : void 0;
  const clonedSrc = isESMImportedImage(resolvedOptions.src) ? (
    // @ts-expect-error - clone is a private, hidden prop
    resolvedOptions.src.clone ?? resolvedOptions.src
  ) : resolvedOptions.src;
  if (isESMImportedImage(clonedSrc)) {
    originalWidth = clonedSrc.width;
    originalHeight = clonedSrc.height;
  }
  if (originalWidth && originalHeight) {
    const aspectRatio = originalWidth / originalHeight;
    if (resolvedOptions.height && !resolvedOptions.width) {
      resolvedOptions.width = Math.round(resolvedOptions.height * aspectRatio);
    } else if (resolvedOptions.width && !resolvedOptions.height) {
      resolvedOptions.height = Math.round(resolvedOptions.width / aspectRatio);
    } else if (!resolvedOptions.width && !resolvedOptions.height) {
      resolvedOptions.width = originalWidth;
      resolvedOptions.height = originalHeight;
    }
  }
  resolvedOptions.src = clonedSrc;
  const layout = options.layout ?? imageConfig2.layout ?? "none";
  if (resolvedOptions.priority) {
    resolvedOptions.loading ??= "eager";
    resolvedOptions.decoding ??= "sync";
    resolvedOptions.fetchpriority ??= "high";
    delete resolvedOptions.priority;
  } else {
    resolvedOptions.loading ??= "lazy";
    resolvedOptions.decoding ??= "async";
    resolvedOptions.fetchpriority ??= "auto";
  }
  if (layout !== "none") {
    resolvedOptions.widths ||= getWidths({
      width: resolvedOptions.width,
      layout,
      originalWidth,
      breakpoints: imageConfig2.breakpoints?.length ? imageConfig2.breakpoints : isLocalService(service) ? LIMITED_RESOLUTIONS : DEFAULT_RESOLUTIONS
    });
    resolvedOptions.sizes ||= getSizesAttribute({ width: resolvedOptions.width, layout });
    delete resolvedOptions.densities;
    resolvedOptions.style = addCSSVarsToStyle(
      {
        fit: cssFitValues.includes(resolvedOptions.fit ?? "") && resolvedOptions.fit,
        pos: resolvedOptions.position
      },
      resolvedOptions.style
    );
    resolvedOptions["data-astro-image"] = layout;
  }
  const validatedOptions = service.validateOptions ? await service.validateOptions(resolvedOptions, imageConfig2) : resolvedOptions;
  const srcSetTransforms = service.getSrcSet ? await service.getSrcSet(validatedOptions, imageConfig2) : [];
  let imageURL = await service.getURL(validatedOptions, imageConfig2);
  const matchesValidatedTransform = /* @__PURE__ */ __name((transform) => transform.width === validatedOptions.width && transform.height === validatedOptions.height && transform.format === validatedOptions.format, "matchesValidatedTransform");
  let srcSets = await Promise.all(
    srcSetTransforms.map(async (srcSet) => {
      return {
        transform: srcSet.transform,
        url: matchesValidatedTransform(srcSet.transform) ? imageURL : await service.getURL(srcSet.transform, imageConfig2),
        descriptor: srcSet.descriptor,
        attributes: srcSet.attributes
      };
    })
  );
  if (isLocalService(service) && globalThis.astroAsset.addStaticImage && !(isRemoteImage(validatedOptions.src) && imageURL === validatedOptions.src)) {
    const propsToHash = service.propertiesToHash ?? DEFAULT_HASH_PROPS;
    imageURL = globalThis.astroAsset.addStaticImage(
      validatedOptions,
      propsToHash,
      originalFilePath
    );
    srcSets = srcSetTransforms.map((srcSet) => {
      return {
        transform: srcSet.transform,
        url: matchesValidatedTransform(srcSet.transform) ? imageURL : globalThis.astroAsset.addStaticImage(srcSet.transform, propsToHash, originalFilePath),
        descriptor: srcSet.descriptor,
        attributes: srcSet.attributes
      };
    });
  } else if (imageConfig2.assetQueryParams) {
    const imageURLObj = createPlaceholderURL(imageURL);
    imageConfig2.assetQueryParams.forEach((value, key) => {
      imageURLObj.searchParams.set(key, value);
    });
    imageURL = stringifyPlaceholderURL(imageURLObj);
    srcSets = srcSets.map((srcSet) => {
      const urlObj = createPlaceholderURL(srcSet.url);
      imageConfig2.assetQueryParams.forEach((value, key) => {
        urlObj.searchParams.set(key, value);
      });
      return {
        ...srcSet,
        url: stringifyPlaceholderURL(urlObj)
      };
    });
  }
  return {
    rawOptions: resolvedOptions,
    options: validatedOptions,
    src: imageURL,
    srcSet: {
      values: srcSets,
      attribute: srcSets.map((srcSet) => `${srcSet.url} ${srcSet.descriptor}`).join(", ")
    },
    attributes: service.getHTMLAttributes !== void 0 ? await service.getHTMLAttributes(validatedOptions, imageConfig2) : {}
  };
}
function lookup(extn) {
  let tmp = ("" + extn).trim().toLowerCase();
  let idx = tmp.lastIndexOf(".");
  return mimes[!~idx ? tmp : tmp.substring(++idx)];
}
function filterPreloads(data, preload) {
  if (!preload) {
    return null;
  }
  if (preload === true) {
    return data;
  }
  return data.filter(
    ({ weight, style, subset }) => preload.some((p) => {
      if (p.weight !== void 0 && weight !== void 0 && !checkWeight(p.weight.toString(), weight)) {
        return false;
      }
      if (p.style !== void 0 && p.style !== style) {
        return false;
      }
      if (p.subset !== void 0 && p.subset !== subset) {
        return false;
      }
      return true;
    })
  );
}
function checkWeight(input, target) {
  const trimmedInput = input.trim();
  if (trimmedInput.includes(" ")) {
    return trimmedInput === target;
  }
  if (target.includes(" ")) {
    const [a2, b] = target.split(" ");
    const parsedInput = Number.parseInt(input);
    return parsedInput >= Number.parseInt(a2) && parsedInput <= Number.parseInt(b);
  }
  return input === target;
}
var MessagePort4, MessageChannelPolyfill3, VALID_SUPPORTED_FORMATS, DEFAULT_OUTPUT_FORMAT, DEFAULT_HASH_PROPS, DEFAULT_RESOLUTIONS, LIMITED_RESOLUTIONS, getWidths, getSizesAttribute, sortNumeric, baseService, cssFitValues, decoder2, toUTF8String, toHexString, readInt16LE, readUInt16BE, readUInt16LE, readUInt24LE, readInt32LE, readUInt32BE, readUInt32LE, methods, BMP, TYPE_ICON, SIZE_HEADER$1, SIZE_IMAGE_ENTRY, ICO, TYPE_CURSOR, CUR, DDS, gifRegexp, GIF, brandMap, HEIF, SIZE_HEADER, FILE_LENGTH_OFFSET, ENTRY_LENGTH_OFFSET, ICON_TYPE_SIZE, ICNS, J2C, JP2, EXIF_MARKER, APP1_DATA_SIZE_BYTES, EXIF_HEADER_BYTES, TIFF_BYTE_ALIGN_BYTES, BIG_ENDIAN_BYTE_ALIGN, LITTLE_ENDIAN_BYTE_ALIGN, IDF_ENTRY_BYTES, NUM_DIRECTORY_ENTRIES_BYTES, JPG, KTX, pngSignature, pngImageHeaderChunkName, pngFriedChunkName, PNG, PNMTypes, handlers, PNM, PSD, svgReg, extractorRegExps, INCH_CM, units, unitsReg, SVG, TGA, signatures, TIFF, WEBP, typeHandlers, types, firstBytes, PLACEHOLDER_BASE, $$Astro$2, $$Image, mimes, $$Astro$1, $$Picture, fontsMod, $$Astro, $$Font, assetQueryParams, imageConfig, getImage, prerender, GET, _page, page;
var init_image_endpoint_D6uoC0U6 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/image-endpoint_D6uoC0U6.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_path_BA_Tke6N();
    init_server_B79ahsw9();
    init_remote_DLFRGwa();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    VALID_SUPPORTED_FORMATS = [
      "jpeg",
      "jpg",
      "png",
      "tiff",
      "webp",
      "gif",
      "svg",
      "avif"
    ];
    DEFAULT_OUTPUT_FORMAT = "webp";
    DEFAULT_HASH_PROPS = [
      "src",
      "width",
      "height",
      "format",
      "quality",
      "fit",
      "position"
    ];
    DEFAULT_RESOLUTIONS = [
      640,
      // older and lower-end phones
      750,
      // iPhone 6-8
      828,
      // iPhone XR/11
      960,
      // older horizontal phones
      1080,
      // iPhone 6-8 Plus
      1280,
      // 720p
      1668,
      // Various iPads
      1920,
      // 1080p
      2048,
      // QXGA
      2560,
      // WQXGA
      3200,
      // QHD+
      3840,
      // 4K
      4480,
      // 4.5K
      5120,
      // 5K
      6016
      // 6K
    ];
    LIMITED_RESOLUTIONS = [
      640,
      // older and lower-end phones
      750,
      // iPhone 6-8
      828,
      // iPhone XR/11
      1080,
      // iPhone 6-8 Plus
      1280,
      // 720p
      1668,
      // Various iPads
      2048,
      // QXGA
      2560
      // WQXGA
    ];
    getWidths = /* @__PURE__ */ __name(({
      width,
      layout,
      breakpoints = DEFAULT_RESOLUTIONS,
      originalWidth
    }) => {
      const smallerThanOriginal = /* @__PURE__ */ __name((w) => !originalWidth || w <= originalWidth, "smallerThanOriginal");
      if (layout === "full-width") {
        return breakpoints.filter(smallerThanOriginal);
      }
      if (!width) {
        return [];
      }
      const doubleWidth = width * 2;
      const maxSize = originalWidth ? Math.min(doubleWidth, originalWidth) : doubleWidth;
      if (layout === "fixed") {
        return originalWidth && width > originalWidth ? [originalWidth] : [width, maxSize];
      }
      if (layout === "constrained") {
        return [
          // Always include the image at 1x and 2x the specified width
          width,
          doubleWidth,
          ...breakpoints
        ].filter((w) => w <= maxSize).sort((a2, b) => a2 - b);
      }
      return [];
    }, "getWidths");
    getSizesAttribute = /* @__PURE__ */ __name(({
      width,
      layout
    }) => {
      if (!width || !layout) {
        return void 0;
      }
      switch (layout) {
        // If screen is wider than the max size then image width is the max size,
        // otherwise it's the width of the screen
        case "constrained":
          return `(min-width: ${width}px) ${width}px, 100vw`;
        // Image is always the same width, whatever the size of the screen
        case "fixed":
          return `${width}px`;
        // Image is always the width of the screen
        case "full-width":
          return `100vw`;
        case "none":
        default:
          return void 0;
      }
    }, "getSizesAttribute");
    __name(isESMImportedImage, "isESMImportedImage");
    __name(isRemoteImage, "isRemoteImage");
    __name(resolveSrc, "resolveSrc");
    __name(isLocalService, "isLocalService");
    __name(parseQuality, "parseQuality");
    sortNumeric = /* @__PURE__ */ __name((a2, b) => a2 - b, "sortNumeric");
    __name(verifyOptions, "verifyOptions");
    baseService = {
      validateOptions(options) {
        if (isESMImportedImage(options.src) && options.src.format === "svg") {
          options.format = "svg";
        }
        verifyOptions(options);
        if (!options.format) {
          options.format = DEFAULT_OUTPUT_FORMAT;
        }
        if (options.width) options.width = Math.round(options.width);
        if (options.height) options.height = Math.round(options.height);
        if (options.layout && options.width && options.height) {
          options.fit ??= "cover";
          delete options.layout;
        }
        if (options.fit === "none") {
          delete options.fit;
        }
        return options;
      },
      getHTMLAttributes(options) {
        const { targetWidth, targetHeight } = getTargetDimensions(options);
        const {
          src,
          width,
          height,
          format,
          quality,
          densities,
          widths,
          formats,
          layout,
          priority,
          fit,
          position,
          ...attributes
        } = options;
        return {
          ...attributes,
          width: targetWidth,
          height: targetHeight,
          loading: attributes.loading ?? "lazy",
          decoding: attributes.decoding ?? "async"
        };
      },
      getSrcSet(options) {
        const { targetWidth, targetHeight } = getTargetDimensions(options);
        const aspectRatio = targetWidth / targetHeight;
        const { widths, densities } = options;
        const targetFormat = options.format ?? DEFAULT_OUTPUT_FORMAT;
        let transformedWidths = (widths ?? []).sort(sortNumeric);
        let imageWidth = options.width;
        let maxWidth = Infinity;
        if (isESMImportedImage(options.src)) {
          imageWidth = options.src.width;
          maxWidth = imageWidth;
          if (transformedWidths.length > 0 && transformedWidths.at(-1) > maxWidth) {
            transformedWidths = transformedWidths.filter((width) => width <= maxWidth);
            transformedWidths.push(maxWidth);
          }
        }
        transformedWidths = Array.from(new Set(transformedWidths));
        const {
          width: transformWidth,
          height: transformHeight,
          ...transformWithoutDimensions
        } = options;
        let allWidths = [];
        if (densities) {
          const densityValues = densities.map((density) => {
            if (typeof density === "number") {
              return density;
            } else {
              return parseFloat(density);
            }
          });
          const densityWidths = densityValues.sort(sortNumeric).map((density) => Math.round(targetWidth * density));
          allWidths = densityWidths.map((width, index2) => ({
            width,
            descriptor: `${densityValues[index2]}x`
          }));
        } else if (transformedWidths.length > 0) {
          allWidths = transformedWidths.map((width) => ({
            width,
            descriptor: `${width}w`
          }));
        }
        return allWidths.map(({ width, descriptor }) => {
          const height = Math.round(width / aspectRatio);
          const transform = { ...transformWithoutDimensions, width, height };
          return {
            transform,
            descriptor,
            attributes: {
              type: `image/${targetFormat}`
            }
          };
        });
      },
      getURL(options, imageConfig2) {
        const searchParams = new URLSearchParams();
        if (isESMImportedImage(options.src)) {
          searchParams.append("href", options.src.src);
        } else if (isRemoteAllowed(options.src, imageConfig2)) {
          searchParams.append("href", options.src);
        } else {
          return options.src;
        }
        const params = {
          w: "width",
          h: "height",
          q: "quality",
          f: "format",
          fit: "fit",
          position: "position"
        };
        Object.entries(params).forEach(([param, key]) => {
          options[key] && searchParams.append(param, options[key].toString());
        });
        const imageEndpoint = joinPaths("/", imageConfig2.endpoint.route);
        let url = `${imageEndpoint}?${searchParams}`;
        if (imageConfig2.assetQueryParams) {
          const assetQueryString = imageConfig2.assetQueryParams.toString();
          if (assetQueryString) {
            url += "&" + assetQueryString;
          }
        }
        return url;
      },
      parseURL(url) {
        const params = url.searchParams;
        if (!params.has("href")) {
          return void 0;
        }
        const transform = {
          src: params.get("href"),
          width: params.has("w") ? parseInt(params.get("w")) : void 0,
          height: params.has("h") ? parseInt(params.get("h")) : void 0,
          format: params.get("f"),
          quality: params.get("q"),
          fit: params.get("fit"),
          position: params.get("position") ?? void 0
        };
        return transform;
      }
    };
    __name(getTargetDimensions, "getTargetDimensions");
    __name(isImageMetadata, "isImageMetadata");
    cssFitValues = ["fill", "contain", "cover", "scale-down"];
    __name(addCSSVarsToStyle, "addCSSVarsToStyle");
    decoder2 = new TextDecoder();
    toUTF8String = /* @__PURE__ */ __name((input, start = 0, end = input.length) => decoder2.decode(input.slice(start, end)), "toUTF8String");
    toHexString = /* @__PURE__ */ __name((input, start = 0, end = input.length) => input.slice(start, end).reduce((memo, i2) => memo + ("0" + i2.toString(16)).slice(-2), ""), "toHexString");
    readInt16LE = /* @__PURE__ */ __name((input, offset = 0) => {
      const val = input[offset] + input[offset + 1] * 2 ** 8;
      return val | (val & 2 ** 15) * 131070;
    }, "readInt16LE");
    readUInt16BE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] * 2 ** 8 + input[offset + 1], "readUInt16BE");
    readUInt16LE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8, "readUInt16LE");
    readUInt24LE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16, "readUInt24LE");
    readInt32LE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + (input[offset + 3] << 24), "readInt32LE");
    readUInt32BE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] * 2 ** 24 + input[offset + 1] * 2 ** 16 + input[offset + 2] * 2 ** 8 + input[offset + 3], "readUInt32BE");
    readUInt32LE = /* @__PURE__ */ __name((input, offset = 0) => input[offset] + input[offset + 1] * 2 ** 8 + input[offset + 2] * 2 ** 16 + input[offset + 3] * 2 ** 24, "readUInt32LE");
    methods = {
      readUInt16BE,
      readUInt16LE,
      readUInt32BE,
      readUInt32LE
    };
    __name(readUInt, "readUInt");
    __name(readBox, "readBox");
    __name(findBox, "findBox");
    BMP = {
      validate: /* @__PURE__ */ __name((input) => toUTF8String(input, 0, 2) === "BM", "validate"),
      calculate: /* @__PURE__ */ __name((input) => ({
        height: Math.abs(readInt32LE(input, 22)),
        width: readUInt32LE(input, 18)
      }), "calculate")
    };
    TYPE_ICON = 1;
    SIZE_HEADER$1 = 2 + 2 + 2;
    SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
    __name(getSizeFromOffset, "getSizeFromOffset");
    __name(getImageSize$1, "getImageSize$1");
    ICO = {
      validate(input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_ICON;
      },
      calculate(input) {
        const nbImages = readUInt16LE(input, 4);
        const imageSize = getImageSize$1(input, 0);
        if (nbImages === 1) return imageSize;
        const imgs = [imageSize];
        for (let imageIndex = 1; imageIndex < nbImages; imageIndex += 1) {
          imgs.push(getImageSize$1(input, imageIndex));
        }
        return {
          height: imageSize.height,
          images: imgs,
          width: imageSize.width
        };
      }
    };
    TYPE_CURSOR = 2;
    CUR = {
      validate(input) {
        const reserved = readUInt16LE(input, 0);
        const imageCount = readUInt16LE(input, 4);
        if (reserved !== 0 || imageCount === 0) return false;
        const imageType = readUInt16LE(input, 2);
        return imageType === TYPE_CURSOR;
      },
      calculate: /* @__PURE__ */ __name((input) => ICO.calculate(input), "calculate")
    };
    DDS = {
      validate: /* @__PURE__ */ __name((input) => readUInt32LE(input, 0) === 542327876, "validate"),
      calculate: /* @__PURE__ */ __name((input) => ({
        height: readUInt32LE(input, 12),
        width: readUInt32LE(input, 16)
      }), "calculate")
    };
    gifRegexp = /^GIF8[79]a/;
    GIF = {
      validate: /* @__PURE__ */ __name((input) => gifRegexp.test(toUTF8String(input, 0, 6)), "validate"),
      calculate: /* @__PURE__ */ __name((input) => ({
        height: readUInt16LE(input, 8),
        width: readUInt16LE(input, 6)
      }), "calculate")
    };
    brandMap = {
      avif: "avif",
      avis: "avif",
      // avif-sequence
      mif1: "heif",
      msf1: "heif",
      // heif-sequence
      heic: "heic",
      heix: "heic",
      hevc: "heic",
      // heic-sequence
      hevx: "heic"
      // heic-sequence
    };
    __name(detectBrands, "detectBrands");
    HEIF = {
      validate(buffer) {
        const ftype = toUTF8String(buffer, 4, 8);
        const brand = toUTF8String(buffer, 8, 12);
        return "ftyp" === ftype && brand in brandMap;
      },
      calculate(buffer) {
        const metaBox = findBox(buffer, "meta", 0);
        const iprpBox = metaBox && findBox(buffer, "iprp", metaBox.offset + 12);
        const ipcoBox = iprpBox && findBox(buffer, "ipco", iprpBox.offset + 8);
        const ispeBox = ipcoBox && findBox(buffer, "ispe", ipcoBox.offset + 8);
        if (ispeBox) {
          return {
            height: readUInt32BE(buffer, ispeBox.offset + 16),
            width: readUInt32BE(buffer, ispeBox.offset + 12),
            type: detectBrands(buffer, 8, metaBox.offset)
          };
        }
        throw new TypeError("Invalid HEIF, no size found");
      }
    };
    SIZE_HEADER = 4 + 4;
    FILE_LENGTH_OFFSET = 4;
    ENTRY_LENGTH_OFFSET = 4;
    ICON_TYPE_SIZE = {
      ICON: 32,
      "ICN#": 32,
      // m => 16 x 16
      "icm#": 16,
      icm4: 16,
      icm8: 16,
      // s => 16 x 16
      "ics#": 16,
      ics4: 16,
      ics8: 16,
      is32: 16,
      s8mk: 16,
      icp4: 16,
      // l => 32 x 32
      icl4: 32,
      icl8: 32,
      il32: 32,
      l8mk: 32,
      icp5: 32,
      ic11: 32,
      // h => 48 x 48
      ich4: 48,
      ich8: 48,
      ih32: 48,
      h8mk: 48,
      // . => 64 x 64
      icp6: 64,
      ic12: 32,
      // t => 128 x 128
      it32: 128,
      t8mk: 128,
      ic07: 128,
      // . => 256 x 256
      ic08: 256,
      ic13: 256,
      // . => 512 x 512
      ic09: 512,
      ic14: 512,
      // . => 1024 x 1024
      ic10: 1024
    };
    __name(readImageHeader, "readImageHeader");
    __name(getImageSize, "getImageSize");
    ICNS = {
      validate: /* @__PURE__ */ __name((input) => toUTF8String(input, 0, 4) === "icns", "validate"),
      calculate(input) {
        const inputLength = input.length;
        const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
        let imageOffset = SIZE_HEADER;
        let imageHeader = readImageHeader(input, imageOffset);
        let imageSize = getImageSize(imageHeader[0]);
        imageOffset += imageHeader[1];
        if (imageOffset === fileLength) return imageSize;
        const result = {
          height: imageSize.height,
          images: [imageSize],
          width: imageSize.width
        };
        while (imageOffset < fileLength && imageOffset < inputLength) {
          imageHeader = readImageHeader(input, imageOffset);
          imageSize = getImageSize(imageHeader[0]);
          imageOffset += imageHeader[1];
          result.images.push(imageSize);
        }
        return result;
      }
    };
    J2C = {
      // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
      validate: /* @__PURE__ */ __name((input) => toHexString(input, 0, 4) === "ff4fff51", "validate"),
      calculate: /* @__PURE__ */ __name((input) => ({
        height: readUInt32BE(input, 12),
        width: readUInt32BE(input, 8)
      }), "calculate")
    };
    JP2 = {
      validate(input) {
        if (readUInt32BE(input, 4) !== 1783636e3 || readUInt32BE(input, 0) < 1) return false;
        const ftypBox = findBox(input, "ftyp", 0);
        if (!ftypBox) return false;
        return readUInt32BE(input, ftypBox.offset + 4) === 1718909296;
      },
      calculate(input) {
        const jp2hBox = findBox(input, "jp2h", 0);
        const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
        if (ihdrBox) {
          return {
            height: readUInt32BE(input, ihdrBox.offset + 8),
            width: readUInt32BE(input, ihdrBox.offset + 12)
          };
        }
        throw new TypeError("Unsupported JPEG 2000 format");
      }
    };
    EXIF_MARKER = "45786966";
    APP1_DATA_SIZE_BYTES = 2;
    EXIF_HEADER_BYTES = 6;
    TIFF_BYTE_ALIGN_BYTES = 2;
    BIG_ENDIAN_BYTE_ALIGN = "4d4d";
    LITTLE_ENDIAN_BYTE_ALIGN = "4949";
    IDF_ENTRY_BYTES = 12;
    NUM_DIRECTORY_ENTRIES_BYTES = 2;
    __name(isEXIF, "isEXIF");
    __name(extractSize, "extractSize");
    __name(extractOrientation, "extractOrientation");
    __name(validateExifBlock, "validateExifBlock");
    __name(validateInput, "validateInput");
    JPG = {
      validate: /* @__PURE__ */ __name((input) => toHexString(input, 0, 2) === "ffd8", "validate"),
      calculate(input) {
        input = input.slice(4);
        let orientation;
        let next;
        while (input.length) {
          const i2 = readUInt16BE(input, 0);
          if (input[i2] !== 255) {
            input = input.slice(i2);
            continue;
          }
          if (isEXIF(input)) {
            orientation = validateExifBlock(input, i2);
          }
          validateInput(input, i2);
          next = input[i2 + 1];
          if (next === 192 || next === 193 || next === 194) {
            const size = extractSize(input, i2 + 5);
            if (!orientation) {
              return size;
            }
            return {
              height: size.height,
              orientation,
              width: size.width
            };
          }
          input = input.slice(i2 + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
    };
    KTX = {
      validate: /* @__PURE__ */ __name((input) => {
        const signature = toUTF8String(input, 1, 7);
        return ["KTX 11", "KTX 20"].includes(signature);
      }, "validate"),
      calculate: /* @__PURE__ */ __name((input) => {
        const type = input[5] === 49 ? "ktx" : "ktx2";
        const offset = type === "ktx" ? 36 : 20;
        return {
          height: readUInt32LE(input, offset + 4),
          width: readUInt32LE(input, offset),
          type
        };
      }, "calculate")
    };
    pngSignature = "PNG\r\n\n";
    pngImageHeaderChunkName = "IHDR";
    pngFriedChunkName = "CgBI";
    PNG = {
      validate(input) {
        if (pngSignature === toUTF8String(input, 1, 8)) {
          let chunkName = toUTF8String(input, 12, 16);
          if (chunkName === pngFriedChunkName) {
            chunkName = toUTF8String(input, 28, 32);
          }
          if (chunkName !== pngImageHeaderChunkName) {
            throw new TypeError("Invalid PNG");
          }
          return true;
        }
        return false;
      },
      calculate(input) {
        if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
          return {
            height: readUInt32BE(input, 36),
            width: readUInt32BE(input, 32)
          };
        }
        return {
          height: readUInt32BE(input, 20),
          width: readUInt32BE(input, 16)
        };
      }
    };
    PNMTypes = {
      P1: "pbm/ascii",
      P2: "pgm/ascii",
      P3: "ppm/ascii",
      P4: "pbm",
      P5: "pgm",
      P6: "ppm",
      P7: "pam",
      PF: "pfm"
    };
    handlers = {
      default: /* @__PURE__ */ __name((lines) => {
        let dimensions = [];
        while (lines.length > 0) {
          const line = lines.shift();
          if (line[0] === "#") {
            continue;
          }
          dimensions = line.split(" ");
          break;
        }
        if (dimensions.length === 2) {
          return {
            height: parseInt(dimensions[1], 10),
            width: parseInt(dimensions[0], 10)
          };
        } else {
          throw new TypeError("Invalid PNM");
        }
      }, "default"),
      pam: /* @__PURE__ */ __name((lines) => {
        const size = {};
        while (lines.length > 0) {
          const line = lines.shift();
          if (line.length > 16 || line.charCodeAt(0) > 128) {
            continue;
          }
          const [key, value] = line.split(" ");
          if (key && value) {
            size[key.toLowerCase()] = parseInt(value, 10);
          }
          if (size.height && size.width) {
            break;
          }
        }
        if (size.height && size.width) {
          return {
            height: size.height,
            width: size.width
          };
        } else {
          throw new TypeError("Invalid PAM");
        }
      }, "pam")
    };
    PNM = {
      validate: /* @__PURE__ */ __name((input) => toUTF8String(input, 0, 2) in PNMTypes, "validate"),
      calculate(input) {
        const signature = toUTF8String(input, 0, 2);
        const type = PNMTypes[signature];
        const lines = toUTF8String(input, 3).split(/[\r\n]+/);
        const handler = handlers[type] || handlers.default;
        return handler(lines);
      }
    };
    PSD = {
      validate: /* @__PURE__ */ __name((input) => toUTF8String(input, 0, 4) === "8BPS", "validate"),
      calculate: /* @__PURE__ */ __name((input) => ({
        height: readUInt32BE(input, 14),
        width: readUInt32BE(input, 18)
      }), "calculate")
    };
    svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
    extractorRegExps = {
      height: /\sheight=(['"])([^%]+?)\1/,
      root: svgReg,
      viewbox: /\sviewBox=(['"])(.+?)\1/i,
      width: /\swidth=(['"])([^%]+?)\1/
    };
    INCH_CM = 2.54;
    units = {
      in: 96,
      cm: 96 / INCH_CM,
      em: 16,
      ex: 8,
      m: 96 / INCH_CM * 100,
      mm: 96 / INCH_CM / 10,
      pc: 96 / 72 / 12,
      pt: 96 / 72,
      px: 1
    };
    unitsReg = new RegExp(
      `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
    );
    __name(parseLength, "parseLength");
    __name(parseViewbox, "parseViewbox");
    __name(parseAttributes, "parseAttributes");
    __name(calculateByDimensions, "calculateByDimensions");
    __name(calculateByViewbox, "calculateByViewbox");
    SVG = {
      // Scan only the first kilo-byte to speed up the check on larger files
      validate: /* @__PURE__ */ __name((input) => svgReg.test(toUTF8String(input, 0, 1e3)), "validate"),
      calculate(input) {
        const root = extractorRegExps.root.exec(toUTF8String(input));
        if (root) {
          const attrs = parseAttributes(root[0]);
          if (attrs.width && attrs.height) {
            return calculateByDimensions(attrs);
          }
          if (attrs.viewbox) {
            return calculateByViewbox(attrs, attrs.viewbox);
          }
        }
        throw new TypeError("Invalid SVG");
      }
    };
    TGA = {
      validate(input) {
        return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
      },
      calculate(input) {
        return {
          height: readUInt16LE(input, 14),
          width: readUInt16LE(input, 12)
        };
      }
    };
    __name(readIFD, "readIFD");
    __name(readValue, "readValue");
    __name(nextTag, "nextTag");
    __name(extractTags, "extractTags");
    __name(determineEndianness, "determineEndianness");
    signatures = [
      // '492049', // currently not supported
      "49492a00",
      // Little endian
      "4d4d002a"
      // Big Endian
      // '4d4d002a', // BigTIFF > 4GB. currently not supported
    ];
    TIFF = {
      validate: /* @__PURE__ */ __name((input) => signatures.includes(toHexString(input, 0, 4)), "validate"),
      calculate(input) {
        const isBigEndian = determineEndianness(input) === "BE";
        const ifdBuffer = readIFD(input, isBigEndian);
        const tags2 = extractTags(ifdBuffer, isBigEndian);
        const width = tags2[256];
        const height = tags2[257];
        if (!width || !height) {
          throw new TypeError("Invalid Tiff. Missing tags");
        }
        return { height, width };
      }
    };
    __name(calculateExtended, "calculateExtended");
    __name(calculateLossless, "calculateLossless");
    __name(calculateLossy, "calculateLossy");
    WEBP = {
      validate(input) {
        const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
        const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
        const vp8Header = "VP8" === toUTF8String(input, 12, 15);
        return riffHeader && webpHeader && vp8Header;
      },
      calculate(input) {
        const chunkHeader = toUTF8String(input, 12, 16);
        input = input.slice(20, 30);
        if (chunkHeader === "VP8X") {
          const extendedHeader = input[0];
          const validStart = (extendedHeader & 192) === 0;
          const validEnd = (extendedHeader & 1) === 0;
          if (validStart && validEnd) {
            return calculateExtended(input);
          } else {
            throw new TypeError("Invalid WebP");
          }
        }
        if (chunkHeader === "VP8 " && input[0] !== 47) {
          return calculateLossy(input);
        }
        const signature = toHexString(input, 3, 6);
        if (chunkHeader === "VP8L" && signature !== "9d012a") {
          return calculateLossless(input);
        }
        throw new TypeError("Invalid WebP");
      }
    };
    typeHandlers = /* @__PURE__ */ new Map([
      ["bmp", BMP],
      ["cur", CUR],
      ["dds", DDS],
      ["gif", GIF],
      ["heif", HEIF],
      ["icns", ICNS],
      ["ico", ICO],
      ["j2c", J2C],
      ["jp2", JP2],
      ["jpg", JPG],
      ["ktx", KTX],
      ["png", PNG],
      ["pnm", PNM],
      ["psd", PSD],
      ["svg", SVG],
      ["tga", TGA],
      ["tiff", TIFF],
      ["webp", WEBP]
    ]);
    types = Array.from(typeHandlers.keys());
    firstBytes = /* @__PURE__ */ new Map([
      [56, "psd"],
      [66, "bmp"],
      [68, "dds"],
      [71, "gif"],
      [73, "tiff"],
      [77, "tiff"],
      [82, "webp"],
      [105, "icns"],
      [137, "png"],
      [255, "jpg"]
    ]);
    __name(detector, "detector");
    __name(lookup$1, "lookup$1");
    __name(imageMetadata, "imageMetadata");
    __name(inferRemoteSize, "inferRemoteSize");
    PLACEHOLDER_BASE = "astro://placeholder";
    __name(createPlaceholderURL, "createPlaceholderURL");
    __name(stringifyPlaceholderURL, "stringifyPlaceholderURL");
    __name(getConfiguredImageService, "getConfiguredImageService");
    __name(getImage$1, "getImage$1");
    $$Astro$2 = createAstro("https://localhost:4321");
    $$Image = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$2, $$props, $$slots);
      Astro2.self = $$Image;
      const props = Astro2.props;
      if (props.alt === void 0 || props.alt === null) {
        throw new AstroError(ImageMissingAlt);
      }
      if (typeof props.width === "string") {
        props.width = parseInt(props.width);
      }
      if (typeof props.height === "string") {
        props.height = parseInt(props.height);
      }
      const layout = props.layout ?? imageConfig.layout ?? "none";
      if (layout !== "none") {
        props.layout ??= imageConfig.layout;
        props.fit ??= imageConfig.objectFit ?? "cover";
        props.position ??= imageConfig.objectPosition ?? "center";
      }
      const image = await getImage(props);
      const additionalAttributes = {};
      if (image.srcSet.values.length > 0) {
        additionalAttributes.srcset = image.srcSet.attribute;
      }
      const { class: className, ...attributes } = { ...additionalAttributes, ...image.attributes };
      return renderTemplate`${maybeRenderHead()}<img${addAttribute(image.src, "src")}${spreadAttributes(attributes)}${addAttribute(className, "class")}>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/astro@5.16.6_@types+node@25_fe4d1830cdec2e66cb5e3dbb9af723fd/node_modules/astro/components/Image.astro", void 0);
    mimes = {
      "3g2": "video/3gpp2",
      "3gp": "video/3gpp",
      "3gpp": "video/3gpp",
      "3mf": "model/3mf",
      "aac": "audio/aac",
      "ac": "application/pkix-attr-cert",
      "adp": "audio/adpcm",
      "adts": "audio/aac",
      "ai": "application/postscript",
      "aml": "application/automationml-aml+xml",
      "amlx": "application/automationml-amlx+zip",
      "amr": "audio/amr",
      "apng": "image/apng",
      "appcache": "text/cache-manifest",
      "appinstaller": "application/appinstaller",
      "appx": "application/appx",
      "appxbundle": "application/appxbundle",
      "asc": "application/pgp-keys",
      "atom": "application/atom+xml",
      "atomcat": "application/atomcat+xml",
      "atomdeleted": "application/atomdeleted+xml",
      "atomsvc": "application/atomsvc+xml",
      "au": "audio/basic",
      "avci": "image/avci",
      "avcs": "image/avcs",
      "avif": "image/avif",
      "aw": "application/applixware",
      "bdoc": "application/bdoc",
      "bin": "application/octet-stream",
      "bmp": "image/bmp",
      "bpk": "application/octet-stream",
      "btf": "image/prs.btif",
      "btif": "image/prs.btif",
      "buffer": "application/octet-stream",
      "ccxml": "application/ccxml+xml",
      "cdfx": "application/cdfx+xml",
      "cdmia": "application/cdmi-capability",
      "cdmic": "application/cdmi-container",
      "cdmid": "application/cdmi-domain",
      "cdmio": "application/cdmi-object",
      "cdmiq": "application/cdmi-queue",
      "cer": "application/pkix-cert",
      "cgm": "image/cgm",
      "cjs": "application/node",
      "class": "application/java-vm",
      "coffee": "text/coffeescript",
      "conf": "text/plain",
      "cpl": "application/cpl+xml",
      "cpt": "application/mac-compactpro",
      "crl": "application/pkix-crl",
      "css": "text/css",
      "csv": "text/csv",
      "cu": "application/cu-seeme",
      "cwl": "application/cwl",
      "cww": "application/prs.cww",
      "davmount": "application/davmount+xml",
      "dbk": "application/docbook+xml",
      "deb": "application/octet-stream",
      "def": "text/plain",
      "deploy": "application/octet-stream",
      "dib": "image/bmp",
      "disposition-notification": "message/disposition-notification",
      "dist": "application/octet-stream",
      "distz": "application/octet-stream",
      "dll": "application/octet-stream",
      "dmg": "application/octet-stream",
      "dms": "application/octet-stream",
      "doc": "application/msword",
      "dot": "application/msword",
      "dpx": "image/dpx",
      "drle": "image/dicom-rle",
      "dsc": "text/prs.lines.tag",
      "dssc": "application/dssc+der",
      "dtd": "application/xml-dtd",
      "dump": "application/octet-stream",
      "dwd": "application/atsc-dwd+xml",
      "ear": "application/java-archive",
      "ecma": "application/ecmascript",
      "elc": "application/octet-stream",
      "emf": "image/emf",
      "eml": "message/rfc822",
      "emma": "application/emma+xml",
      "emotionml": "application/emotionml+xml",
      "eps": "application/postscript",
      "epub": "application/epub+zip",
      "exe": "application/octet-stream",
      "exi": "application/exi",
      "exp": "application/express",
      "exr": "image/aces",
      "ez": "application/andrew-inset",
      "fdf": "application/fdf",
      "fdt": "application/fdt+xml",
      "fits": "image/fits",
      "g3": "image/g3fax",
      "gbr": "application/rpki-ghostbusters",
      "geojson": "application/geo+json",
      "gif": "image/gif",
      "glb": "model/gltf-binary",
      "gltf": "model/gltf+json",
      "gml": "application/gml+xml",
      "gpx": "application/gpx+xml",
      "gram": "application/srgs",
      "grxml": "application/srgs+xml",
      "gxf": "application/gxf",
      "gz": "application/gzip",
      "h261": "video/h261",
      "h263": "video/h263",
      "h264": "video/h264",
      "heic": "image/heic",
      "heics": "image/heic-sequence",
      "heif": "image/heif",
      "heifs": "image/heif-sequence",
      "hej2": "image/hej2k",
      "held": "application/atsc-held+xml",
      "hjson": "application/hjson",
      "hlp": "application/winhlp",
      "hqx": "application/mac-binhex40",
      "hsj2": "image/hsj2",
      "htm": "text/html",
      "html": "text/html",
      "ics": "text/calendar",
      "ief": "image/ief",
      "ifb": "text/calendar",
      "iges": "model/iges",
      "igs": "model/iges",
      "img": "application/octet-stream",
      "in": "text/plain",
      "ini": "text/plain",
      "ink": "application/inkml+xml",
      "inkml": "application/inkml+xml",
      "ipfix": "application/ipfix",
      "iso": "application/octet-stream",
      "its": "application/its+xml",
      "jade": "text/jade",
      "jar": "application/java-archive",
      "jhc": "image/jphc",
      "jls": "image/jls",
      "jp2": "image/jp2",
      "jpe": "image/jpeg",
      "jpeg": "image/jpeg",
      "jpf": "image/jpx",
      "jpg": "image/jpeg",
      "jpg2": "image/jp2",
      "jpgm": "image/jpm",
      "jpgv": "video/jpeg",
      "jph": "image/jph",
      "jpm": "image/jpm",
      "jpx": "image/jpx",
      "js": "text/javascript",
      "json": "application/json",
      "json5": "application/json5",
      "jsonld": "application/ld+json",
      "jsonml": "application/jsonml+json",
      "jsx": "text/jsx",
      "jt": "model/jt",
      "jxl": "image/jxl",
      "jxr": "image/jxr",
      "jxra": "image/jxra",
      "jxrs": "image/jxrs",
      "jxs": "image/jxs",
      "jxsc": "image/jxsc",
      "jxsi": "image/jxsi",
      "jxss": "image/jxss",
      "kar": "audio/midi",
      "ktx": "image/ktx",
      "ktx2": "image/ktx2",
      "less": "text/less",
      "lgr": "application/lgr+xml",
      "list": "text/plain",
      "litcoffee": "text/coffeescript",
      "log": "text/plain",
      "lostxml": "application/lost+xml",
      "lrf": "application/octet-stream",
      "m1v": "video/mpeg",
      "m21": "application/mp21",
      "m2a": "audio/mpeg",
      "m2t": "video/mp2t",
      "m2ts": "video/mp2t",
      "m2v": "video/mpeg",
      "m3a": "audio/mpeg",
      "m4a": "audio/mp4",
      "m4p": "application/mp4",
      "m4s": "video/iso.segment",
      "ma": "application/mathematica",
      "mads": "application/mads+xml",
      "maei": "application/mmt-aei+xml",
      "man": "text/troff",
      "manifest": "text/cache-manifest",
      "map": "application/json",
      "mar": "application/octet-stream",
      "markdown": "text/markdown",
      "mathml": "application/mathml+xml",
      "mb": "application/mathematica",
      "mbox": "application/mbox",
      "md": "text/markdown",
      "mdx": "text/mdx",
      "me": "text/troff",
      "mesh": "model/mesh",
      "meta4": "application/metalink4+xml",
      "metalink": "application/metalink+xml",
      "mets": "application/mets+xml",
      "mft": "application/rpki-manifest",
      "mid": "audio/midi",
      "midi": "audio/midi",
      "mime": "message/rfc822",
      "mj2": "video/mj2",
      "mjp2": "video/mj2",
      "mjs": "text/javascript",
      "mml": "text/mathml",
      "mods": "application/mods+xml",
      "mov": "video/quicktime",
      "mp2": "audio/mpeg",
      "mp21": "application/mp21",
      "mp2a": "audio/mpeg",
      "mp3": "audio/mpeg",
      "mp4": "video/mp4",
      "mp4a": "audio/mp4",
      "mp4s": "application/mp4",
      "mp4v": "video/mp4",
      "mpd": "application/dash+xml",
      "mpe": "video/mpeg",
      "mpeg": "video/mpeg",
      "mpf": "application/media-policy-dataset+xml",
      "mpg": "video/mpeg",
      "mpg4": "video/mp4",
      "mpga": "audio/mpeg",
      "mpp": "application/dash-patch+xml",
      "mrc": "application/marc",
      "mrcx": "application/marcxml+xml",
      "ms": "text/troff",
      "mscml": "application/mediaservercontrol+xml",
      "msh": "model/mesh",
      "msi": "application/octet-stream",
      "msix": "application/msix",
      "msixbundle": "application/msixbundle",
      "msm": "application/octet-stream",
      "msp": "application/octet-stream",
      "mtl": "model/mtl",
      "mts": "video/mp2t",
      "musd": "application/mmt-usd+xml",
      "mxf": "application/mxf",
      "mxmf": "audio/mobile-xmf",
      "mxml": "application/xv+xml",
      "n3": "text/n3",
      "nb": "application/mathematica",
      "nq": "application/n-quads",
      "nt": "application/n-triples",
      "obj": "model/obj",
      "oda": "application/oda",
      "oga": "audio/ogg",
      "ogg": "audio/ogg",
      "ogv": "video/ogg",
      "ogx": "application/ogg",
      "omdoc": "application/omdoc+xml",
      "onepkg": "application/onenote",
      "onetmp": "application/onenote",
      "onetoc": "application/onenote",
      "onetoc2": "application/onenote",
      "opf": "application/oebps-package+xml",
      "opus": "audio/ogg",
      "otf": "font/otf",
      "owl": "application/rdf+xml",
      "oxps": "application/oxps",
      "p10": "application/pkcs10",
      "p7c": "application/pkcs7-mime",
      "p7m": "application/pkcs7-mime",
      "p7s": "application/pkcs7-signature",
      "p8": "application/pkcs8",
      "pdf": "application/pdf",
      "pfr": "application/font-tdpfr",
      "pgp": "application/pgp-encrypted",
      "pkg": "application/octet-stream",
      "pki": "application/pkixcmp",
      "pkipath": "application/pkix-pkipath",
      "pls": "application/pls+xml",
      "png": "image/png",
      "prc": "model/prc",
      "prf": "application/pics-rules",
      "provx": "application/provenance+xml",
      "ps": "application/postscript",
      "pskcxml": "application/pskc+xml",
      "pti": "image/prs.pti",
      "qt": "video/quicktime",
      "raml": "application/raml+yaml",
      "rapd": "application/route-apd+xml",
      "rdf": "application/rdf+xml",
      "relo": "application/p2p-overlay+xml",
      "rif": "application/reginfo+xml",
      "rl": "application/resource-lists+xml",
      "rld": "application/resource-lists-diff+xml",
      "rmi": "audio/midi",
      "rnc": "application/relax-ng-compact-syntax",
      "rng": "application/xml",
      "roa": "application/rpki-roa",
      "roff": "text/troff",
      "rq": "application/sparql-query",
      "rs": "application/rls-services+xml",
      "rsat": "application/atsc-rsat+xml",
      "rsd": "application/rsd+xml",
      "rsheet": "application/urc-ressheet+xml",
      "rss": "application/rss+xml",
      "rtf": "text/rtf",
      "rtx": "text/richtext",
      "rusd": "application/route-usd+xml",
      "s3m": "audio/s3m",
      "sbml": "application/sbml+xml",
      "scq": "application/scvp-cv-request",
      "scs": "application/scvp-cv-response",
      "sdp": "application/sdp",
      "senmlx": "application/senml+xml",
      "sensmlx": "application/sensml+xml",
      "ser": "application/java-serialized-object",
      "setpay": "application/set-payment-initiation",
      "setreg": "application/set-registration-initiation",
      "sgi": "image/sgi",
      "sgm": "text/sgml",
      "sgml": "text/sgml",
      "shex": "text/shex",
      "shf": "application/shf+xml",
      "shtml": "text/html",
      "sieve": "application/sieve",
      "sig": "application/pgp-signature",
      "sil": "audio/silk",
      "silo": "model/mesh",
      "siv": "application/sieve",
      "slim": "text/slim",
      "slm": "text/slim",
      "sls": "application/route-s-tsid+xml",
      "smi": "application/smil+xml",
      "smil": "application/smil+xml",
      "snd": "audio/basic",
      "so": "application/octet-stream",
      "spdx": "text/spdx",
      "spp": "application/scvp-vp-response",
      "spq": "application/scvp-vp-request",
      "spx": "audio/ogg",
      "sql": "application/sql",
      "sru": "application/sru+xml",
      "srx": "application/sparql-results+xml",
      "ssdl": "application/ssdl+xml",
      "ssml": "application/ssml+xml",
      "stk": "application/hyperstudio",
      "stl": "model/stl",
      "stpx": "model/step+xml",
      "stpxz": "model/step-xml+zip",
      "stpz": "model/step+zip",
      "styl": "text/stylus",
      "stylus": "text/stylus",
      "svg": "image/svg+xml",
      "svgz": "image/svg+xml",
      "swidtag": "application/swid+xml",
      "t": "text/troff",
      "t38": "image/t38",
      "td": "application/urc-targetdesc+xml",
      "tei": "application/tei+xml",
      "teicorpus": "application/tei+xml",
      "text": "text/plain",
      "tfi": "application/thraud+xml",
      "tfx": "image/tiff-fx",
      "tif": "image/tiff",
      "tiff": "image/tiff",
      "toml": "application/toml",
      "tr": "text/troff",
      "trig": "application/trig",
      "ts": "video/mp2t",
      "tsd": "application/timestamped-data",
      "tsv": "text/tab-separated-values",
      "ttc": "font/collection",
      "ttf": "font/ttf",
      "ttl": "text/turtle",
      "ttml": "application/ttml+xml",
      "txt": "text/plain",
      "u3d": "model/u3d",
      "u8dsn": "message/global-delivery-status",
      "u8hdr": "message/global-headers",
      "u8mdn": "message/global-disposition-notification",
      "u8msg": "message/global",
      "ubj": "application/ubjson",
      "uri": "text/uri-list",
      "uris": "text/uri-list",
      "urls": "text/uri-list",
      "vcard": "text/vcard",
      "vrml": "model/vrml",
      "vtt": "text/vtt",
      "vxml": "application/voicexml+xml",
      "war": "application/java-archive",
      "wasm": "application/wasm",
      "wav": "audio/wav",
      "weba": "audio/webm",
      "webm": "video/webm",
      "webmanifest": "application/manifest+json",
      "webp": "image/webp",
      "wgsl": "text/wgsl",
      "wgt": "application/widget",
      "wif": "application/watcherinfo+xml",
      "wmf": "image/wmf",
      "woff": "font/woff",
      "woff2": "font/woff2",
      "wrl": "model/vrml",
      "wsdl": "application/wsdl+xml",
      "wspolicy": "application/wspolicy+xml",
      "x3d": "model/x3d+xml",
      "x3db": "model/x3d+fastinfoset",
      "x3dbz": "model/x3d+binary",
      "x3dv": "model/x3d-vrml",
      "x3dvz": "model/x3d+vrml",
      "x3dz": "model/x3d+xml",
      "xaml": "application/xaml+xml",
      "xav": "application/xcap-att+xml",
      "xca": "application/xcap-caps+xml",
      "xcs": "application/calendar+xml",
      "xdf": "application/xcap-diff+xml",
      "xdssc": "application/dssc+xml",
      "xel": "application/xcap-el+xml",
      "xenc": "application/xenc+xml",
      "xer": "application/patch-ops-error+xml",
      "xfdf": "application/xfdf",
      "xht": "application/xhtml+xml",
      "xhtml": "application/xhtml+xml",
      "xhvml": "application/xv+xml",
      "xlf": "application/xliff+xml",
      "xm": "audio/xm",
      "xml": "text/xml",
      "xns": "application/xcap-ns+xml",
      "xop": "application/xop+xml",
      "xpl": "application/xproc+xml",
      "xsd": "application/xml",
      "xsf": "application/prs.xsf+xml",
      "xsl": "application/xml",
      "xslt": "application/xml",
      "xspf": "application/xspf+xml",
      "xvm": "application/xv+xml",
      "xvml": "application/xv+xml",
      "yaml": "text/yaml",
      "yang": "application/yang",
      "yin": "application/yin+xml",
      "yml": "text/yaml",
      "zip": "application/zip"
    };
    __name(lookup, "lookup");
    $$Astro$1 = createAstro("https://localhost:4321");
    $$Picture = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
      Astro2.self = $$Picture;
      const defaultFormats = ["webp"];
      const defaultFallbackFormat = "png";
      const specialFormatsFallback = ["gif", "svg", "jpg", "jpeg"];
      const { formats = defaultFormats, pictureAttributes = {}, fallbackFormat, ...props } = Astro2.props;
      if (props.alt === void 0 || props.alt === null) {
        throw new AstroError(ImageMissingAlt);
      }
      const scopedStyleClass = props.class?.match(/\bastro-\w{8}\b/)?.[0];
      if (scopedStyleClass) {
        if (pictureAttributes.class) {
          pictureAttributes.class = `${pictureAttributes.class} ${scopedStyleClass}`;
        } else {
          pictureAttributes.class = scopedStyleClass;
        }
      }
      const layout = props.layout ?? imageConfig.layout ?? "none";
      const useResponsive = layout !== "none";
      if (useResponsive) {
        props.layout ??= imageConfig.layout;
        props.fit ??= imageConfig.objectFit ?? "cover";
        props.position ??= imageConfig.objectPosition ?? "center";
      }
      for (const key in props) {
        if (key.startsWith("data-astro-cid")) {
          pictureAttributes[key] = props[key];
        }
      }
      const originalSrc = await resolveSrc(props.src);
      const optimizedImages = await Promise.all(
        formats.map(
          async (format) => await getImage({
            ...props,
            src: originalSrc,
            format,
            widths: props.widths,
            densities: props.densities
          })
        )
      );
      let resultFallbackFormat = fallbackFormat ?? defaultFallbackFormat;
      if (!fallbackFormat && isESMImportedImage(originalSrc) && specialFormatsFallback.includes(originalSrc.format)) {
        resultFallbackFormat = originalSrc.format;
      }
      const fallbackImage = await getImage({
        ...props,
        format: resultFallbackFormat,
        widths: props.widths,
        densities: props.densities
      });
      const imgAdditionalAttributes = {};
      const sourceAdditionalAttributes = {};
      if (props.sizes) {
        sourceAdditionalAttributes.sizes = props.sizes;
      }
      if (fallbackImage.srcSet.values.length > 0) {
        imgAdditionalAttributes.srcset = fallbackImage.srcSet.attribute;
      }
      const { class: className, ...attributes } = {
        ...imgAdditionalAttributes,
        ...fallbackImage.attributes
      };
      return renderTemplate`${maybeRenderHead()}<picture${spreadAttributes(pictureAttributes)}> ${Object.entries(optimizedImages).map(([_, image]) => {
        const srcsetAttribute = props.densities || !props.densities && !props.widths && !useResponsive ? `${image.src}${image.srcSet.values.length > 0 ? ", " + image.srcSet.attribute : ""}` : image.srcSet.attribute;
        return renderTemplate`<source${addAttribute(srcsetAttribute, "srcset")}${addAttribute(lookup(image.options.format ?? image.src) ?? `image/${image.options.format}`, "type")}${spreadAttributes(sourceAdditionalAttributes)}>`;
      })}  <img${addAttribute(fallbackImage.src, "src")}${spreadAttributes(attributes)}${addAttribute(className, "class")}> </picture>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/astro@5.16.6_@types+node@25_fe4d1830cdec2e66cb5e3dbb9af723fd/node_modules/astro/components/Picture.astro", void 0);
    fontsMod = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null
    }, Symbol.toStringTag, { value: "Module" }));
    __name(filterPreloads, "filterPreloads");
    __name(checkWeight, "checkWeight");
    $$Astro = createAstro("https://localhost:4321");
    $$Font = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
      Astro2.self = $$Font;
      const { internalConsumableMap } = fontsMod;
      if (!internalConsumableMap) {
        throw new AstroError(ExperimentalFontsNotEnabled);
      }
      const { cssVariable, preload = false } = Astro2.props;
      const data = internalConsumableMap.get(cssVariable);
      if (!data) {
        throw new AstroError({
          ...FontFamilyNotFound,
          message: FontFamilyNotFound.message(cssVariable)
        });
      }
      const filteredPreloadData = filterPreloads(data.preloadData, preload);
      return renderTemplate`<style>${unescapeHTML(data.css)}</style>${filteredPreloadData?.map(({ url, type }) => renderTemplate`<link rel="preload"${addAttribute(url, "href")} as="font"${addAttribute(`font/${type}`, "type")} crossorigin>`)}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/astro@5.16.6_@types+node@25_fe4d1830cdec2e66cb5e3dbb9af723fd/node_modules/astro/components/Font.astro", void 0);
    assetQueryParams = void 0;
    imageConfig = { "endpoint": { "route": "/_image", "entrypoint": "@astrojs/cloudflare/image-endpoint" }, "service": { "entrypoint": "astro/assets/services/sharp", "config": {} }, "domains": [], "remotePatterns": [], "responsiveStyles": false };
    Object.defineProperty(imageConfig, "assetQueryParams", {
      value: assetQueryParams,
      enumerable: false,
      configurable: true
    });
    getImage = /* @__PURE__ */ __name(async (options) => await getImage$1(options, imageConfig), "getImage");
    prerender = false;
    GET = /* @__PURE__ */ __name((ctx) => {
      const href = ctx.url.searchParams.get("href");
      if (!href) {
        return new Response("Missing 'href' query parameter", {
          status: 400,
          statusText: "Missing 'href' query parameter"
        });
      }
      if (isRemotePath(href)) {
        if (isRemoteAllowed(href, imageConfig) === false) {
          return new Response("Forbidden", { status: 403 });
        } else {
          return Response.redirect(href, 302);
        }
      }
      const proxied = new URL(href, ctx.url.origin);
      if (proxied.origin !== ctx.url.origin) {
        return new Response("Forbidden", { status: 403 });
      }
      return fetch(proxied);
    }, "GET");
    _page = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET,
      prerender
    }, Symbol.toStringTag, { value: "Module" }));
    page = /* @__PURE__ */ __name(() => _page, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/_image.astro.mjs
var image_astro_exports = {};
__export(image_astro_exports, {
  page: () => page,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3;
var init_image_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/_image.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_image_endpoint_D6uoC0U6();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/Layout_DDkk2Mp3.mjs
var MessagePort4, MessageChannelPolyfill3, SITE_TITLE, $$Astro$22, $$BaseHead, $$Astro$12, $$Header, $$Footer, $$Astro2, $$Layout;
var init_Layout_DDkk2Mp3 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/Layout_DDkk2Mp3.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    SITE_TITLE = "Astro Blog";
    $$Astro$22 = createAstro("https://localhost:4321");
    $$BaseHead = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$22, $$props, $$slots);
      Astro2.self = $$BaseHead;
      const FALLBACK_IMAGE_URL = "https://images.unsplash.com/photo-1546069901-ba9599a7e63c?w=1200&h=630&fit=crop";
      const siteUrl = Astro2.site?.toString() || Astro2.url.origin;
      const canonicalURL = new URL(Astro2.url.pathname, siteUrl);
      const { title: title3, description, image } = Astro2.props;
      const imageSrc = image ? typeof image === "string" ? image : image.src : FALLBACK_IMAGE_URL;
      const imageUrl = new URL(imageSrc, siteUrl);
      return renderTemplate`<!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><!-- Favicons - use uploaded if available, otherwise fallback -->${renderTemplate`<link rel="icon" type="image/svg+xml" href="/logos/favicon.svg">`}${renderTemplate`<link rel="icon" type="image/png" sizes="32x32" href="/logos/favicon-32x32.png">`}${renderTemplate`<link rel="icon" type="image/png" sizes="16x16" href="/logos/favicon-16x16.png">`}${renderTemplate`<link rel="apple-touch-icon" sizes="180x180" href="/logos/apple-touch-icon.png">`}${renderTemplate`<link rel="manifest" href="/logos/site.webmanifest">`}<link rel="sitemap"${addAttribute(new URL("sitemap-index.xml", siteUrl), "href")}><link rel="alternate" type="application/rss+xml"${addAttribute(SITE_TITLE, "title")}${addAttribute(new URL("rss.xml", siteUrl), "href")}><meta name="generator"${addAttribute(Astro2.generator, "content")}><!-- Font preloads - Using Google Fonts for Atkinson Hyperlegible --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical"${addAttribute(canonicalURL, "href")}><!-- Primary Meta Tags --><title>${title3}</title><meta name="title"${addAttribute(title3, "content")}><meta name="description"${addAttribute(description, "content")}><meta name="robots" content="index, follow"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url"${addAttribute(canonicalURL, "content")}><meta property="og:title"${addAttribute(title3, "content")}><meta property="og:description"${addAttribute(description, "content")}><meta property="og:image"${addAttribute(imageUrl, "content")}><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url"${addAttribute(canonicalURL, "content")}><meta property="twitter:title"${addAttribute(title3, "content")}><meta property="twitter:description"${addAttribute(description, "content")}><meta property="twitter:image"${addAttribute(imageUrl, "content")}>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/BaseHead.astro", void 0);
    $$Astro$12 = createAstro("https://localhost:4321");
    $$Header = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$12, $$props, $$slots);
      Astro2.self = $$Header;
      const currentPath = Astro2.url.pathname;
      const logoMain = "/logos/logo-main.png";
      return renderTemplate`${maybeRenderHead()}<header class="site-header" data-astro-cid-3ef6ksr2> <a href="#main-content" class="skip-link" data-astro-cid-3ef6ksr2>Skip to content</a> <div class="header-container" data-astro-cid-3ef6ksr2> <div class="header-content" data-astro-cid-3ef6ksr2> <!-- Logo --> <a href="/" class="logo" data-astro-cid-3ef6ksr2> ${renderTemplate`${renderComponent($$result, "Fragment", Fragment, { "data-astro-cid-3ef6ksr2": true }, { "default": /* @__PURE__ */ __name(($$result2) => renderTemplate` <img${addAttribute(logoMain, "src")} alt="Freecipies" class="logo-img logo-light" width="200" height="60" data-astro-cid-3ef6ksr2> ${renderTemplate`<img${addAttribute(logoMain, "src")} alt="Freecipies" class="logo-img logo-dark" width="200" height="60" data-astro-cid-3ef6ksr2>`}`, "default") })}`} </a> <!-- Desktop Navigation --> <nav class="desktop-nav" data-astro-cid-3ef6ksr2> <a href="/categories"${addAttribute([
        "nav-link",
        { active: currentPath.startsWith("/categories") }
      ], "class:list")} data-astro-cid-3ef6ksr2>
Categories
</a> <a href="/recipes"${addAttribute([
        "nav-link",
        { active: currentPath.startsWith("/recipes") }
      ], "class:list")} data-astro-cid-3ef6ksr2>
Explore
</a> <a href="/authors"${addAttribute([
        "nav-link",
        { active: currentPath.startsWith("/authors") }
      ], "class:list")} data-astro-cid-3ef6ksr2>
Authors
</a> <a href="/about"${addAttribute(["nav-link", { active: currentPath === "/about" }], "class:list")} data-astro-cid-3ef6ksr2>
About
</a> <a href="/contact"${addAttribute(["nav-link", { active: currentPath === "/contact" }], "class:list")} data-astro-cid-3ef6ksr2>
Contact
</a> </nav> <!-- Search & Mobile Menu --> <div class="header-actions" data-astro-cid-3ef6ksr2> <button class="search-btn" aria-label="Search" title="Quick and easy search" aria-controls="search-modal" aria-expanded="false" data-astro-cid-3ef6ksr2> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-3ef6ksr2> <circle cx="11" cy="11" r="8" data-astro-cid-3ef6ksr2></circle> <path d="m21 21-4.35-4.35" data-astro-cid-3ef6ksr2></path> </svg> </button> <button class="mobile-menu-btn" aria-label="Show menu" aria-controls="mobile-nav" aria-expanded="false" data-astro-cid-3ef6ksr2> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-3ef6ksr2> <line x1="3" y1="12" x2="21" y2="12" data-astro-cid-3ef6ksr2></line> <line x1="3" y1="6" x2="21" y2="6" data-astro-cid-3ef6ksr2></line> <line x1="3" y1="18" x2="21" y2="18" data-astro-cid-3ef6ksr2></line> </svg> </button> </div> </div> </div> <!-- Mobile Navigation --> <nav class="mobile-nav" id="mobile-nav" data-astro-cid-3ef6ksr2> <a href="/categories" class="mobile-nav-link" data-astro-cid-3ef6ksr2>Categories</a> <a href="/recipes" class="mobile-nav-link" data-astro-cid-3ef6ksr2>Explore</a> <a href="/authors" class="mobile-nav-link" data-astro-cid-3ef6ksr2>Authors</a> <a href="/about" class="mobile-nav-link" data-astro-cid-3ef6ksr2>About</a> <a href="/contact" class="mobile-nav-link" data-astro-cid-3ef6ksr2>Contact</a> </nav> <!-- Search Modal --> <div class="search-modal" id="search-modal" role="dialog" aria-modal="true" aria-hidden="true" data-astro-cid-3ef6ksr2> <div class="search-modal-content" data-astro-cid-3ef6ksr2> <div class="search-header" data-astro-cid-3ef6ksr2> <h2 id="search-title" data-astro-cid-3ef6ksr2>Search Recipes</h2> <button class="close-search" aria-label="Close search" data-astro-cid-3ef6ksr2> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-3ef6ksr2> <line x1="18" y1="6" x2="6" y2="18" data-astro-cid-3ef6ksr2></line> <line x1="6" y1="6" x2="18" y2="18" data-astro-cid-3ef6ksr2></line> </svg> </button> </div> <form action="/search" method="GET" class="search-form" data-astro-cid-3ef6ksr2> <input type="search" name="q" placeholder="Search for recipes..." autocomplete="off" class="search-input" data-astro-cid-3ef6ksr2> <button type="submit" class="search-submit" data-astro-cid-3ef6ksr2>Search</button> </form> </div> </div> </header>  ${renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Header.astro?astro&type=script&index=0&lang.ts")}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Header.astro", void 0);
    $$Footer = createComponent(($$result, $$props, $$slots) => {
      const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      return renderTemplate`${maybeRenderHead()}<footer class="site-footer" data-astro-cid-sz7xmlte> <div class="footer-container" data-astro-cid-sz7xmlte> <div class="footer-grid" data-astro-cid-sz7xmlte> <!-- Column 1 --> <div class="footer-column" data-astro-cid-sz7xmlte> <h3 data-astro-cid-sz7xmlte>Main Pages</h3> <ul data-astro-cid-sz7xmlte> <li data-astro-cid-sz7xmlte><a href="/" data-astro-cid-sz7xmlte>Home</a></li> <li data-astro-cid-sz7xmlte><a href="/authors" data-astro-cid-sz7xmlte>Writers</a></li> <li data-astro-cid-sz7xmlte><a href="/categories" data-astro-cid-sz7xmlte>Topics</a></li> <li data-astro-cid-sz7xmlte><a href="/tags" data-astro-cid-sz7xmlte>Keywords</a></li> <li data-astro-cid-sz7xmlte><a href="/favorites" data-astro-cid-sz7xmlte>Favorites</a></li> </ul> </div> <!-- Column 2 --> <div class="footer-column" data-astro-cid-sz7xmlte> <h3 data-astro-cid-sz7xmlte>Content</h3> <ul data-astro-cid-sz7xmlte> <li data-astro-cid-sz7xmlte><a href="/recipes" data-astro-cid-sz7xmlte>Discover</a></li> <li data-astro-cid-sz7xmlte><a href="/blog" data-astro-cid-sz7xmlte>Posts</a></li> <li data-astro-cid-sz7xmlte><a href="/recipes" data-astro-cid-sz7xmlte>Recipes</a></li> <li data-astro-cid-sz7xmlte><a href="/about" data-astro-cid-sz7xmlte>About Us</a></li> <li data-astro-cid-sz7xmlte><a href="/privacy" data-astro-cid-sz7xmlte>Privacy</a></li> </ul> </div> <!-- Column 3 --> <div class="footer-column" data-astro-cid-sz7xmlte> <h3 data-astro-cid-sz7xmlte>Support</h3> <ul data-astro-cid-sz7xmlte> <li data-astro-cid-sz7xmlte><a href="/faqs" data-astro-cid-sz7xmlte>FAQs</a></li> <li data-astro-cid-sz7xmlte><a href="/contact" data-astro-cid-sz7xmlte>Contact</a></li> <li data-astro-cid-sz7xmlte><a href="/search" data-astro-cid-sz7xmlte>Search</a></li> <li data-astro-cid-sz7xmlte><a href="/sitemap.xml" data-astro-cid-sz7xmlte>Sitemap</a></li> <li data-astro-cid-sz7xmlte><a href="/rss.xml" data-astro-cid-sz7xmlte>RSS</a></li> </ul> </div> </div> <!-- Social --> <div class="footer-social" data-astro-cid-sz7xmlte> <a href="https://facebook.com" target="_blank" rel="noopener" aria-label="Facebook" data-astro-cid-sz7xmlte> <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-sz7xmlte> <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" data-astro-cid-sz7xmlte></path> </svg> </a> <a href="https://pinterest.com" target="_blank" rel="noopener" aria-label="Pinterest" data-astro-cid-sz7xmlte> <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-sz7xmlte> <path d="M12 0C5.373 0 0 5.372 0 12c0 5.084 3.163 9.426 7.627 11.174-.105-.949-.2-2.405.042-3.441.218-.937 1.407-5.965 1.407-5.965s-.359-.719-.359-1.782c0-1.668.967-2.914 2.171-2.914 1.023 0 1.518.769 1.518 1.69 0 1.029-.655 2.568-.994 3.995-.283 1.194.599 2.169 1.777 2.169 2.133 0 3.772-2.249 3.772-5.495 0-2.873-2.064-4.882-5.012-4.882-3.414 0-5.418 2.561-5.418 5.207 0 1.031.397 2.138.893 2.738.098.119.112.224.083.345l-.333 1.36c-.053.22-.174.267-.402.161-1.499-.698-2.436-2.889-2.436-4.649 0-3.785 2.75-7.262 7.929-7.262 4.163 0 7.398 2.967 7.398 6.931 0 4.136-2.607 7.464-6.227 7.464-1.216 0-2.359-.631-2.75-1.378l-.748 2.853c-.271 1.043-1.002 2.35-1.492 3.146C9.57 23.812 10.763 24 12 24c6.627 0 12-5.373 12-12 0-6.628-5.373-12-12-12z" data-astro-cid-sz7xmlte></path> </svg> </a> <a href="mailto:contact@recipes-saas.com" aria-label="Email" data-astro-cid-sz7xmlte> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-sz7xmlte> <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-astro-cid-sz7xmlte></path> <polyline points="22,6 12,13 2,6" data-astro-cid-sz7xmlte></polyline> </svg> </a> </div> <!-- Copyright --> <div class="footer-bottom" data-astro-cid-sz7xmlte> <p data-astro-cid-sz7xmlte>
&copy; ${currentYear} Freecipies. All rights reserved. <span class="version" data-astro-cid-sz7xmlte>V6.0</span> </p> </div> </div> </footer> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Footer.astro", void 0);
    $$Astro2 = createAstro("https://localhost:4321");
    $$Layout = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro2, $$props, $$slots);
      Astro2.self = $$Layout;
      const { title: title3, description, image } = Astro2.props;
      return renderTemplate`<html lang="en"> <head>${renderComponent($$result, "BaseHead", $$BaseHead, { "title": title3, "description": description, "image": image })}${renderSlot($$result, $$slots["head"])}${renderHead()}</head> <body class="min-h-screen flex flex-col bg-white dark:bg-gray-900"> ${renderComponent($$result, "Header", $$Header, {})} <main id="main-content" class="flex-1"> ${renderSlot($$result, $$slots["default"])} </main> ${renderComponent($$result, "Footer", $$Footer, {})} </body></html>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/layouts/Layout.astro", void 0);
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/about.astro.mjs
var about_astro_exports = {};
__export(about_astro_exports, {
  page: () => page2,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$About, $$file, $$url, _page2, page2;
var init_about_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/about.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$About = createComponent(($$result, $$props, $$slots) => {
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": "About Us | FreeCipies", "description": "Learn about FreeCipies - your destination for delicious, easy-to-follow recipes from around the world.", "data-astro-cid-kh7btl4r": true }, { "default": /* @__PURE__ */ __name(($$result2) => renderTemplate` ${maybeRenderHead()}<main class="about-page" data-astro-cid-kh7btl4r> <!-- Hero Section --> <section class="hero" data-astro-cid-kh7btl4r> <div class="hero-content" data-astro-cid-kh7btl4r> <h1 data-astro-cid-kh7btl4r>About <span class="highlight" data-astro-cid-kh7btl4r>FreeCipies</span></h1> <p class="tagline" data-astro-cid-kh7btl4r>Where passion meets flavor</p> </div> </section> <!-- Mission Section --> <section class="mission" data-astro-cid-kh7btl4r> <div class="container" data-astro-cid-kh7btl4r> <div class="mission-content" data-astro-cid-kh7btl4r> <div class="mission-icon" data-astro-cid-kh7btl4r></div> <h2 data-astro-cid-kh7btl4r>Our Mission</h2> <p data-astro-cid-kh7btl4r>
At FreeCipies, we believe that great food should be
						accessible to everyone. Our mission is to inspire home
						cooks around the world with delicious, easy-to-follow
						recipes that bring joy to the kitchen and smiles to the
						table.
</p> </div> </div> </section> <!-- Story Section --> <section class="story" data-astro-cid-kh7btl4r> <div class="container" data-astro-cid-kh7btl4r> <div class="story-grid" data-astro-cid-kh7btl4r> <div class="story-image" data-astro-cid-kh7btl4r> <div class="image-placeholder" data-astro-cid-kh7btl4r> <span data-astro-cid-kh7btl4r></span> </div> </div> <div class="story-text" data-astro-cid-kh7btl4r> <h2 data-astro-cid-kh7btl4r>Our Story</h2> <p data-astro-cid-kh7btl4r>
FreeCipies started with a simple idea: sharing the
							recipes we love with the world. What began as a
							small collection of family favorites has grown into
							a vibrant community of food lovers.
</p> <p data-astro-cid-kh7btl4r>
Every recipe on our site is carefully tested and
							crafted to ensure success in your kitchen. From
							quick weeknight dinners to impressive weekend
							feasts, we've got you covered.
</p> <p data-astro-cid-kh7btl4r>
We're passionate about celebrating diverse cuisines,
							supporting local ingredients, and making cooking an
							enjoyable experience for everyonewhether you're a
							beginner or a seasoned chef.
</p> </div> </div> </div> </section> <!-- Values Section --> <section class="values" data-astro-cid-kh7btl4r> <div class="container" data-astro-cid-kh7btl4r> <h2 data-astro-cid-kh7btl4r>What We Stand For</h2> <div class="values-grid" data-astro-cid-kh7btl4r> <div class="value-card" data-astro-cid-kh7btl4r> <div class="value-icon" data-astro-cid-kh7btl4r></div> <h3 data-astro-cid-kh7btl4r>Quality</h3> <p data-astro-cid-kh7btl4r>
Every recipe is tested multiple times to ensure
							perfect results every time.
</p> </div> <div class="value-card" data-astro-cid-kh7btl4r> <div class="value-icon" data-astro-cid-kh7btl4r></div> <h3 data-astro-cid-kh7btl4r>Diversity</h3> <p data-astro-cid-kh7btl4r>
We celebrate cuisines from around the world,
							bringing global flavors to your kitchen.
</p> </div> <div class="value-card" data-astro-cid-kh7btl4r> <div class="value-icon" data-astro-cid-kh7btl4r></div> <h3 data-astro-cid-kh7btl4r>Sustainability</h3> <p data-astro-cid-kh7btl4r>
We promote seasonal ingredients and sustainable
							cooking practices.
</p> </div> <div class="value-card" data-astro-cid-kh7btl4r> <div class="value-icon" data-astro-cid-kh7btl4r></div> <h3 data-astro-cid-kh7btl4r>Community</h3> <p data-astro-cid-kh7btl4r>
We're building a community where food lovers can
							share, learn, and grow together.
</p> </div> </div> </div> </section> <!-- Stats Section --> <section class="stats" data-astro-cid-kh7btl4r> <div class="container" data-astro-cid-kh7btl4r> <div class="stats-grid" data-astro-cid-kh7btl4r> <div class="stat-item" data-astro-cid-kh7btl4r> <span class="stat-number" data-astro-cid-kh7btl4r>1000+</span> <span class="stat-label" data-astro-cid-kh7btl4r>Recipes</span> </div> <div class="stat-item" data-astro-cid-kh7btl4r> <span class="stat-number" data-astro-cid-kh7btl4r>50K+</span> <span class="stat-label" data-astro-cid-kh7btl4r>Happy Cooks</span> </div> <div class="stat-item" data-astro-cid-kh7btl4r> <span class="stat-number" data-astro-cid-kh7btl4r>25+</span> <span class="stat-label" data-astro-cid-kh7btl4r>Cuisines</span> </div> <div class="stat-item" data-astro-cid-kh7btl4r> <span class="stat-number" data-astro-cid-kh7btl4r>100%</span> <span class="stat-label" data-astro-cid-kh7btl4r>Free Forever</span> </div> </div> </div> </section> <!-- CTA Section --> <section class="cta" data-astro-cid-kh7btl4r> <div class="container" data-astro-cid-kh7btl4r> <h2 data-astro-cid-kh7btl4r>Ready to Start Cooking?</h2> <p data-astro-cid-kh7btl4r>
Explore our collection of delicious recipes and find your
					next favorite dish.
</p> <a href="/recipes" class="cta-button" data-astro-cid-kh7btl4r>Browse Recipes</a> </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/about.astro", void 0);
    $$file = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/about.astro";
    $$url = "/about";
    _page2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$About,
      file: $$file,
      url: $$url
    }, Symbol.toStringTag, { value: "Module" }));
    page2 = /* @__PURE__ */ __name(() => _page2, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/admin/_---path_.astro.mjs
var path_astro_exports = {};
__export(path_astro_exports, {
  page: () => page3,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender2, $$, $$file2, $$url2, _page3, page3;
var init_path_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/admin/_---path_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender2 = false;
    $$ = createComponent(($$result, $$props, $$slots) => {
      return renderTemplate`<html lang="en" data-astro-cid-oigiyrrr> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Admin Panel -</title>${renderHead()}</head> <body data-astro-cid-oigiyrrr> <div id="admin-root" data-astro-cid-oigiyrrr> ${renderComponent($$result, "AdminApp", null, { "client:only": "react", "client:component-hydration": "only", "data-astro-cid-oigiyrrr": true, "client:component-path": "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/AdminApp", "client:component-export": "default" })} </div> </body></html>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/admin/[...path].astro", void 0);
    $$file2 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/admin/[...path].astro";
    $$url2 = "/admin/[...path]";
    _page3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$,
      file: $$file2,
      prerender: prerender2,
      url: $$url2
    }, Symbol.toStringTag, { value: "Module" }));
    page3 = /* @__PURE__ */ __name(() => _page3, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/templates.schema_DMbF8Dv3.mjs
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
function getTableName(table4) {
  return table4[TableName];
}
function getTableUniqueName(table4) {
  return `${table4[Schema] ?? "public"}.${table4[TableName]}`;
}
function isSQLWrapper(value) {
  return value !== null && value !== void 0 && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path: path3, field }, columnIndex) => {
      let decoder4;
      if (is(field, Column)) {
        decoder4 = field;
      } else if (is(field, SQL)) {
        decoder4 = field.decoder;
      } else if (is(field, Subquery)) {
        decoder4 = field._.sql.decoder;
      } else {
        decoder4 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path3.entries()) {
        if (pathChunkIndex < path3.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value = node[pathChunk] = rawValue === null ? null : decoder4.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is(field, Column) && path3.length === 2) {
            const objectName = path3[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased) || is(field, Subquery)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index2, key] of leftKeys.entries()) {
    if (key !== rightKeys[index2]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table4, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== void 0).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table4[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor") continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
function getTableColumns(table4) {
  return table4[Table.Symbol.Columns];
}
function getTableLikeName(table4) {
  return is(table4, Subquery) ? table4._.alias : is(table4, View) ? table4[ViewBaseConfig].name : is(table4, SQL) ? void 0 : table4[Table.Symbol.IsAlias] ? table4[Table.Symbol.Name] : table4[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a2, b) {
  return {
    name: typeof a2 === "string" && a2.length > 0 ? a2 : "",
    config: typeof a2 === "object" ? a2 : b
  };
}
function uniqueKeyName(table4, columns) {
  return `${table4[TableName]}_${columns.join("_")}_unique`;
}
function blob(a2, b) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b);
  if (config3?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name);
  }
  if (config3?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name);
  }
  return new SQLiteBlobBufferBuilder(name);
}
function customType(customTypeParams) {
  return (a2, b) => {
    const { name, config: config3 } = getColumnNameAndConfig(a2, b);
    return new SQLiteCustomColumnBuilder(
      name,
      config3,
      customTypeParams
    );
  };
}
function integer(a2, b) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b);
  if (config3?.mode === "timestamp" || config3?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config3.mode);
  }
  if (config3?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config3.mode);
  }
  return new SQLiteIntegerBuilder(name);
}
function numeric(a2, b) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b);
  const mode = config3?.mode;
  return mode === "number" ? new SQLiteNumericNumberBuilder(name) : mode === "bigint" ? new SQLiteNumericBigIntBuilder(name) : new SQLiteNumericBuilder(name);
}
function real(name) {
  return new SQLiteRealBuilder(name ?? "");
}
function text(a2, b = {}) {
  const { name, config: config3 } = getColumnNameAndConfig(a2, b);
  if (config3.mode === "json") {
    return new SQLiteTextJsonBuilder(name);
  }
  return new SQLiteTextBuilder(name, config3);
}
function getSQLiteColumnBuilders() {
  return {
    blob,
    customType,
    integer,
    numeric,
    real,
    text
  };
}
function sqliteTableBase(name, columns, extraConfig, schema2, baseName = name) {
  const rawTable = new SQLiteTable(name, schema2, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getSQLiteColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table4 = Object.assign(rawTable, builtColumns);
  table4[Table.Symbol.Columns] = builtColumns;
  table4[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table4[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table4;
}
function index(name) {
  return new IndexBuilderOn(name, false);
}
var MessagePort4, MessageChannelPolyfill3, entityKind, Column, ColumnBuilder, TableName, isPgEnumSym, Subquery, WithSubquery, tracer, ViewBaseConfig, Schema, Columns, ExtraConfigColumns, OriginalName, BaseName, IsAlias, ExtraConfigBuilder, IsDrizzleTable, Table, StringChunk, SQL, Name, noopDecoder, noopEncoder, Param, Placeholder, IsDrizzleView, View, textDecoder, ForeignKeyBuilder, ForeignKey, SQLiteColumnBuilder, SQLiteColumn, SQLiteBigIntBuilder, SQLiteBigInt, SQLiteBlobJsonBuilder, SQLiteBlobJson, SQLiteBlobBufferBuilder, SQLiteBlobBuffer, SQLiteCustomColumnBuilder, SQLiteCustomColumn, SQLiteBaseIntegerBuilder, SQLiteBaseInteger, SQLiteIntegerBuilder, SQLiteInteger, SQLiteTimestampBuilder, SQLiteTimestamp, SQLiteBooleanBuilder, SQLiteBoolean, SQLiteNumericBuilder, SQLiteNumeric, SQLiteNumericNumberBuilder, SQLiteNumericNumber, SQLiteNumericBigIntBuilder, SQLiteNumericBigInt, SQLiteRealBuilder, SQLiteReal, SQLiteTextBuilder, SQLiteText, SQLiteTextJsonBuilder, SQLiteTextJson, InlineForeignKeys, SQLiteTable, sqliteTable, IndexBuilderOn, IndexBuilder, Index, pinTemplates;
var init_templates_schema_DMbF8Dv3 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/templates.schema_DMbF8Dv3.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    entityKind = Symbol.for("drizzle:entityKind");
    __name(is, "is");
    Column = class {
      static {
        __name(this, "Column");
      }
      constructor(table4, config3) {
        this.table = table4;
        this.config = config3;
        this.name = config3.name;
        this.keyAsName = config3.keyAsName;
        this.notNull = config3.notNull;
        this.default = config3.default;
        this.defaultFn = config3.defaultFn;
        this.onUpdateFn = config3.onUpdateFn;
        this.hasDefault = config3.hasDefault;
        this.primary = config3.primaryKey;
        this.isUnique = config3.isUnique;
        this.uniqueName = config3.uniqueName;
        this.uniqueType = config3.uniqueType;
        this.dataType = config3.dataType;
        this.columnType = config3.columnType;
        this.generated = config3.generated;
        this.generatedIdentity = config3.generatedIdentity;
      }
      static [entityKind] = "Column";
      name;
      keyAsName;
      primary;
      notNull;
      default;
      defaultFn;
      onUpdateFn;
      hasDefault;
      isUnique;
      uniqueName;
      uniqueType;
      dataType;
      columnType;
      enumValues = void 0;
      generated = void 0;
      generatedIdentity = void 0;
      config;
      mapFromDriverValue(value) {
        return value;
      }
      mapToDriverValue(value) {
        return value;
      }
      // ** @internal */
      shouldDisableInsert() {
        return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
      }
    };
    ColumnBuilder = class {
      static {
        __name(this, "ColumnBuilder");
      }
      static [entityKind] = "ColumnBuilder";
      config;
      constructor(name, dataType, columnType) {
        this.config = {
          name,
          keyAsName: name === "",
          notNull: false,
          default: void 0,
          hasDefault: false,
          primaryKey: false,
          isUnique: false,
          uniqueName: void 0,
          uniqueType: void 0,
          dataType,
          columnType,
          generated: void 0
        };
      }
      /**
       * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
       *
       * @example
       * ```ts
       * const users = pgTable('users', {
       * 	id: integer('id').$type<UserId>().primaryKey(),
       * 	details: json('details').$type<UserDetails>().notNull(),
       * });
       * ```
       */
      $type() {
        return this;
      }
      /**
       * Adds a `not null` clause to the column definition.
       *
       * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
       */
      notNull() {
        this.config.notNull = true;
        return this;
      }
      /**
       * Adds a `default <value>` clause to the column definition.
       *
       * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
       *
       * If you need to set a dynamic default value, use {@link $defaultFn} instead.
       */
      default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Adds a dynamic default value to the column.
       * The function will be called when the row is inserted, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $defaultFn}.
       */
      $default = this.$defaultFn;
      /**
       * Adds a dynamic update value to the column.
       * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
       * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
       *
       * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
       */
      $onUpdateFn(fn) {
        this.config.onUpdateFn = fn;
        this.config.hasDefault = true;
        return this;
      }
      /**
       * Alias for {@link $onUpdateFn}.
       */
      $onUpdate = this.$onUpdateFn;
      /**
       * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
       *
       * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
       */
      primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
      }
      /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
      setName(name) {
        if (this.config.name !== "") return;
        this.config.name = name;
      }
    };
    TableName = Symbol.for("drizzle:Name");
    isPgEnumSym = Symbol.for("drizzle:isPgEnum");
    __name(isPgEnum, "isPgEnum");
    Subquery = class {
      static {
        __name(this, "Subquery");
      }
      static [entityKind] = "Subquery";
      constructor(sql2, fields, alias, isWith = false, usedTables = []) {
        this._ = {
          brand: "Subquery",
          sql: sql2,
          selectedFields: fields,
          alias,
          isWith,
          usedTables
        };
      }
      // getSQL(): SQL<unknown> {
      // 	return new SQL([this]);
      // }
    };
    WithSubquery = class extends Subquery {
      static {
        __name(this, "WithSubquery");
      }
      static [entityKind] = "WithSubquery";
    };
    tracer = {
      startActiveSpan(name, fn) {
        {
          return fn();
        }
      }
    };
    ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");
    Schema = Symbol.for("drizzle:Schema");
    Columns = Symbol.for("drizzle:Columns");
    ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
    OriginalName = Symbol.for("drizzle:OriginalName");
    BaseName = Symbol.for("drizzle:BaseName");
    IsAlias = Symbol.for("drizzle:IsAlias");
    ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
    IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
    Table = class {
      static {
        __name(this, "Table");
      }
      static [entityKind] = "Table";
      /** @internal */
      static Symbol = {
        Name: TableName,
        Schema,
        OriginalName,
        Columns,
        ExtraConfigColumns,
        BaseName,
        IsAlias,
        ExtraConfigBuilder
      };
      /**
       * @internal
       * Can be changed if the table is aliased.
       */
      [TableName];
      /**
       * @internal
       * Used to store the original name of the table, before any aliasing.
       */
      [OriginalName];
      /** @internal */
      [Schema];
      /** @internal */
      [Columns];
      /** @internal */
      [ExtraConfigColumns];
      /**
       *  @internal
       * Used to store the table name before the transformation via the `tableCreator` functions.
       */
      [BaseName];
      /** @internal */
      [IsAlias] = false;
      /** @internal */
      [IsDrizzleTable] = true;
      /** @internal */
      [ExtraConfigBuilder] = void 0;
      constructor(name, schema2, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema2;
        this[BaseName] = baseName;
      }
    };
    __name(getTableName, "getTableName");
    __name(getTableUniqueName, "getTableUniqueName");
    __name(isSQLWrapper, "isSQLWrapper");
    __name(mergeQueries, "mergeQueries");
    StringChunk = class {
      static {
        __name(this, "StringChunk");
      }
      static [entityKind] = "StringChunk";
      value;
      constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    SQL = class _SQL {
      static {
        __name(this, "SQL");
      }
      constructor(queryChunks) {
        this.queryChunks = queryChunks;
        for (const chunk of queryChunks) {
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            this.usedTables.push(
              schemaName === void 0 ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]
            );
          }
        }
      }
      static [entityKind] = "SQL";
      /** @internal */
      decoder = noopDecoder;
      shouldInlineParams = false;
      /** @internal */
      usedTables = [];
      append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
      }
      toQuery(config3) {
        return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
          const query = this.buildQueryFromSourceParams(this.queryChunks, config3);
          span?.setAttributes({
            "drizzle.query.text": query.sql,
            "drizzle.query.params": JSON.stringify(query.params)
          });
          return query;
        });
      }
      buildQueryFromSourceParams(chunks, _config) {
        const config3 = Object.assign({}, _config, {
          inlineParams: _config.inlineParams || this.shouldInlineParams,
          paramStartIndex: _config.paramStartIndex || { value: 0 }
        });
        const {
          casing,
          escapeName,
          escapeParam,
          prepareTyping,
          inlineParams,
          paramStartIndex
        } = config3;
        return mergeQueries(chunks.map((chunk) => {
          if (is(chunk, StringChunk)) {
            return { sql: chunk.value.join(""), params: [] };
          }
          if (is(chunk, Name)) {
            return { sql: escapeName(chunk.value), params: [] };
          }
          if (chunk === void 0) {
            return { sql: "", params: [] };
          }
          if (Array.isArray(chunk)) {
            const result = [new StringChunk("(")];
            for (const [i2, p] of chunk.entries()) {
              result.push(p);
              if (i2 < chunk.length - 1) {
                result.push(new StringChunk(", "));
              }
            }
            result.push(new StringChunk(")"));
            return this.buildQueryFromSourceParams(result, config3);
          }
          if (is(chunk, _SQL)) {
            return this.buildQueryFromSourceParams(chunk.queryChunks, {
              ...config3,
              inlineParams: inlineParams || chunk.shouldInlineParams
            });
          }
          if (is(chunk, Table)) {
            const schemaName = chunk[Table.Symbol.Schema];
            const tableName = chunk[Table.Symbol.Name];
            return {
              sql: schemaName === void 0 || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
              params: []
            };
          }
          if (is(chunk, Column)) {
            const columnName = casing.getColumnCasing(chunk);
            if (_config.invokeSource === "indexes") {
              return { sql: escapeName(columnName), params: [] };
            }
            const schemaName = chunk.table[Table.Symbol.Schema];
            return {
              sql: chunk.table[IsAlias] || schemaName === void 0 ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
              params: []
            };
          }
          if (is(chunk, View)) {
            const schemaName = chunk[ViewBaseConfig].schema;
            const viewName = chunk[ViewBaseConfig].name;
            return {
              sql: schemaName === void 0 || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
              params: []
            };
          }
          if (is(chunk, Param)) {
            if (is(chunk.value, Placeholder)) {
              return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
            }
            const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
            if (is(mappedValue, _SQL)) {
              return this.buildQueryFromSourceParams([mappedValue], config3);
            }
            if (inlineParams) {
              return { sql: this.mapInlineParam(mappedValue, config3), params: [] };
            }
            let typings = ["none"];
            if (prepareTyping) {
              typings = [prepareTyping(chunk.encoder)];
            }
            return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
          }
          if (is(chunk, Placeholder)) {
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
          }
          if (is(chunk, _SQL.Aliased) && chunk.fieldAlias !== void 0) {
            return { sql: escapeName(chunk.fieldAlias), params: [] };
          }
          if (is(chunk, Subquery)) {
            if (chunk._.isWith) {
              return { sql: escapeName(chunk._.alias), params: [] };
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk._.sql,
              new StringChunk(") "),
              new Name(chunk._.alias)
            ], config3);
          }
          if (isPgEnum(chunk)) {
            if (chunk.schema) {
              return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
            }
            return { sql: escapeName(chunk.enumName), params: [] };
          }
          if (isSQLWrapper(chunk)) {
            if (chunk.shouldOmitSQLParens?.()) {
              return this.buildQueryFromSourceParams([chunk.getSQL()], config3);
            }
            return this.buildQueryFromSourceParams([
              new StringChunk("("),
              chunk.getSQL(),
              new StringChunk(")")
            ], config3);
          }
          if (inlineParams) {
            return { sql: this.mapInlineParam(chunk, config3), params: [] };
          }
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }));
      }
      mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
          return "null";
        }
        if (typeof chunk === "number" || typeof chunk === "boolean") {
          return chunk.toString();
        }
        if (typeof chunk === "string") {
          return escapeString(chunk);
        }
        if (typeof chunk === "object") {
          const mappedValueAsString = chunk.toString();
          if (mappedValueAsString === "[object Object]") {
            return escapeString(JSON.stringify(chunk));
          }
          return escapeString(mappedValueAsString);
        }
        throw new Error("Unexpected param value: " + chunk);
      }
      getSQL() {
        return this;
      }
      as(alias) {
        if (alias === void 0) {
          return this;
        }
        return new _SQL.Aliased(this, alias);
      }
      mapWith(decoder4) {
        this.decoder = typeof decoder4 === "function" ? { mapFromDriverValue: decoder4 } : decoder4;
        return this;
      }
      inlineParams() {
        this.shouldInlineParams = true;
        return this;
      }
      /**
       * This method is used to conditionally include a part of the query.
       *
       * @param condition - Condition to check
       * @returns itself if the condition is `true`, otherwise `undefined`
       */
      if(condition) {
        return condition ? this : void 0;
      }
    };
    Name = class {
      static {
        __name(this, "Name");
      }
      constructor(value) {
        this.value = value;
      }
      static [entityKind] = "Name";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(isDriverValueEncoder, "isDriverValueEncoder");
    noopDecoder = {
      mapFromDriverValue: /* @__PURE__ */ __name((value) => value, "mapFromDriverValue")
    };
    noopEncoder = {
      mapToDriverValue: /* @__PURE__ */ __name((value) => value, "mapToDriverValue")
    };
    ({
      ...noopDecoder,
      ...noopEncoder
    });
    Param = class {
      static {
        __name(this, "Param");
      }
      /**
       * @param value - Parameter value
       * @param encoder - Encoder to convert the value to a driver parameter
       */
      constructor(value, encoder4 = noopEncoder) {
        this.value = value;
        this.encoder = encoder4;
      }
      static [entityKind] = "Param";
      brand;
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(sql, "sql");
    ((sql2) => {
      function empty() {
        return new SQL([]);
      }
      __name(empty, "empty");
      sql2.empty = empty;
      function fromList(list) {
        return new SQL(list);
      }
      __name(fromList, "fromList");
      sql2.fromList = fromList;
      function raw(str) {
        return new SQL([new StringChunk(str)]);
      }
      __name(raw, "raw");
      sql2.raw = raw;
      function join(chunks, separator) {
        const result = [];
        for (const [i2, chunk] of chunks.entries()) {
          if (i2 > 0 && separator !== void 0) {
            result.push(separator);
          }
          result.push(chunk);
        }
        return new SQL(result);
      }
      __name(join, "join");
      sql2.join = join;
      function identifier(value) {
        return new Name(value);
      }
      __name(identifier, "identifier");
      sql2.identifier = identifier;
      function placeholder2(name2) {
        return new Placeholder(name2);
      }
      __name(placeholder2, "placeholder2");
      sql2.placeholder = placeholder2;
      function param2(value, encoder4) {
        return new Param(value, encoder4);
      }
      __name(param2, "param2");
      sql2.param = param2;
    })(sql || (sql = {}));
    ((SQL2) => {
      class Aliased {
        static {
          __name(this, "Aliased");
        }
        constructor(sql2, fieldAlias) {
          this.sql = sql2;
          this.fieldAlias = fieldAlias;
        }
        static [entityKind] = "SQL.Aliased";
        /** @internal */
        isSelectionField = false;
        getSQL() {
          return this.sql;
        }
        /** @internal */
        clone() {
          return new Aliased(this.sql, this.fieldAlias);
        }
      }
      SQL2.Aliased = Aliased;
    })(SQL || (SQL = {}));
    Placeholder = class {
      static {
        __name(this, "Placeholder");
      }
      constructor(name2) {
        this.name = name2;
      }
      static [entityKind] = "Placeholder";
      getSQL() {
        return new SQL([this]);
      }
    };
    __name(fillPlaceholders, "fillPlaceholders");
    IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");
    View = class {
      static {
        __name(this, "View");
      }
      static [entityKind] = "View";
      /** @internal */
      [ViewBaseConfig];
      /** @internal */
      [IsDrizzleView] = true;
      constructor({ name: name2, schema: schema2, selectedFields, query }) {
        this[ViewBaseConfig] = {
          name: name2,
          originalName: name2,
          schema: schema2,
          selectedFields,
          query,
          isExisting: !query,
          isAlias: false
        };
      }
      getSQL() {
        return new SQL([this]);
      }
    };
    Column.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Table.prototype.getSQL = function() {
      return new SQL([this]);
    };
    Subquery.prototype.getSQL = function() {
      return new SQL([this]);
    };
    __name(mapResultRow, "mapResultRow");
    __name(orderSelectedFields, "orderSelectedFields");
    __name(haveSameKeys, "haveSameKeys");
    __name(mapUpdateSet, "mapUpdateSet");
    __name(applyMixins, "applyMixins");
    __name(getTableColumns, "getTableColumns");
    __name(getTableLikeName, "getTableLikeName");
    __name(getColumnNameAndConfig, "getColumnNameAndConfig");
    textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder();
    ForeignKeyBuilder = class {
      static {
        __name(this, "ForeignKeyBuilder");
      }
      static [entityKind] = "SQLiteForeignKeyBuilder";
      /** @internal */
      reference;
      /** @internal */
      _onUpdate;
      /** @internal */
      _onDelete;
      constructor(config3, actions) {
        this.reference = () => {
          const { name, columns, foreignColumns } = config3();
          return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
          this._onUpdate = actions.onUpdate;
          this._onDelete = actions.onDelete;
        }
      }
      onUpdate(action) {
        this._onUpdate = action;
        return this;
      }
      onDelete(action) {
        this._onDelete = action;
        return this;
      }
      /** @internal */
      build(table4) {
        return new ForeignKey(table4, this);
      }
    };
    ForeignKey = class {
      static {
        __name(this, "ForeignKey");
      }
      constructor(table4, builder) {
        this.table = table4;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
      }
      static [entityKind] = "SQLiteForeignKey";
      reference;
      onUpdate;
      onDelete;
      getName() {
        const { name, columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
          this.table[TableName],
          ...columnNames,
          foreignColumns[0].table[TableName],
          ...foreignColumnNames
        ];
        return name ?? `${chunks.join("_")}_fk`;
      }
    };
    __name(uniqueKeyName, "uniqueKeyName");
    SQLiteColumnBuilder = class extends ColumnBuilder {
      static {
        __name(this, "SQLiteColumnBuilder");
      }
      static [entityKind] = "SQLiteColumnBuilder";
      foreignKeyConfigs = [];
      references(ref3, actions = {}) {
        this.foreignKeyConfigs.push({ ref: ref3, actions });
        return this;
      }
      unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
      }
      generatedAlwaysAs(as, config3) {
        this.config.generated = {
          as,
          type: "always",
          mode: config3?.mode ?? "virtual"
        };
        return this;
      }
      /** @internal */
      buildForeignKeys(column, table4) {
        return this.foreignKeyConfigs.map(({ ref: ref3, actions }) => {
          return ((ref22, actions2) => {
            const builder = new ForeignKeyBuilder(() => {
              const foreignColumn = ref22();
              return { columns: [column], foreignColumns: [foreignColumn] };
            });
            if (actions2.onUpdate) {
              builder.onUpdate(actions2.onUpdate);
            }
            if (actions2.onDelete) {
              builder.onDelete(actions2.onDelete);
            }
            return builder.build(table4);
          })(ref3, actions);
        });
      }
    };
    SQLiteColumn = class extends Column {
      static {
        __name(this, "SQLiteColumn");
      }
      constructor(table4, config3) {
        if (!config3.uniqueName) {
          config3.uniqueName = uniqueKeyName(table4, [config3.name]);
        }
        super(table4, config3);
        this.table = table4;
      }
      static [entityKind] = "SQLiteColumn";
    };
    SQLiteBigIntBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBigIntBuilder");
      }
      static [entityKind] = "SQLiteBigIntBuilder";
      constructor(name) {
        super(name, "bigint", "SQLiteBigInt");
      }
      /** @internal */
      build(table4) {
        return new SQLiteBigInt(table4, this.config);
      }
    };
    SQLiteBigInt = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBigInt");
      }
      static [entityKind] = "SQLiteBigInt";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        if (typeof Buffer !== "undefined" && Buffer.from) {
          const buf = Buffer.isBuffer(value) ? value : value instanceof ArrayBuffer ? Buffer.from(value) : value.buffer ? Buffer.from(value.buffer, value.byteOffset, value.byteLength) : Buffer.from(value);
          return BigInt(buf.toString("utf8"));
        }
        return BigInt(textDecoder.decode(value));
      }
      mapToDriverValue(value) {
        return Buffer.from(value.toString());
      }
    };
    SQLiteBlobJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobJsonBuilder");
      }
      static [entityKind] = "SQLiteBlobJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteBlobJson");
      }
      /** @internal */
      build(table4) {
        return new SQLiteBlobJson(
          table4,
          this.config
        );
      }
    };
    SQLiteBlobJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobJson");
      }
      static [entityKind] = "SQLiteBlobJson";
      getSQLType() {
        return "blob";
      }
      mapFromDriverValue(value) {
        if (typeof Buffer !== "undefined" && Buffer.from) {
          const buf = Buffer.isBuffer(value) ? value : value instanceof ArrayBuffer ? Buffer.from(value) : value.buffer ? Buffer.from(value.buffer, value.byteOffset, value.byteLength) : Buffer.from(value);
          return JSON.parse(buf.toString("utf8"));
        }
        return JSON.parse(textDecoder.decode(value));
      }
      mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
      }
    };
    SQLiteBlobBufferBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBlobBufferBuilder");
      }
      static [entityKind] = "SQLiteBlobBufferBuilder";
      constructor(name) {
        super(name, "buffer", "SQLiteBlobBuffer");
      }
      /** @internal */
      build(table4) {
        return new SQLiteBlobBuffer(table4, this.config);
      }
    };
    SQLiteBlobBuffer = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBlobBuffer");
      }
      static [entityKind] = "SQLiteBlobBuffer";
      mapFromDriverValue(value) {
        if (Buffer.isBuffer(value)) {
          return value;
        }
        return Buffer.from(value);
      }
      getSQLType() {
        return "blob";
      }
    };
    __name(blob, "blob");
    SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteCustomColumnBuilder");
      }
      static [entityKind] = "SQLiteCustomColumnBuilder";
      constructor(name, fieldConfig, customTypeParams) {
        super(name, "custom", "SQLiteCustomColumn");
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
      }
      /** @internal */
      build(table4) {
        return new SQLiteCustomColumn(
          table4,
          this.config
        );
      }
    };
    SQLiteCustomColumn = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteCustomColumn");
      }
      static [entityKind] = "SQLiteCustomColumn";
      sqlName;
      mapTo;
      mapFrom;
      constructor(table4, config3) {
        super(table4, config3);
        this.sqlName = config3.customTypeParams.dataType(config3.fieldConfig);
        this.mapTo = config3.customTypeParams.toDriver;
        this.mapFrom = config3.customTypeParams.fromDriver;
      }
      getSQLType() {
        return this.sqlName;
      }
      mapFromDriverValue(value) {
        return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
      }
      mapToDriverValue(value) {
        return typeof this.mapTo === "function" ? this.mapTo(value) : value;
      }
    };
    __name(customType, "customType");
    SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteBaseIntegerBuilder");
      }
      static [entityKind] = "SQLiteBaseIntegerBuilder";
      constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
      }
      primaryKey(config3) {
        if (config3?.autoIncrement) {
          this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
      }
    };
    SQLiteBaseInteger = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteBaseInteger");
      }
      static [entityKind] = "SQLiteBaseInteger";
      autoIncrement = this.config.autoIncrement;
      getSQLType() {
        return "integer";
      }
    };
    SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteIntegerBuilder");
      }
      static [entityKind] = "SQLiteIntegerBuilder";
      constructor(name) {
        super(name, "number", "SQLiteInteger");
      }
      build(table4) {
        return new SQLiteInteger(
          table4,
          this.config
        );
      }
    };
    SQLiteInteger = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteInteger");
      }
      static [entityKind] = "SQLiteInteger";
    };
    SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteTimestampBuilder");
      }
      static [entityKind] = "SQLiteTimestampBuilder";
      constructor(name, mode) {
        super(name, "date", "SQLiteTimestamp");
        this.config.mode = mode;
      }
      /**
       * @deprecated Use `default()` with your own expression instead.
       *
       * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
       */
      defaultNow() {
        return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
      }
      build(table4) {
        return new SQLiteTimestamp(
          table4,
          this.config
        );
      }
    };
    SQLiteTimestamp = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteTimestamp");
      }
      static [entityKind] = "SQLiteTimestamp";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        if (this.config.mode === "timestamp") {
          return new Date(value * 1e3);
        }
        return new Date(value);
      }
      mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === "timestamp") {
          return Math.floor(unix / 1e3);
        }
        return unix;
      }
    };
    SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
      static {
        __name(this, "SQLiteBooleanBuilder");
      }
      static [entityKind] = "SQLiteBooleanBuilder";
      constructor(name, mode) {
        super(name, "boolean", "SQLiteBoolean");
        this.config.mode = mode;
      }
      build(table4) {
        return new SQLiteBoolean(
          table4,
          this.config
        );
      }
    };
    SQLiteBoolean = class extends SQLiteBaseInteger {
      static {
        __name(this, "SQLiteBoolean");
      }
      static [entityKind] = "SQLiteBoolean";
      mode = this.config.mode;
      mapFromDriverValue(value) {
        return Number(value) === 1;
      }
      mapToDriverValue(value) {
        return value ? 1 : 0;
      }
    };
    __name(integer, "integer");
    SQLiteNumericBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteNumericBuilder");
      }
      static [entityKind] = "SQLiteNumericBuilder";
      constructor(name) {
        super(name, "string", "SQLiteNumeric");
      }
      /** @internal */
      build(table4) {
        return new SQLiteNumeric(
          table4,
          this.config
        );
      }
    };
    SQLiteNumeric = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteNumeric");
      }
      static [entityKind] = "SQLiteNumeric";
      mapFromDriverValue(value) {
        if (typeof value === "string") return value;
        return String(value);
      }
      getSQLType() {
        return "numeric";
      }
    };
    SQLiteNumericNumberBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteNumericNumberBuilder");
      }
      static [entityKind] = "SQLiteNumericNumberBuilder";
      constructor(name) {
        super(name, "number", "SQLiteNumericNumber");
      }
      /** @internal */
      build(table4) {
        return new SQLiteNumericNumber(
          table4,
          this.config
        );
      }
    };
    SQLiteNumericNumber = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteNumericNumber");
      }
      static [entityKind] = "SQLiteNumericNumber";
      mapFromDriverValue(value) {
        if (typeof value === "number") return value;
        return Number(value);
      }
      mapToDriverValue = String;
      getSQLType() {
        return "numeric";
      }
    };
    SQLiteNumericBigIntBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteNumericBigIntBuilder");
      }
      static [entityKind] = "SQLiteNumericBigIntBuilder";
      constructor(name) {
        super(name, "bigint", "SQLiteNumericBigInt");
      }
      /** @internal */
      build(table4) {
        return new SQLiteNumericBigInt(
          table4,
          this.config
        );
      }
    };
    SQLiteNumericBigInt = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteNumericBigInt");
      }
      static [entityKind] = "SQLiteNumericBigInt";
      mapFromDriverValue = BigInt;
      mapToDriverValue = String;
      getSQLType() {
        return "numeric";
      }
    };
    __name(numeric, "numeric");
    SQLiteRealBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteRealBuilder");
      }
      static [entityKind] = "SQLiteRealBuilder";
      constructor(name) {
        super(name, "number", "SQLiteReal");
      }
      /** @internal */
      build(table4) {
        return new SQLiteReal(table4, this.config);
      }
    };
    SQLiteReal = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteReal");
      }
      static [entityKind] = "SQLiteReal";
      getSQLType() {
        return "real";
      }
    };
    __name(real, "real");
    SQLiteTextBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextBuilder");
      }
      static [entityKind] = "SQLiteTextBuilder";
      constructor(name, config3) {
        super(name, "string", "SQLiteText");
        this.config.enumValues = config3.enum;
        this.config.length = config3.length;
      }
      /** @internal */
      build(table4) {
        return new SQLiteText(
          table4,
          this.config
        );
      }
    };
    SQLiteText = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteText");
      }
      static [entityKind] = "SQLiteText";
      enumValues = this.config.enumValues;
      length = this.config.length;
      constructor(table4, config3) {
        super(table4, config3);
      }
      getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ""}`;
      }
    };
    SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
      static {
        __name(this, "SQLiteTextJsonBuilder");
      }
      static [entityKind] = "SQLiteTextJsonBuilder";
      constructor(name) {
        super(name, "json", "SQLiteTextJson");
      }
      /** @internal */
      build(table4) {
        return new SQLiteTextJson(
          table4,
          this.config
        );
      }
    };
    SQLiteTextJson = class extends SQLiteColumn {
      static {
        __name(this, "SQLiteTextJson");
      }
      static [entityKind] = "SQLiteTextJson";
      getSQLType() {
        return "text";
      }
      mapFromDriverValue(value) {
        return JSON.parse(value);
      }
      mapToDriverValue(value) {
        return JSON.stringify(value);
      }
    };
    __name(text, "text");
    __name(getSQLiteColumnBuilders, "getSQLiteColumnBuilders");
    InlineForeignKeys = Symbol.for("drizzle:SQLiteInlineForeignKeys");
    SQLiteTable = class extends Table {
      static {
        __name(this, "SQLiteTable");
      }
      static [entityKind] = "SQLiteTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys
      });
      /** @internal */
      [Table.Symbol.Columns];
      /** @internal */
      [InlineForeignKeys] = [];
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
    };
    __name(sqliteTableBase, "sqliteTableBase");
    sqliteTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
      return sqliteTableBase(name, columns, extraConfig);
    }, "sqliteTable");
    IndexBuilderOn = class {
      static {
        __name(this, "IndexBuilderOn");
      }
      constructor(name, unique) {
        this.name = name;
        this.unique = unique;
      }
      static [entityKind] = "SQLiteIndexBuilderOn";
      on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
      }
    };
    IndexBuilder = class {
      static {
        __name(this, "IndexBuilder");
      }
      static [entityKind] = "SQLiteIndexBuilder";
      /** @internal */
      config;
      constructor(name, columns, unique) {
        this.config = {
          name,
          columns,
          unique,
          where: void 0
        };
      }
      /**
       * Condition for partial index.
       */
      where(condition) {
        this.config.where = condition;
        return this;
      }
      /** @internal */
      build(table4) {
        return new Index(this.config, table4);
      }
    };
    Index = class {
      static {
        __name(this, "Index");
      }
      static [entityKind] = "SQLiteIndex";
      config;
      constructor(config3, table4) {
        this.config = { ...config3, table: table4 };
      }
    };
    __name(index, "index");
    pinTemplates = sqliteTable("pin_templates", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      slug: text("slug").unique().notNull(),
      name: text("name").notNull(),
      description: text("description"),
      category: text("category").default("general"),
      thumbnailUrl: text("thumbnail_url"),
      width: integer("width").default(1e3),
      height: integer("height").default(1500),
      elementsJson: text("elements_json").notNull(),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`)
    }, (table4) => [
      index("idx_pin_templates_slug").on(table4.slug),
      index("idx_pin_templates_category").on(table4.category),
      index("idx_pin_templates_active").on(table4.isActive)
    ]);
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/pinterest.schema_eG5oHE2g.mjs
var MessagePort4, MessageChannelPolyfill3, categories, authors, articles, tags, media, siteSettings, pinterestBoards, pinterestPins;
var init_pinterest_schema_eG5oHE2g = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/pinterest.schema_eG5oHE2g.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_templates_schema_DMbF8Dv3();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    categories = sqliteTable("categories", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      // 1. NAVIGATION & HIERARCHY
      slug: text("slug").unique().notNull(),
      label: text("label").notNull(),
      parentId: integer("parent_id"),
      depth: integer("depth").default(0),
      // 2. DISPLAY TEXT (Landing Page Content)
      headline: text("headline"),
      collectionTitle: text("collection_title"),
      shortDescription: text("short_description").notNull(),
      // 3. VISUALS (Display-Ready Image Data)
      imagesJson: text("images_json").default("{}"),
      // 4. LOGIC & THEME
      color: text("color").default("#ff6600ff"),
      iconSvg: text("icon_svg"),
      isFeatured: integer("is_featured", { mode: "boolean" }).default(false),
      // 5. JSON CONFIG CONTAINERS
      seoJson: text("seo_json").default("{}"),
      configJson: text("config_json").default("{}"),
      i18nJson: text("i18n_json").default("{}"),
      // 6. SYSTEM & METRICS
      sortOrder: integer("sort_order").default(0),
      isOnline: integer("is_online", { mode: "boolean" }).default(false),
      cachedPostCount: integer("cached_post_count").default(0),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_categories_slug").on(table4.slug),
      index("idx_categories_parent").on(table4.parentId),
      index("idx_categories_display").on(table4.isOnline, table4.sortOrder),
      index("idx_categories_featured").on(table4.isFeatured),
      index("idx_categories_active").on(table4.deletedAt)
    ]);
    authors = sqliteTable("authors", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      // 1. IDENTITY & ROUTING
      slug: text("slug").unique().notNull(),
      name: text("name").notNull(),
      email: text("email").unique().notNull(),
      // 2. DISPLAY METADATA
      jobTitle: text("job_title"),
      role: text("role").default("guest"),
      headline: text("headline"),
      subtitle: text("subtitle"),
      shortDescription: text("short_description").notNull(),
      excerpt: text("excerpt"),
      introduction: text("introduction"),
      // 3. VISUALS
      imagesJson: text("images_json").default("{}"),
      // 4. BIOGRAPHY & SOCIALS
      bioJson: text("bio_json").default("{}"),
      // 5. SEO CONFIGURATION
      seoJson: text("seo_json").default("{}"),
      // 6. SYSTEM & METRICS
      isOnline: integer("is_online", { mode: "boolean" }).default(false),
      isFeatured: integer("is_featured", { mode: "boolean" }).default(false),
      sortOrder: integer("sort_order").default(0),
      cachedPostCount: integer("cached_post_count").default(0),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_authors_slug").on(table4.slug),
      index("idx_authors_role").on(table4.role),
      index("idx_authors_email").on(table4.email),
      index("idx_authors_featured").on(table4.isFeatured),
      index("idx_authors_display").on(table4.isOnline, table4.sortOrder),
      index("idx_authors_active").on(table4.deletedAt)
    ]);
    articles = sqliteTable("articles", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      slug: text("slug").unique().notNull(),
      type: text("type").notNull().default("article"),
      locale: text("locale").default("en"),
      // Relations
      categoryId: integer("category_id").notNull().references(() => categories.id),
      authorId: integer("author_id").notNull().references(() => authors.id),
      parentArticleId: integer("parent_article_id"),
      // Display Metadata
      headline: text("headline").notNull(),
      subtitle: text("subtitle"),
      shortDescription: text("short_description").notNull(),
      excerpt: text("excerpt"),
      introduction: text("introduction"),
      // Content Fields
      imagesJson: text("images_json"),
      contentJson: text("content_json"),
      recipeJson: text("recipe_json"),
      roundupJson: text("roundup_json"),
      faqsJson: text("faqs_json"),
      // Cached Fields (Zero-Join)
      relatedArticlesJson: text("related_articles_json"),
      cachedTagsJson: text("cached_tags_json"),
      cachedCategoryJson: text("cached_category_json"),
      cachedAuthorJson: text("cached_author_json"),
      cachedEquipmentJson: text("cached_equipment_json"),
      cachedCommentCount: integer("cached_comment_count").default(0),
      cachedRatingJson: text("cached_rating_json"),
      cachedTocJson: text("cached_toc_json"),
      cachedRecipeJson: text("cached_recipe_json"),
      cachedCardJson: text("cached_card_json"),
      readingTimeMinutes: integer("reading_time_minutes"),
      // Scalar Indexes
      totalTimeMinutes: integer("total_time_minutes"),
      difficultyLabel: text("difficulty_label"),
      // SEO & Config
      seoJson: text("seo_json"),
      jsonldJson: text("jsonld_json"),
      configJson: text("config_json"),
      // Workflow
      workflowStatus: text("workflow_status").default("draft"),
      scheduledAt: text("scheduled_at"),
      // System
      isOnline: integer("is_online", { mode: "boolean" }).default(false),
      isFavorite: integer("is_favorite", { mode: "boolean" }).default(false),
      accessLevel: integer("access_level").default(0),
      viewCount: integer("view_count").default(0),
      publishedAt: text("published_at"),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_articles_slug").on(table4.slug),
      index("idx_articles_type").on(table4.type),
      index("idx_articles_category").on(table4.categoryId),
      index("idx_articles_author").on(table4.authorId),
      index("idx_articles_online").on(table4.isOnline),
      index("idx_articles_favorite").on(table4.isFavorite),
      index("idx_articles_published").on(table4.publishedAt),
      index("idx_articles_views").on(table4.viewCount),
      index("idx_articles_workflow").on(table4.workflowStatus),
      index("idx_articles_time").on(table4.totalTimeMinutes),
      index("idx_articles_difficulty").on(table4.difficultyLabel),
      index("idx_articles_active").on(table4.deletedAt)
    ]);
    tags = sqliteTable("tags", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      // 1. IDENTITY & ROUTING
      slug: text("slug").unique().notNull(),
      label: text("label").notNull(),
      description: text("description"),
      // 2. FILTER LOGIC (Multi-Grouping)
      filterGroupsJson: text("filter_groups_json").default("[]"),
      // 3. VISUAL STYLING
      styleJson: text("style_json").default("{}"),
      // 4. SYSTEM & METRICS
      cachedPostCount: integer("cached_post_count").default(0),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_tags_slug").on(table4.slug),
      index("idx_tags_popular").on(table4.cachedPostCount),
      index("idx_tags_label").on(table4.label),
      index("idx_tags_active").on(table4.deletedAt)
    ]);
    media = sqliteTable("media", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      // 1. SEARCHABLE METADATA
      name: text("name").notNull(),
      altText: text("alt_text").notNull(),
      caption: text("caption"),
      credit: text("credit"),
      mimeType: text("mime_type").notNull().default("image/webp"),
      aspectRatio: text("aspect_ratio"),
      // 2. TECHNICAL PAYLOAD
      variantsJson: text("variants_json").notNull(),
      // 3. SMART DISPLAY
      focalPointJson: text("focal_point_json").default('{"x": 50, "y": 50}'),
      // 4. SYSTEM METADATA
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_media_search").on(table4.name, table4.altText, table4.credit),
      index("idx_media_date").on(table4.createdAt),
      index("idx_media_active").on(table4.deletedAt)
    ]);
    siteSettings = sqliteTable("site_settings", {
      key: text("key").primaryKey(),
      value: text("value").notNull(),
      description: text("description"),
      category: text("category").default("general"),
      sortOrder: integer("sort_order").default(0),
      type: text("type").default("json"),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`)
    }, (table4) => [
      index("idx_site_settings_category").on(table4.category, table4.sortOrder)
    ]);
    pinterestBoards = sqliteTable("pinterest_boards", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      slug: text("slug").unique().notNull(),
      name: text("name").notNull(),
      description: text("description"),
      boardUrl: text("board_url"),
      coverImageUrl: text("cover_image_url"),
      locale: text("locale").default("en"),
      isActive: integer("is_active", { mode: "boolean" }).default(true),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`),
      deletedAt: text("deleted_at")
    }, (table4) => [
      index("idx_pinterest_boards_active").on(table4.isActive)
    ]);
    pinterestPins = sqliteTable("pinterest_pins", {
      id: integer("id").primaryKey({ autoIncrement: true }),
      articleId: integer("article_id").references(() => articles.id, { onDelete: "cascade" }),
      boardId: integer("board_id").references(() => pinterestBoards.id, { onDelete: "set null" }),
      sectionName: text("section_name"),
      imageUrl: text("image_url").notNull(),
      destinationUrl: text("destination_url").notNull(),
      title: text("title").notNull(),
      description: text("description"),
      tagsJson: text("tags_json").default("[]"),
      status: text("status").default("draft"),
      pinterestPinId: text("pinterest_pin_id"),
      exportedAt: text("exported_at"),
      exportBatchId: text("export_batch_id"),
      createdAt: text("created_at").default(sql`CURRENT_TIMESTAMP`),
      updatedAt: text("updated_at").default(sql`CURRENT_TIMESTAMP`)
    }, (table4) => [
      index("idx_pinterest_pins_board").on(table4.boardId),
      index("idx_pinterest_pins_article").on(table4.articleId),
      index("idx_pinterest_pins_status").on(table4.status),
      index("idx_pinterest_pins_batch").on(table4.exportBatchId)
    ]);
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/drizzle_BakpoMbM.mjs
function aliasedTable(table4, tableAlias) {
  return new Proxy(table4, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}
function extractUsedTable(table4) {
  if (is(table4, SQLiteTable)) {
    return [`${table4[Table.Symbol.BaseName]}`];
  }
  if (is(table4, Subquery)) {
    return table4._.usedTables ?? [];
  }
  if (is(table4, SQL)) {
    return table4.usedTables ?? [];
  }
  return [];
}
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i2) => {
    const formattedWord = i2 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(
    max,
    column
  )}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(
    min,
    column
  )} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema2, configHelpers) {
  if (Object.keys(schema2).length === 1 && "default" in schema2 && !is(schema2["default"], Table)) {
    schema2 = schema2["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema2)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(
        configHelpers(value.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table4, config3) {
    return new One(
      sourceTable,
      table4,
      config3,
      config3?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  }, "one");
}
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config3) {
    return new Many(sourceTable, referencedTable, config3);
  }, "many");
}
function normalizeRelation(schema2, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema2[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder4;
      if (is(field, Column)) {
        decoder4 = field;
      } else if (is(field, SQL)) {
        decoder4 = field.decoder;
      } else {
        decoder4 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder4.mapFromDriverValue(value);
    }
  }
  return result;
}
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder4 = new TextEncoder();
  const data = encoder4.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k) => row[k]);
    rows.push(entry);
  }
  return rows;
}
function drizzle(client, config3 = {}) {
  const dialect = new SQLiteAsyncDialect({ casing: config3.casing });
  let logger;
  if (config3.logger === true) {
    logger = new DefaultLogger();
  } else if (config3.logger !== false) {
    logger = config3.logger;
  }
  let schema2;
  if (config3.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config3.schema,
      createTableRelationsHelpers
    );
    schema2 = {
      fullSchema: config3.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema2, { logger, cache: config3.cache });
  const db = new DrizzleD1Database("async", dialect, session, schema2);
  db.$client = client;
  db.$cache = config3.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config3.cache?.onMutate;
  }
  return db;
}
function createDb(d1) {
  return drizzle(d1, { schema });
}
var MessagePort4, MessageChannelPolyfill3, ColumnAliasProxyHandler, TableAliasProxyHandler, SelectionProxyHandler, QueryPromise, SQLiteDeleteBase, CasingCache, DrizzleError, DrizzleQueryError, TransactionRollbackError, InlineForeignKeys2, EnableRLS, PgTable, PrimaryKeyBuilder, PrimaryKey, eq, ne, gt, gte, lt, lte, Relation, Relations, One, Many, SQLiteViewBase, SQLiteDialect, SQLiteSyncDialect, SQLiteAsyncDialect, TypedQueryBuilder, SQLiteSelectBuilder, SQLiteSelectQueryBuilderBase, SQLiteSelectBase, getSQLiteSetOperators, union, unionAll, intersect, except, QueryBuilder, SQLiteInsertBuilder, SQLiteInsertBase, SQLiteUpdateBuilder, SQLiteUpdateBase, SQLiteCountBuilder, RelationalQueryBuilder, SQLiteRelationalQuery, SQLiteSyncRelationalQuery, SQLiteRaw, BaseSQLiteDatabase, Cache, NoopCache, ExecuteResultSync, SQLitePreparedQuery, SQLiteSession, SQLiteTransaction, ConsoleLogWriter, DefaultLogger, NoopLogger, SQLiteD1Session, D1Transaction, D1PreparedQuery, DrizzleD1Database, schema;
var init_drizzle_BakpoMbM = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/drizzle_BakpoMbM.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_templates_schema_DMbF8Dv3();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    ColumnAliasProxyHandler = class {
      static {
        __name(this, "ColumnAliasProxyHandler");
      }
      constructor(table4) {
        this.table = table4;
      }
      static [entityKind] = "ColumnAliasProxyHandler";
      get(columnObj, prop) {
        if (prop === "table") {
          return this.table;
        }
        return columnObj[prop];
      }
    };
    TableAliasProxyHandler = class {
      static {
        __name(this, "TableAliasProxyHandler");
      }
      constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
      }
      static [entityKind] = "TableAliasProxyHandler";
      get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
          return true;
        }
        if (prop === Table.Symbol.Name) {
          return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
          return this.alias;
        }
        if (prop === ViewBaseConfig) {
          return {
            ...target[ViewBaseConfig],
            name: this.alias,
            isAlias: true
          };
        }
        if (prop === Table.Symbol.Columns) {
          const columns = target[Table.Symbol.Columns];
          if (!columns) {
            return columns;
          }
          const proxiedColumns = {};
          Object.keys(columns).map((key) => {
            proxiedColumns[key] = new Proxy(
              columns[key],
              new ColumnAliasProxyHandler(new Proxy(target, this))
            );
          });
          return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
          return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
      }
    };
    __name(aliasedTable, "aliasedTable");
    __name(aliasedTableColumn, "aliasedTableColumn");
    __name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
    __name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");
    SelectionProxyHandler = class _SelectionProxyHandler {
      static {
        __name(this, "SelectionProxyHandler");
      }
      static [entityKind] = "SelectionProxyHandler";
      config;
      constructor(config3) {
        this.config = { ...config3 };
      }
      get(subquery, prop) {
        if (prop === "_") {
          return {
            ...subquery["_"],
            selectedFields: new Proxy(
              subquery._.selectedFields,
              this
            )
          };
        }
        if (prop === ViewBaseConfig) {
          return {
            ...subquery[ViewBaseConfig],
            selectedFields: new Proxy(
              subquery[ViewBaseConfig].selectedFields,
              this
            )
          };
        }
        if (typeof prop === "symbol") {
          return subquery[prop];
        }
        const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
          if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
            return value.sql;
          }
          const newValue = value.clone();
          newValue.isSelectionField = true;
          return newValue;
        }
        if (is(value, SQL)) {
          if (this.config.sqlBehavior === "sql") {
            return value;
          }
          throw new Error(
            `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
          );
        }
        if (is(value, Column)) {
          if (this.config.alias) {
            return new Proxy(
              value,
              new ColumnAliasProxyHandler(
                new Proxy(
                  value.table,
                  new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
                )
              )
            );
          }
          return value;
        }
        if (typeof value !== "object" || value === null) {
          return value;
        }
        return new Proxy(value, new _SelectionProxyHandler(this.config));
      }
    };
    QueryPromise = class {
      static {
        __name(this, "QueryPromise");
      }
      static [entityKind] = "QueryPromise";
      [Symbol.toStringTag] = "QueryPromise";
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
      then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
      }
    };
    __name(extractUsedTable, "extractUsedTable");
    SQLiteDeleteBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteDeleteBase");
      }
      constructor(table4, session, dialect, withList) {
        super();
        this.table = table4;
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table4, withList };
      }
      static [entityKind] = "SQLiteDelete";
      /** @internal */
      config;
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will delete only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be deleted.
       *
       * ```ts
       * // Delete all cars with green color
       * db.delete(cars).where(eq(cars.color, 'green'));
       * // or
       * db.delete(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Delete all BMW cars with a green color
       * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Delete all cars with the green or blue color
       * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.table[Table.Symbol.Columns],
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          this.config.orderBy = orderByArray;
        } else {
          const orderByArray = columns;
          this.config.orderBy = orderByArray;
        }
        return this;
      }
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true,
          void 0,
          {
            type: "delete",
            tables: extractUsedTable(this.config.table)
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute(placeholderValues) {
        return this._prepare().execute(placeholderValues);
      }
      $dynamic() {
        return this;
      }
    };
    __name(toSnakeCase, "toSnakeCase");
    __name(toCamelCase, "toCamelCase");
    __name(noopCase, "noopCase");
    CasingCache = class {
      static {
        __name(this, "CasingCache");
      }
      static [entityKind] = "CasingCache";
      /** @internal */
      cache = {};
      cachedTables = {};
      convert;
      constructor(casing) {
        this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
      }
      getColumnCasing(column) {
        if (!column.keyAsName) return column.name;
        const schema2 = column.table[Table.Symbol.Schema] ?? "public";
        const tableName = column.table[Table.Symbol.OriginalName];
        const key = `${schema2}.${tableName}.${column.name}`;
        if (!this.cache[key]) {
          this.cacheTable(column.table);
        }
        return this.cache[key];
      }
      cacheTable(table4) {
        const schema2 = table4[Table.Symbol.Schema] ?? "public";
        const tableName = table4[Table.Symbol.OriginalName];
        const tableKey = `${schema2}.${tableName}`;
        if (!this.cachedTables[tableKey]) {
          for (const column of Object.values(table4[Table.Symbol.Columns])) {
            const columnKey = `${tableKey}.${column.name}`;
            this.cache[columnKey] = this.convert(column.name);
          }
          this.cachedTables[tableKey] = true;
        }
      }
      clearCache() {
        this.cache = {};
        this.cachedTables = {};
      }
    };
    DrizzleError = class extends Error {
      static {
        __name(this, "DrizzleError");
      }
      static [entityKind] = "DrizzleError";
      constructor({ message: message2, cause }) {
        super(message2);
        this.name = "DrizzleError";
        this.cause = cause;
      }
    };
    DrizzleQueryError = class _DrizzleQueryError extends Error {
      static {
        __name(this, "DrizzleQueryError");
      }
      constructor(query, params, cause) {
        super(`Failed query: ${query}
params: ${params}`);
        this.query = query;
        this.params = params;
        this.cause = cause;
        Error.captureStackTrace(this, _DrizzleQueryError);
        if (cause) this.cause = cause;
      }
    };
    TransactionRollbackError = class extends DrizzleError {
      static {
        __name(this, "TransactionRollbackError");
      }
      static [entityKind] = "TransactionRollbackError";
      constructor() {
        super({ message: "Rollback" });
      }
    };
    InlineForeignKeys2 = Symbol.for("drizzle:PgInlineForeignKeys");
    EnableRLS = Symbol.for("drizzle:EnableRLS");
    PgTable = class extends Table {
      static {
        __name(this, "PgTable");
      }
      static [entityKind] = "PgTable";
      /** @internal */
      static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys2,
        EnableRLS
      });
      /**@internal */
      [InlineForeignKeys2] = [];
      /** @internal */
      [EnableRLS] = false;
      /** @internal */
      [Table.Symbol.ExtraConfigBuilder] = void 0;
      /** @internal */
      [Table.Symbol.ExtraConfigColumns] = {};
    };
    PrimaryKeyBuilder = class {
      static {
        __name(this, "PrimaryKeyBuilder");
      }
      static [entityKind] = "PgPrimaryKeyBuilder";
      /** @internal */
      columns;
      /** @internal */
      name;
      constructor(columns, name) {
        this.columns = columns;
        this.name = name;
      }
      /** @internal */
      build(table4) {
        return new PrimaryKey(table4, this.columns, this.name);
      }
    };
    PrimaryKey = class {
      static {
        __name(this, "PrimaryKey");
      }
      constructor(table4, columns, name) {
        this.table = table4;
        this.columns = columns;
        this.name = name;
      }
      static [entityKind] = "PgPrimaryKey";
      columns;
      name;
      getName() {
        return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
      }
    };
    __name(bindIfParam, "bindIfParam");
    eq = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} = ${bindIfParam(right, left)}`;
    }, "eq");
    ne = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <> ${bindIfParam(right, left)}`;
    }, "ne");
    __name(and, "and");
    __name(or, "or");
    __name(not, "not");
    gt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} > ${bindIfParam(right, left)}`;
    }, "gt");
    gte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} >= ${bindIfParam(right, left)}`;
    }, "gte");
    lt = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} < ${bindIfParam(right, left)}`;
    }, "lt");
    lte = /* @__PURE__ */ __name((left, right) => {
      return sql`${left} <= ${bindIfParam(right, left)}`;
    }, "lte");
    __name(inArray, "inArray");
    __name(notInArray, "notInArray");
    __name(isNull, "isNull");
    __name(isNotNull, "isNotNull");
    __name(exists, "exists");
    __name(notExists, "notExists");
    __name(between, "between");
    __name(notBetween, "notBetween");
    __name(like, "like");
    __name(notLike, "notLike");
    __name(ilike, "ilike");
    __name(notIlike, "notIlike");
    __name(asc, "asc");
    __name(desc, "desc");
    Relation = class {
      static {
        __name(this, "Relation");
      }
      constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
      }
      static [entityKind] = "Relation";
      referencedTableName;
      fieldName;
    };
    Relations = class {
      static {
        __name(this, "Relations");
      }
      constructor(table4, config3) {
        this.table = table4;
        this.config = config3;
      }
      static [entityKind] = "Relations";
    };
    One = class _One extends Relation {
      static {
        __name(this, "One");
      }
      constructor(sourceTable, referencedTable, config3, isNullable) {
        super(sourceTable, referencedTable, config3?.relationName);
        this.config = config3;
        this.isNullable = isNullable;
      }
      static [entityKind] = "One";
      withFieldName(fieldName) {
        const relation = new _One(
          this.sourceTable,
          this.referencedTable,
          this.config,
          this.isNullable
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    Many = class _Many extends Relation {
      static {
        __name(this, "Many");
      }
      constructor(sourceTable, referencedTable, config3) {
        super(sourceTable, referencedTable, config3?.relationName);
        this.config = config3;
      }
      static [entityKind] = "Many";
      withFieldName(fieldName) {
        const relation = new _Many(
          this.sourceTable,
          this.referencedTable,
          this.config
        );
        relation.fieldName = fieldName;
        return relation;
      }
    };
    __name(getOperators, "getOperators");
    __name(getOrderByOperators, "getOrderByOperators");
    __name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
    __name(createOne, "createOne");
    __name(createMany, "createMany");
    __name(normalizeRelation, "normalizeRelation");
    __name(createTableRelationsHelpers, "createTableRelationsHelpers");
    __name(mapRelationalRow, "mapRelationalRow");
    SQLiteViewBase = class extends View {
      static {
        __name(this, "SQLiteViewBase");
      }
      static [entityKind] = "SQLiteViewBase";
    };
    SQLiteDialect = class {
      static {
        __name(this, "SQLiteDialect");
      }
      static [entityKind] = "SQLiteDialect";
      /** @internal */
      casing;
      constructor(config3) {
        this.casing = new CasingCache(config3?.casing);
      }
      escapeName(name) {
        return `"${name}"`;
      }
      escapeParam(_num) {
        return "?";
      }
      escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
      }
      buildWithCTE(queries) {
        if (!queries?.length) return void 0;
        const withSqlChunks = [sql`with `];
        for (const [i2, w] of queries.entries()) {
          withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
          if (i2 < queries.length - 1) {
            withSqlChunks.push(sql`, `);
          }
        }
        withSqlChunks.push(sql` `);
        return sql.join(withSqlChunks);
      }
      buildDeleteQuery({ table: table4, where, returning, withList, limit, orderBy }) {
        const withSql = this.buildWithCTE(withList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        return sql`${withSql}delete from ${table4}${whereSql}${returningSql}${orderBySql}${limitSql}`;
      }
      buildUpdateSet(table4, set) {
        const tableColumns = table4[Table.Symbol.Columns];
        const columnNames = Object.keys(tableColumns).filter(
          (colName) => set[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
        );
        const setSize = columnNames.length;
        return sql.join(columnNames.flatMap((colName, i2) => {
          const col = tableColumns[colName];
          const onUpdateFnResult = col.onUpdateFn?.();
          const value = set[colName] ?? (is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));
          const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
          if (i2 < setSize - 1) {
            return [res, sql.raw(", ")];
          }
          return [res];
        }));
      }
      buildUpdateQuery({ table: table4, set, where, returning, withList, joins, from, limit, orderBy }) {
        const withSql = this.buildWithCTE(withList);
        const setSql = this.buildUpdateSet(table4, set);
        const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
        const joinsSql = this.buildJoins(joins);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const whereSql = where ? sql` where ${where}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        return sql`${withSql}update ${table4} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;
      }
      /**
       * Builds selection SQL with provided fields/expressions
       *
       * Examples:
       *
       * `select <selection> from`
       *
       * `insert ... returning <selection>`
       *
       * If `isSingleTable` is true, then columns won't be prefixed with table name
       */
      buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields.flatMap(({ field }, i2) => {
          const chunk = [];
          if (is(field, SQL.Aliased) && field.isSelectionField) {
            chunk.push(sql.identifier(field.fieldAlias));
          } else if (is(field, SQL.Aliased) || is(field, SQL)) {
            const query = is(field, SQL.Aliased) ? field.sql : field;
            if (isSingleTable) {
              chunk.push(
                new SQL(
                  query.queryChunks.map((c) => {
                    if (is(c, Column)) {
                      return sql.identifier(this.casing.getColumnCasing(c));
                    }
                    return c;
                  })
                )
              );
            } else {
              chunk.push(query);
            }
            if (is(field, SQL.Aliased)) {
              chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
            }
          } else if (is(field, Column)) {
            const tableName = field.table[Table.Symbol.Name];
            if (field.columnType === "SQLiteNumericBigInt") {
              if (isSingleTable) {
                chunk.push(sql`cast(${sql.identifier(this.casing.getColumnCasing(field))} as text)`);
              } else {
                chunk.push(
                  sql`cast(${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))} as text)`
                );
              }
            } else {
              if (isSingleTable) {
                chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
              } else {
                chunk.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
              }
            }
          } else if (is(field, Subquery)) {
            const entries = Object.entries(field._.selectedFields);
            if (entries.length === 1) {
              const entry = entries[0][1];
              const fieldDecoder = is(entry, SQL) ? entry.decoder : is(entry, Column) ? { mapFromDriverValue: /* @__PURE__ */ __name((v) => entry.mapFromDriverValue(v), "mapFromDriverValue") } : entry.sql.decoder;
              if (fieldDecoder) field._.sql.decoder = fieldDecoder;
            }
            chunk.push(field);
          }
          if (i2 < columnsLen - 1) {
            chunk.push(sql`, `);
          }
          return chunk;
        });
        return sql.join(chunks);
      }
      buildJoins(joins) {
        if (!joins || joins.length === 0) {
          return void 0;
        }
        const joinsArray = [];
        if (joins) {
          for (const [index2, joinMeta] of joins.entries()) {
            if (index2 === 0) {
              joinsArray.push(sql` `);
            }
            const table4 = joinMeta.table;
            const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : void 0;
            if (is(table4, SQLiteTable)) {
              const tableName = table4[SQLiteTable.Symbol.Name];
              const tableSchema = table4[SQLiteTable.Symbol.Schema];
              const origTableName = table4[SQLiteTable.Symbol.OriginalName];
              const alias = tableName === origTableName ? void 0 : joinMeta.alias;
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`
              );
            } else {
              joinsArray.push(
                sql`${sql.raw(joinMeta.joinType)} join ${table4}${onSql}`
              );
            }
            if (index2 < joins.length - 1) {
              joinsArray.push(sql` `);
            }
          }
        }
        return sql.join(joinsArray);
      }
      buildLimit(limit) {
        return typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
      }
      buildOrderBy(orderBy) {
        const orderByList = [];
        if (orderBy) {
          for (const [index2, orderByValue] of orderBy.entries()) {
            orderByList.push(orderByValue);
            if (index2 < orderBy.length - 1) {
              orderByList.push(sql`, `);
            }
          }
        }
        return orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
      }
      buildFromTable(table4) {
        if (is(table4, Table) && table4[Table.Symbol.IsAlias]) {
          return sql`${sql`${sql.identifier(table4[Table.Symbol.Schema] ?? "")}.`.if(table4[Table.Symbol.Schema])}${sql.identifier(table4[Table.Symbol.OriginalName])} ${sql.identifier(table4[Table.Symbol.Name])}`;
        }
        return table4;
      }
      buildSelectQuery({
        withList,
        fields,
        fieldsFlat,
        where,
        having,
        table: table4,
        joins,
        orderBy,
        groupBy,
        limit,
        offset,
        distinct,
        setOperators
      }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
          if (is(f.field, Column) && getTableName(f.field.table) !== (is(table4, Subquery) ? table4._.alias : is(table4, SQLiteViewBase) ? table4[ViewBaseConfig].name : is(table4, SQL) ? void 0 : getTableName(table4)) && !((table23) => joins?.some(
            ({ alias }) => alias === (table23[Table.Symbol.IsAlias] ? getTableName(table23) : table23[Table.Symbol.BaseName])
          ))(f.field.table)) {
            const tableName = getTableName(f.field.table);
            throw new Error(
              `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
            );
          }
        }
        const isSingleTable = !joins || joins.length === 0;
        const withSql = this.buildWithCTE(withList);
        const distinctSql = distinct ? sql` distinct` : void 0;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = this.buildFromTable(table4);
        const joinsSql = this.buildJoins(joins);
        const whereSql = where ? sql` where ${where}` : void 0;
        const havingSql = having ? sql` having ${having}` : void 0;
        const groupByList = [];
        if (groupBy) {
          for (const [index2, groupByValue] of groupBy.entries()) {
            groupByList.push(groupByValue);
            if (index2 < groupBy.length - 1) {
              groupByList.push(sql`, `);
            }
          }
        }
        const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
        const orderBySql = this.buildOrderBy(orderBy);
        const limitSql = this.buildLimit(limit);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
        if (setOperators.length > 0) {
          return this.buildSetOperations(finalQuery, setOperators);
        }
        return finalQuery;
      }
      buildSetOperations(leftSelect, setOperators) {
        const [setOperator, ...rest] = setOperators;
        if (!setOperator) {
          throw new Error("Cannot pass undefined values to any set operator");
        }
        if (rest.length === 0) {
          return this.buildSetOperationQuery({ leftSelect, setOperator });
        }
        return this.buildSetOperations(
          this.buildSetOperationQuery({ leftSelect, setOperator }),
          rest
        );
      }
      buildSetOperationQuery({
        leftSelect,
        setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
      }) {
        const leftChunk = sql`${leftSelect.getSQL()} `;
        const rightChunk = sql`${rightSelect.getSQL()}`;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
          const orderByValues = [];
          for (const singleOrderBy of orderBy) {
            if (is(singleOrderBy, SQLiteColumn)) {
              orderByValues.push(sql.identifier(singleOrderBy.name));
            } else if (is(singleOrderBy, SQL)) {
              for (let i2 = 0; i2 < singleOrderBy.queryChunks.length; i2++) {
                const chunk = singleOrderBy.queryChunks[i2];
                if (is(chunk, SQLiteColumn)) {
                  singleOrderBy.queryChunks[i2] = sql.identifier(this.casing.getColumnCasing(chunk));
                }
              }
              orderByValues.push(sql`${singleOrderBy}`);
            } else {
              orderByValues.push(sql`${singleOrderBy}`);
            }
          }
          orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
        }
        const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
        const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
        const offsetSql = offset ? sql` offset ${offset}` : void 0;
        return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
      }
      buildInsertQuery({ table: table4, values: valuesOrSelect, onConflict, returning, withList, select }) {
        const valuesSqlList = [];
        const columns = table4[Table.Symbol.Columns];
        const colEntries = Object.entries(columns).filter(
          ([_, col]) => !col.shouldDisableInsert()
        );
        const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
        if (select) {
          const select2 = valuesOrSelect;
          if (is(select2, SQL)) {
            valuesSqlList.push(select2);
          } else {
            valuesSqlList.push(select2.getSQL());
          }
        } else {
          const values = valuesOrSelect;
          valuesSqlList.push(sql.raw("values "));
          for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
              const colValue = value[fieldName];
              if (colValue === void 0 || is(colValue, Param) && colValue.value === void 0) {
                let defaultValue;
                if (col.default !== null && col.default !== void 0) {
                  defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
                } else if (col.defaultFn !== void 0) {
                  const defaultFnResult = col.defaultFn();
                  defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                } else if (!col.default && col.onUpdateFn !== void 0) {
                  const onUpdateFnResult = col.onUpdateFn();
                  defaultValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
                } else {
                  defaultValue = sql`null`;
                }
                valueList.push(defaultValue);
              } else {
                valueList.push(colValue);
              }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
              valuesSqlList.push(sql`, `);
            }
          }
        }
        const withSql = this.buildWithCTE(withList);
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
        const onConflictSql = onConflict?.length ? sql.join(onConflict) : void 0;
        return sql`${withSql}insert into ${table4} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;
      }
      sqlToQuery(sql2, invokeSource) {
        return sql2.toQuery({
          casing: this.casing,
          escapeName: this.escapeName,
          escapeParam: this.escapeParam,
          escapeString: this.escapeString,
          invokeSource
        });
      }
      buildRelationalQuery({
        fullSchema,
        schema: schema2,
        tableNamesMap,
        table: table4,
        tableConfig,
        queryConfig: config3,
        tableAlias,
        nestedQueryRelation,
        joinOn
      }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config3 === true) {
          const selectionEntries = Object.entries(tableConfig.columns);
          selection = selectionEntries.map(([key, value]) => ({
            dbKey: value.name,
            tsKey: key,
            field: aliasedTableColumn(value, tableAlias),
            relationTableTsKey: void 0,
            isJson: false,
            selection: []
          }));
        } else {
          const aliasedColumns = Object.fromEntries(
            Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)])
          );
          if (config3.where) {
            const whereSql = typeof config3.where === "function" ? config3.where(aliasedColumns, getOperators()) : config3.where;
            where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
          }
          const fieldsSelection = [];
          let selectedColumns = [];
          if (config3.columns) {
            let isIncludeMode = false;
            for (const [field, value] of Object.entries(config3.columns)) {
              if (value === void 0) {
                continue;
              }
              if (field in tableConfig.columns) {
                if (!isIncludeMode && value === true) {
                  isIncludeMode = true;
                }
                selectedColumns.push(field);
              }
            }
            if (selectedColumns.length > 0) {
              selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config3.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
            }
          } else {
            selectedColumns = Object.keys(tableConfig.columns);
          }
          for (const field of selectedColumns) {
            const column = tableConfig.columns[field];
            fieldsSelection.push({ tsKey: field, value: column });
          }
          let selectedRelations = [];
          if (config3.with) {
            selectedRelations = Object.entries(config3.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
          }
          let extras;
          if (config3.extras) {
            extras = typeof config3.extras === "function" ? config3.extras(aliasedColumns, { sql }) : config3.extras;
            for (const [tsKey, value] of Object.entries(extras)) {
              fieldsSelection.push({
                tsKey,
                value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
              });
            }
          }
          for (const { tsKey, value } of fieldsSelection) {
            selection.push({
              dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
              tsKey,
              field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
              relationTableTsKey: void 0,
              isJson: false,
              selection: []
            });
          }
          let orderByOrig = typeof config3.orderBy === "function" ? config3.orderBy(aliasedColumns, getOrderByOperators()) : config3.orderBy ?? [];
          if (!Array.isArray(orderByOrig)) {
            orderByOrig = [orderByOrig];
          }
          orderBy = orderByOrig.map((orderByValue) => {
            if (is(orderByValue, Column)) {
              return aliasedTableColumn(orderByValue, tableAlias);
            }
            return mapColumnsInSQLToAlias(orderByValue, tableAlias);
          });
          limit = config3.limit;
          offset = config3.offset;
          for (const {
            tsKey: selectedRelationTsKey,
            queryConfig: selectedRelationConfigValue,
            relation
          } of selectedRelations) {
            const normalizedRelation = normalizeRelation(schema2, tableNamesMap, relation);
            const relationTableName = getTableUniqueName(relation.referencedTable);
            const relationTableTsName = tableNamesMap[relationTableName];
            const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
            const joinOn2 = and(
              ...normalizedRelation.fields.map(
                (field2, i2) => eq(
                  aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias),
                  aliasedTableColumn(field2, tableAlias)
                )
              )
            );
            const builtRelation = this.buildRelationalQuery({
              fullSchema,
              schema: schema2,
              tableNamesMap,
              table: fullSchema[relationTableTsName],
              tableConfig: schema2[relationTableTsName],
              queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
              tableAlias: relationTableAlias,
              joinOn: joinOn2,
              nestedQueryRelation: relation
            });
            const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
            selection.push({
              dbKey: selectedRelationTsKey,
              tsKey: selectedRelationTsKey,
              field,
              relationTableTsKey: relationTableTsName,
              isJson: true,
              selection: builtRelation.selection
            });
          }
        }
        if (selection.length === 0) {
          throw new DrizzleError({
            message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
          });
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
          let field = sql`json_array(${sql.join(
            selection.map(
              ({ field: field2 }) => is(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is(field2, SQL.Aliased) ? field2.sql : field2
            ),
            sql`, `
          )})`;
          if (is(nestedQueryRelation, Many)) {
            field = sql`coalesce(json_group_array(${field}), json_array())`;
          }
          const nestedSelection = [{
            dbKey: "data",
            tsKey: "data",
            field: field.as("data"),
            isJson: true,
            relationTableTsKey: tableConfig.tsName,
            selection
          }];
          const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
          if (needsSubquery) {
            result = this.buildSelectQuery({
              table: aliasedTable(table4, tableAlias),
              fields: {},
              fieldsFlat: [
                {
                  path: [],
                  field: sql.raw("*")
                }
              ],
              where,
              limit,
              offset,
              orderBy,
              setOperators: []
            });
            where = void 0;
            limit = void 0;
            offset = void 0;
            orderBy = void 0;
          } else {
            result = aliasedTable(table4, tableAlias);
          }
          result = this.buildSelectQuery({
            table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
            fields: {},
            fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
              path: [],
              field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        } else {
          result = this.buildSelectQuery({
            table: aliasedTable(table4, tableAlias),
            fields: {},
            fieldsFlat: selection.map(({ field }) => ({
              path: [],
              field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
            })),
            joins,
            where,
            limit,
            offset,
            orderBy,
            setOperators: []
          });
        }
        return {
          tableTsKey: tableConfig.tsName,
          sql: result,
          selection
        };
      }
    };
    SQLiteSyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteSyncDialect");
      }
      static [entityKind] = "SQLiteSyncDialect";
      migrate(migrations, session, config3) {
        const migrationsTable = config3 === void 0 ? "__drizzle_migrations" : typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        session.run(sql`BEGIN`);
        try {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                session.run(sql.raw(stmt));
              }
              session.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
          session.run(sql`COMMIT`);
        } catch (e2) {
          session.run(sql`ROLLBACK`);
          throw e2;
        }
      }
    };
    SQLiteAsyncDialect = class extends SQLiteDialect {
      static {
        __name(this, "SQLiteAsyncDialect");
      }
      static [entityKind] = "SQLiteAsyncDialect";
      async migrate(migrations, session, config3) {
        const migrationsTable = config3 === void 0 ? "__drizzle_migrations" : typeof config3 === "string" ? "__drizzle_migrations" : config3.migrationsTable ?? "__drizzle_migrations";
        const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(
          sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
        );
        const lastDbMigration = dbMigrations[0] ?? void 0;
        await session.transaction(async (tx) => {
          for (const migration of migrations) {
            if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
              for (const stmt of migration.sql) {
                await tx.run(sql.raw(stmt));
              }
              await tx.run(
                sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
              );
            }
          }
        });
      }
    };
    TypedQueryBuilder = class {
      static {
        __name(this, "TypedQueryBuilder");
      }
      static [entityKind] = "TypedQueryBuilder";
      /** @internal */
      getSelectedFields() {
        return this._.selectedFields;
      }
    };
    SQLiteSelectBuilder = class {
      static {
        __name(this, "SQLiteSelectBuilder");
      }
      static [entityKind] = "SQLiteSelectBuilder";
      fields;
      session;
      dialect;
      withList;
      distinct;
      constructor(config3) {
        this.fields = config3.fields;
        this.session = config3.session;
        this.dialect = config3.dialect;
        this.withList = config3.withList;
        this.distinct = config3.distinct;
      }
      from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
          fields = this.fields;
        } else if (is(source, Subquery)) {
          fields = Object.fromEntries(
            Object.keys(source._.selectedFields).map((key) => [key, source[key]])
          );
        } else if (is(source, SQLiteViewBase)) {
          fields = source[ViewBaseConfig].selectedFields;
        } else if (is(source, SQL)) {
          fields = {};
        } else {
          fields = getTableColumns(source);
        }
        return new SQLiteSelectBase({
          table: source,
          fields,
          isPartialSelect,
          session: this.session,
          dialect: this.dialect,
          withList: this.withList,
          distinct: this.distinct
        });
      }
    };
    SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
      static {
        __name(this, "SQLiteSelectQueryBuilderBase");
      }
      static [entityKind] = "SQLiteSelectQueryBuilder";
      _;
      /** @internal */
      config;
      joinsNotNullableMap;
      tableName;
      isPartialSelect;
      session;
      dialect;
      cacheConfig = void 0;
      usedTables = /* @__PURE__ */ new Set();
      constructor({ table: table4, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
          withList,
          table: table4,
          fields: { ...fields },
          distinct,
          setOperators: []
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
          selectedFields: fields,
          config: this.config
        };
        this.tableName = getTableLikeName(table4);
        this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
        for (const item of extractUsedTable(table4)) this.usedTables.add(item);
      }
      /** @internal */
      getUsedTables() {
        return [...this.usedTables];
      }
      createJoin(joinType) {
        return (table4, on3) => {
          const baseTableName = this.tableName;
          const tableName = getTableLikeName(table4);
          for (const item of extractUsedTable(table4)) this.usedTables.add(item);
          if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (!this.isPartialSelect) {
            if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
              this.config.fields = {
                [baseTableName]: this.config.fields
              };
            }
            if (typeof tableName === "string" && !is(table4, SQL)) {
              const selection = is(table4, Subquery) ? table4._.selectedFields : is(table4, View) ? table4[ViewBaseConfig].selectedFields : table4[Table.Symbol.Columns];
              this.config.fields[tableName] = selection;
            }
          }
          if (typeof on3 === "function") {
            on3 = on3(
              new Proxy(
                this.config.fields,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          if (!this.config.joins) {
            this.config.joins = [];
          }
          this.config.joins.push({ on: on3, table: table4, joinType, alias: tableName });
          if (typeof tableName === "string") {
            switch (joinType) {
              case "left": {
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
              case "right": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "cross":
              case "inner": {
                this.joinsNotNullableMap[tableName] = true;
                break;
              }
              case "full": {
                this.joinsNotNullableMap = Object.fromEntries(
                  Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
                );
                this.joinsNotNullableMap[tableName] = false;
                break;
              }
            }
          }
          return this;
        };
      }
      /**
       * Executes a `left join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet | null; }[] = await db.select()
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number | null; }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .leftJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      leftJoin = this.createJoin("left");
      /**
       * Executes a `right join` operation by adding another table to the current query.
       *
       * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet; }[] = await db.select()
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number; }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .rightJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      rightJoin = this.createJoin("right");
      /**
       * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
       *
       * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .innerJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      innerJoin = this.createJoin("inner");
      /**
       * Executes a `full join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
       *
       * @param table the table to join.
       * @param on the `on` clause.
       *
       * @example
       *
       * ```ts
       * // Select all users and their pets
       * const usersWithPets: { user: User | null; pets: Pet | null; }[] = await db.select()
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number | null; petId: number | null; }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .fullJoin(pets, eq(users.id, pets.ownerId))
       * ```
       */
      fullJoin = this.createJoin("full");
      /**
       * Executes a `cross join` operation by combining rows from two tables into a new table.
       *
       * Calling this method retrieves all rows from both main and joined tables, merging all rows from each table.
       *
       * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join}
       *
       * @param table the table to join.
       *
       * @example
       *
       * ```ts
       * // Select all users, each user with every pet
       * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
       *   .from(users)
       *   .crossJoin(pets)
       *
       * // Select userId and petId
       * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
       *   userId: users.id,
       *   petId: pets.id,
       * })
       *   .from(users)
       *   .crossJoin(pets)
       * ```
       */
      crossJoin = this.createJoin("cross");
      createSetOperator(type, isAll) {
        return (rightSelection) => {
          const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
          if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
            throw new Error(
              "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
            );
          }
          this.config.setOperators.push({ type, isAll, rightSelect });
          return this;
        };
      }
      /**
       * Adds `union` set operator to the query.
       *
       * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
       *
       * @example
       *
       * ```ts
       * // Select all unique names from customers and users tables
       * await db.select({ name: users.name })
       *   .from(users)
       *   .union(
       *     db.select({ name: customers.name }).from(customers)
       *   );
       * // or
       * import { union } from 'drizzle-orm/sqlite-core'
       *
       * await union(
       *   db.select({ name: users.name }).from(users),
       *   db.select({ name: customers.name }).from(customers)
       * );
       * ```
       */
      union = this.createSetOperator("union", false);
      /**
       * Adds `union all` set operator to the query.
       *
       * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
       *
       * @example
       *
       * ```ts
       * // Select all transaction ids from both online and in-store sales
       * await db.select({ transaction: onlineSales.transactionId })
       *   .from(onlineSales)
       *   .unionAll(
       *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       *   );
       * // or
       * import { unionAll } from 'drizzle-orm/sqlite-core'
       *
       * await unionAll(
       *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
       *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
       * );
       * ```
       */
      unionAll = this.createSetOperator("union", true);
      /**
       * Adds `intersect` set operator to the query.
       *
       * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
       *
       * @example
       *
       * ```ts
       * // Select course names that are offered in both departments A and B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .intersect(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { intersect } from 'drizzle-orm/sqlite-core'
       *
       * await intersect(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      intersect = this.createSetOperator("intersect", false);
      /**
       * Adds `except` set operator to the query.
       *
       * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
       *
       * @example
       *
       * ```ts
       * // Select all courses offered in department A but not in department B
       * await db.select({ courseName: depA.courseName })
       *   .from(depA)
       *   .except(
       *     db.select({ courseName: depB.courseName }).from(depB)
       *   );
       * // or
       * import { except } from 'drizzle-orm/sqlite-core'
       *
       * await except(
       *   db.select({ courseName: depA.courseName }).from(depA),
       *   db.select({ courseName: depB.courseName }).from(depB)
       * );
       * ```
       */
      except = this.createSetOperator("except", false);
      /** @internal */
      addSetOperators(setOperators) {
        this.config.setOperators.push(...setOperators);
        return this;
      }
      /**
       * Adds a `where` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
       *
       * @param where the `where` clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be selected.
       *
       * ```ts
       * // Select all cars with green color
       * await db.select().from(cars).where(eq(cars.color, 'green'));
       * // or
       * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Select all BMW cars with a green color
       * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Select all cars with the green or blue color
       * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        if (typeof where === "function") {
          where = where(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.where = where;
        return this;
      }
      /**
       * Adds a `having` clause to the query.
       *
       * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
       *
       * @param having the `having` clause.
       *
       * @example
       *
       * ```ts
       * // Select all brands with more than one car
       * await db.select({
       * 	brand: cars.brand,
       * 	count: sql<number>`cast(count(${cars.id}) as int)`,
       * })
       *   .from(cars)
       *   .groupBy(cars.brand)
       *   .having(({ count }) => gt(count, 1));
       * ```
       */
      having(having) {
        if (typeof having === "function") {
          having = having(
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
            )
          );
        }
        this.config.having = having;
        return this;
      }
      groupBy(...columns) {
        if (typeof columns[0] === "function") {
          const groupBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        } else {
          this.config.groupBy = columns;
        }
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.fields,
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        } else {
          const orderByArray = columns;
          if (this.config.setOperators.length > 0) {
            this.config.setOperators.at(-1).orderBy = orderByArray;
          } else {
            this.config.orderBy = orderByArray;
          }
        }
        return this;
      }
      /**
       * Adds a `limit` clause to the query.
       *
       * Calling this method will set the maximum number of rows that will be returned by this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param limit the `limit` clause.
       *
       * @example
       *
       * ```ts
       * // Get the first 10 people from this query.
       * await db.select().from(people).limit(10);
       * ```
       */
      limit(limit) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).limit = limit;
        } else {
          this.config.limit = limit;
        }
        return this;
      }
      /**
       * Adds an `offset` clause to the query.
       *
       * Calling this method will skip a number of rows when returning results from this query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
       *
       * @param offset the `offset` clause.
       *
       * @example
       *
       * ```ts
       * // Get the 10th-20th people from this query.
       * await db.select().from(people).offset(10).limit(10);
       * ```
       */
      offset(offset) {
        if (this.config.setOperators.length > 0) {
          this.config.setOperators.at(-1).offset = offset;
        } else {
          this.config.offset = offset;
        }
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildSelectQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      as(alias) {
        const usedTables = [];
        usedTables.push(...extractUsedTable(this.config.table));
        if (this.config.joins) {
          for (const it of this.config.joins) usedTables.push(...extractUsedTable(it.table));
        }
        return new Proxy(
          new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      /** @internal */
      getSelectedFields() {
        return new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
      $dynamic() {
        return this;
      }
    };
    SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
      static {
        __name(this, "SQLiteSelectBase");
      }
      static [entityKind] = "SQLiteSelect";
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        if (!this.session) {
          throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          fieldsList,
          "all",
          true,
          void 0,
          {
            type: "select",
            tables: [...this.usedTables]
          },
          this.cacheConfig
        );
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
      }
      $withCache(config3) {
        this.cacheConfig = config3 === void 0 ? { config: {}, enable: true, autoInvalidate: true } : config3 === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config3 };
        return this;
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.all();
      }
    };
    applyMixins(SQLiteSelectBase, [QueryPromise]);
    __name(createSetOperator, "createSetOperator");
    getSQLiteSetOperators = /* @__PURE__ */ __name(() => ({
      union,
      unionAll,
      intersect,
      except
    }), "getSQLiteSetOperators");
    union = createSetOperator("union", false);
    unionAll = createSetOperator("union", true);
    intersect = createSetOperator("intersect", false);
    except = createSetOperator("except", false);
    QueryBuilder = class {
      static {
        __name(this, "QueryBuilder");
      }
      static [entityKind] = "SQLiteQueryBuilder";
      dialect;
      dialectConfig;
      constructor(dialect) {
        this.dialect = is(dialect, SQLiteDialect) ? dialect : void 0;
        this.dialectConfig = is(dialect, SQLiteDialect) ? void 0 : dialect;
      }
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const queryBuilder = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(queryBuilder);
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: void 0,
            dialect: self.getDialect(),
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        return { select, selectDistinct };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: void 0,
          dialect: this.getDialect(),
          distinct: true
        });
      }
      // Lazy load dialect to avoid circular dependency
      getDialect() {
        if (!this.dialect) {
          this.dialect = new SQLiteSyncDialect(this.dialectConfig);
        }
        return this.dialect;
      }
    };
    SQLiteInsertBuilder = class {
      static {
        __name(this, "SQLiteInsertBuilder");
      }
      constructor(table4, session, dialect, withList) {
        this.table = table4;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteInsertBuilder";
      values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
          throw new Error("values() must be called with at least one value");
        }
        const mappedValues = values.map((entry) => {
          const result = {};
          const cols = this.table[Table.Symbol.Columns];
          for (const colKey of Object.keys(entry)) {
            const colValue = entry[colKey];
            result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
          }
          return result;
        });
        return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
      }
      select(selectQuery) {
        const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder()) : selectQuery;
        if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
          throw new Error(
            "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
          );
        }
        return new SQLiteInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
      }
    };
    SQLiteInsertBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteInsertBase");
      }
      constructor(table4, values, session, dialect, withList, select) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table: table4, values, withList, select };
      }
      static [entityKind] = "SQLiteInsert";
      /** @internal */
      config;
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /**
       * Adds an `on conflict do nothing` clause to the query.
       *
       * Calling this method simply avoids inserting a row as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
       *
       * @param config The `target` and `where` clauses.
       *
       * @example
       * ```ts
       * // Insert one row and cancel the insert if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing();
       *
       * // Explicitly specify conflict target
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoNothing({ target: cars.id });
       * ```
       */
      onConflictDoNothing(config3 = {}) {
        if (!this.config.onConflict) this.config.onConflict = [];
        if (config3.target === void 0) {
          this.config.onConflict.push(sql` on conflict do nothing`);
        } else {
          const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
          const whereSql = config3.where ? sql` where ${config3.where}` : sql``;
          this.config.onConflict.push(sql` on conflict ${targetSql} do nothing${whereSql}`);
        }
        return this;
      }
      /**
       * Adds an `on conflict do update` clause to the query.
       *
       * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
       *
       * @param config The `target`, `set` and `where` clauses.
       *
       * @example
       * ```ts
       * // Update the row if there's a conflict
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'Porsche' }
       *   });
       *
       * // Upsert with 'where' clause
       * await db.insert(cars)
       *   .values({ id: 1, brand: 'BMW' })
       *   .onConflictDoUpdate({
       *     target: cars.id,
       *     set: { brand: 'newBMW' },
       *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
       *   });
       * ```
       */
      onConflictDoUpdate(config3) {
        if (config3.where && (config3.targetWhere || config3.setWhere)) {
          throw new Error(
            'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
          );
        }
        if (!this.config.onConflict) this.config.onConflict = [];
        const whereSql = config3.where ? sql` where ${config3.where}` : void 0;
        const targetWhereSql = config3.targetWhere ? sql` where ${config3.targetWhere}` : void 0;
        const setWhereSql = config3.setWhere ? sql` where ${config3.setWhere}` : void 0;
        const targetSql = Array.isArray(config3.target) ? sql`${config3.target}` : sql`${[config3.target]}`;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config3.set));
        this.config.onConflict.push(
          sql` on conflict ${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`
        );
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildInsertQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true,
          void 0,
          {
            type: "insert",
            tables: extractUsedTable(this.config.table)
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
    SQLiteUpdateBuilder = class {
      static {
        __name(this, "SQLiteUpdateBuilder");
      }
      constructor(table4, session, dialect, withList) {
        this.table = table4;
        this.session = session;
        this.dialect = dialect;
        this.withList = withList;
      }
      static [entityKind] = "SQLiteUpdateBuilder";
      set(values) {
        return new SQLiteUpdateBase(
          this.table,
          mapUpdateSet(this.table, values),
          this.session,
          this.dialect,
          this.withList
        );
      }
    };
    SQLiteUpdateBase = class extends QueryPromise {
      static {
        __name(this, "SQLiteUpdateBase");
      }
      constructor(table4, set, session, dialect, withList) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table: table4, withList, joins: [] };
      }
      static [entityKind] = "SQLiteUpdate";
      /** @internal */
      config;
      from(source) {
        this.config.from = source;
        return this;
      }
      createJoin(joinType) {
        return (table4, on3) => {
          const tableName = getTableLikeName(table4);
          if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
            throw new Error(`Alias "${tableName}" is already used in this query`);
          }
          if (typeof on3 === "function") {
            const from = this.config.from ? is(table4, SQLiteTable) ? table4[Table.Symbol.Columns] : is(table4, Subquery) ? table4._.selectedFields : is(table4, SQLiteViewBase) ? table4[ViewBaseConfig].selectedFields : void 0 : void 0;
            on3 = on3(
              new Proxy(
                this.config.table[Table.Symbol.Columns],
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              ),
              from && new Proxy(
                from,
                new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
              )
            );
          }
          this.config.joins.push({ on: on3, table: table4, joinType, alias: tableName });
          return this;
        };
      }
      leftJoin = this.createJoin("left");
      rightJoin = this.createJoin("right");
      innerJoin = this.createJoin("inner");
      fullJoin = this.createJoin("full");
      /**
       * Adds a 'where' clause to the query.
       *
       * Calling this method will update only those rows that fulfill a specified condition.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param where the 'where' clause.
       *
       * @example
       * You can use conditional operators and `sql function` to filter the rows to be updated.
       *
       * ```ts
       * // Update all cars with green color
       * db.update(cars).set({ color: 'red' })
       *   .where(eq(cars.color, 'green'));
       * // or
       * db.update(cars).set({ color: 'red' })
       *   .where(sql`${cars.color} = 'green'`)
       * ```
       *
       * You can logically combine conditional operators with `and()` and `or()` operators:
       *
       * ```ts
       * // Update all BMW cars with a green color
       * db.update(cars).set({ color: 'red' })
       *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
       *
       * // Update all cars with the green or blue color
       * db.update(cars).set({ color: 'red' })
       *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
       * ```
       */
      where(where) {
        this.config.where = where;
        return this;
      }
      orderBy(...columns) {
        if (typeof columns[0] === "function") {
          const orderBy = columns[0](
            new Proxy(
              this.config.table[Table.Symbol.Columns],
              new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
            )
          );
          const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
          this.config.orderBy = orderByArray;
        } else {
          const orderByArray = columns;
          this.config.orderBy = orderByArray;
        }
        return this;
      }
      limit(limit) {
        this.config.limit = limit;
        return this;
      }
      returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
      }
      /** @internal */
      getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
      }
      toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
      }
      /** @internal */
      _prepare(isOneTimeQuery = true) {
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          this.dialect.sqlToQuery(this.getSQL()),
          this.config.returning,
          this.config.returning ? "all" : "run",
          true,
          void 0,
          {
            type: "insert",
            tables: extractUsedTable(this.config.table)
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      run = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().run(placeholderValues);
      }, "run");
      all = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().all(placeholderValues);
      }, "all");
      get = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().get(placeholderValues);
      }, "get");
      values = /* @__PURE__ */ __name((placeholderValues) => {
        return this._prepare().values(placeholderValues);
      }, "values");
      async execute() {
        return this.config.returning ? this.all() : this.run();
      }
      $dynamic() {
        return this;
      }
    };
    SQLiteCountBuilder = class _SQLiteCountBuilder extends SQL {
      static {
        __name(this, "SQLiteCountBuilder");
      }
      constructor(params) {
        super(_SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
        this.params = params;
        this.session = params.session;
        this.sql = _SQLiteCountBuilder.buildCount(
          params.source,
          params.filters
        );
      }
      sql;
      static [entityKind] = "SQLiteCountBuilderAsync";
      [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
      session;
      static buildEmbeddedCount(source, filters) {
        return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
      }
      static buildCount(source, filters) {
        return sql`select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters}`;
      }
      then(onfulfilled, onrejected) {
        return Promise.resolve(this.session.count(this.sql)).then(
          onfulfilled,
          onrejected
        );
      }
      catch(onRejected) {
        return this.then(void 0, onRejected);
      }
      finally(onFinally) {
        return this.then(
          (value) => {
            onFinally?.();
            return value;
          },
          (reason) => {
            onFinally?.();
            throw reason;
          }
        );
      }
    };
    RelationalQueryBuilder = class {
      static {
        __name(this, "RelationalQueryBuilder");
      }
      constructor(mode, fullSchema, schema2, tableNamesMap, table4, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table4;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
      }
      static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
      findMany(config3) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config3 ? config3 : {},
          "many"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config3 ? config3 : {},
          "many"
        );
      }
      findFirst(config3) {
        return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config3 ? { ...config3, limit: 1 } : { limit: 1 },
          "first"
        ) : new SQLiteRelationalQuery(
          this.fullSchema,
          this.schema,
          this.tableNamesMap,
          this.table,
          this.tableConfig,
          this.dialect,
          this.session,
          config3 ? { ...config3, limit: 1 } : { limit: 1 },
          "first"
        );
      }
    };
    SQLiteRelationalQuery = class extends QueryPromise {
      static {
        __name(this, "SQLiteRelationalQuery");
      }
      constructor(fullSchema, schema2, tableNamesMap, table4, tableConfig, dialect, session, config3, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema2;
        this.tableNamesMap = tableNamesMap;
        this.table = table4;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config3;
        this.mode = mode;
      }
      static [entityKind] = "SQLiteAsyncRelationalQuery";
      /** @internal */
      mode;
      /** @internal */
      getSQL() {
        return this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        }).sql;
      }
      /** @internal */
      _prepare(isOneTimeQuery = false) {
        const { query, builtQuery } = this._toSQL();
        return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
          builtQuery,
          void 0,
          this.mode === "first" ? "get" : "all",
          true,
          (rawRows, mapColumnValue) => {
            const rows = rawRows.map(
              (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
            );
            if (this.mode === "first") {
              return rows[0];
            }
            return rows;
          }
        );
      }
      prepare() {
        return this._prepare(false);
      }
      _toSQL() {
        const query = this.dialect.buildRelationalQuery({
          fullSchema: this.fullSchema,
          schema: this.schema,
          tableNamesMap: this.tableNamesMap,
          table: this.table,
          tableConfig: this.tableConfig,
          queryConfig: this.config,
          tableAlias: this.tableConfig.tsName
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
      }
      toSQL() {
        return this._toSQL().builtQuery;
      }
      /** @internal */
      executeRaw() {
        if (this.mode === "first") {
          return this._prepare(false).get();
        }
        return this._prepare(false).all();
      }
      async execute() {
        return this.executeRaw();
      }
    };
    SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
      static {
        __name(this, "SQLiteSyncRelationalQuery");
      }
      static [entityKind] = "SQLiteSyncRelationalQuery";
      sync() {
        return this.executeRaw();
      }
    };
    SQLiteRaw = class extends QueryPromise {
      static {
        __name(this, "SQLiteRaw");
      }
      constructor(execute, getSQL, action, dialect, mapBatchResult) {
        super();
        this.execute = execute;
        this.getSQL = getSQL;
        this.dialect = dialect;
        this.mapBatchResult = mapBatchResult;
        this.config = { action };
      }
      static [entityKind] = "SQLiteRaw";
      /** @internal */
      config;
      getQuery() {
        return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
      }
      mapResult(result, isFromBatch) {
        return isFromBatch ? this.mapBatchResult(result) : result;
      }
      _prepare() {
        return this;
      }
      /** @internal */
      isResponseInArrayMode() {
        return false;
      }
    };
    BaseSQLiteDatabase = class {
      static {
        __name(this, "BaseSQLiteDatabase");
      }
      constructor(resultKind, dialect, session, schema2) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema2 ? {
          schema: schema2.schema,
          fullSchema: schema2.fullSchema,
          tableNamesMap: schema2.tableNamesMap
        } : {
          schema: void 0,
          fullSchema: {},
          tableNamesMap: {}
        };
        this.query = {};
        const query = this.query;
        if (this._.schema) {
          for (const [tableName, columns] of Object.entries(this._.schema)) {
            query[tableName] = new RelationalQueryBuilder(
              resultKind,
              schema2.fullSchema,
              this._.schema,
              this._.tableNamesMap,
              schema2.fullSchema[tableName],
              columns,
              dialect,
              session
            );
          }
        }
        this.$cache = { invalidate: /* @__PURE__ */ __name(async (_params) => {
        }, "invalidate") };
      }
      static [entityKind] = "BaseSQLiteDatabase";
      query;
      /**
       * Creates a subquery that defines a temporary named result set as a CTE.
       *
       * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param alias The alias for the subquery.
       *
       * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
       *
       * @example
       *
       * ```ts
       * // Create a subquery with alias 'sq' and use it in the select query
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * const result = await db.with(sq).select().from(sq);
       * ```
       *
       * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
       *
       * ```ts
       * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
       * const sq = db.$with('sq').as(db.select({
       *   name: sql<string>`upper(${users.name})`.as('name'),
       * })
       * .from(users));
       *
       * const result = await db.with(sq).select({ name: sq.name }).from(sq);
       * ```
       */
      $with = /* @__PURE__ */ __name((alias, selection) => {
        const self = this;
        const as = /* @__PURE__ */ __name((qb) => {
          if (typeof qb === "function") {
            qb = qb(new QueryBuilder(self.dialect));
          }
          return new Proxy(
            new WithSubquery(
              qb.getSQL(),
              selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
              alias,
              true
            ),
            new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
          );
        }, "as");
        return { as };
      }, "$with");
      $count(source, filters) {
        return new SQLiteCountBuilder({ source, filters, session: this.session });
      }
      /**
       * Incorporates a previously defined CTE (using `$with`) into the main query.
       *
       * This method allows the main query to reference a temporary named result set.
       *
       * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
       *
       * @param queries The CTEs to incorporate into the main query.
       *
       * @example
       *
       * ```ts
       * // Define a subquery 'sq' as a CTE using $with
       * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
       *
       * // Incorporate the CTE 'sq' into the main query and select from it
       * const result = await db.with(sq).select().from(sq);
       * ```
       */
      with(...queries) {
        const self = this;
        function select(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries
          });
        }
        __name(select, "select");
        function selectDistinct(fields) {
          return new SQLiteSelectBuilder({
            fields: fields ?? void 0,
            session: self.session,
            dialect: self.dialect,
            withList: queries,
            distinct: true
          });
        }
        __name(selectDistinct, "selectDistinct");
        function update(table4) {
          return new SQLiteUpdateBuilder(table4, self.session, self.dialect, queries);
        }
        __name(update, "update");
        function insert(into) {
          return new SQLiteInsertBuilder(into, self.session, self.dialect, queries);
        }
        __name(insert, "insert");
        function delete_(from) {
          return new SQLiteDeleteBase(from, self.session, self.dialect, queries);
        }
        __name(delete_, "delete_");
        return { select, selectDistinct, update, insert, delete: delete_ };
      }
      select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
      }
      selectDistinct(fields) {
        return new SQLiteSelectBuilder({
          fields: fields ?? void 0,
          session: this.session,
          dialect: this.dialect,
          distinct: true
        });
      }
      /**
       * Creates an update query.
       *
       * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
       *
       * Use `.set()` method to specify which values to update.
       *
       * See docs: {@link https://orm.drizzle.team/docs/update}
       *
       * @param table The table to update.
       *
       * @example
       *
       * ```ts
       * // Update all rows in the 'cars' table
       * await db.update(cars).set({ color: 'red' });
       *
       * // Update rows with filters and conditions
       * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
       *
       * // Update with returning clause
       * const updatedCar: Car[] = await db.update(cars)
       *   .set({ color: 'red' })
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      update(table4) {
        return new SQLiteUpdateBuilder(table4, this.session, this.dialect);
      }
      $cache;
      /**
       * Creates an insert query.
       *
       * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
       *
       * See docs: {@link https://orm.drizzle.team/docs/insert}
       *
       * @param table The table to insert into.
       *
       * @example
       *
       * ```ts
       * // Insert one row
       * await db.insert(cars).values({ brand: 'BMW' });
       *
       * // Insert multiple rows
       * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
       *
       * // Insert with returning clause
       * const insertedCar: Car[] = await db.insert(cars)
       *   .values({ brand: 'BMW' })
       *   .returning();
       * ```
       */
      insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
      }
      /**
       * Creates a delete query.
       *
       * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
       *
       * See docs: {@link https://orm.drizzle.team/docs/delete}
       *
       * @param table The table to delete from.
       *
       * @example
       *
       * ```ts
       * // Delete all rows in the 'cars' table
       * await db.delete(cars);
       *
       * // Delete rows with filters and conditions
       * await db.delete(cars).where(eq(cars.color, 'green'));
       *
       * // Delete with returning clause
       * const deletedCar: Car[] = await db.delete(cars)
       *   .where(eq(cars.id, 1))
       *   .returning();
       * ```
       */
      delete(from) {
        return new SQLiteDeleteBase(from, this.session, this.dialect);
      }
      run(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.run(sequel),
            () => sequel,
            "run",
            this.dialect,
            this.session.extractRawRunValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.run(sequel);
      }
      all(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.all(sequel),
            () => sequel,
            "all",
            this.dialect,
            this.session.extractRawAllValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.all(sequel);
      }
      get(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.get(sequel),
            () => sequel,
            "get",
            this.dialect,
            this.session.extractRawGetValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.get(sequel);
      }
      values(query) {
        const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
        if (this.resultKind === "async") {
          return new SQLiteRaw(
            async () => this.session.values(sequel),
            () => sequel,
            "values",
            this.dialect,
            this.session.extractRawValuesValueFromBatchResult.bind(this.session)
          );
        }
        return this.session.values(sequel);
      }
      transaction(transaction, config3) {
        return this.session.transaction(transaction, config3);
      }
    };
    Cache = class {
      static {
        __name(this, "Cache");
      }
      static [entityKind] = "Cache";
    };
    NoopCache = class extends Cache {
      static {
        __name(this, "NoopCache");
      }
      strategy() {
        return "all";
      }
      static [entityKind] = "NoopCache";
      async get(_key) {
        return void 0;
      }
      async put(_hashedQuery, _response, _tables, _config) {
      }
      async onMutate(_params) {
      }
    };
    __name(hashQuery, "hashQuery");
    ExecuteResultSync = class extends QueryPromise {
      static {
        __name(this, "ExecuteResultSync");
      }
      constructor(resultCb) {
        super();
        this.resultCb = resultCb;
      }
      static [entityKind] = "ExecuteResultSync";
      async execute() {
        return this.resultCb();
      }
      sync() {
        return this.resultCb();
      }
    };
    SQLitePreparedQuery = class {
      static {
        __name(this, "SQLitePreparedQuery");
      }
      constructor(mode, executeMethod, query, cache2, queryMetadata, cacheConfig) {
        this.mode = mode;
        this.executeMethod = executeMethod;
        this.query = query;
        this.cache = cache2;
        this.queryMetadata = queryMetadata;
        this.cacheConfig = cacheConfig;
        if (cache2 && cache2.strategy() === "all" && cacheConfig === void 0) {
          this.cacheConfig = { enable: true, autoInvalidate: true };
        }
        if (!this.cacheConfig?.enable) {
          this.cacheConfig = void 0;
        }
      }
      static [entityKind] = "PreparedQuery";
      /** @internal */
      joinsNotNullableMap;
      /** @internal */
      async queryWithCache(queryString, params, query) {
        if (this.cache === void 0 || is(this.cache, NoopCache) || this.queryMetadata === void 0) {
          try {
            return await query();
          } catch (e2) {
            throw new DrizzleQueryError(queryString, params, e2);
          }
        }
        if (this.cacheConfig && !this.cacheConfig.enable) {
          try {
            return await query();
          } catch (e2) {
            throw new DrizzleQueryError(queryString, params, e2);
          }
        }
        if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
          try {
            const [res] = await Promise.all([
              query(),
              this.cache.onMutate({ tables: this.queryMetadata.tables })
            ]);
            return res;
          } catch (e2) {
            throw new DrizzleQueryError(queryString, params, e2);
          }
        }
        if (!this.cacheConfig) {
          try {
            return await query();
          } catch (e2) {
            throw new DrizzleQueryError(queryString, params, e2);
          }
        }
        if (this.queryMetadata.type === "select") {
          const fromCache = await this.cache.get(
            this.cacheConfig.tag ?? await hashQuery(queryString, params),
            this.queryMetadata.tables,
            this.cacheConfig.tag !== void 0,
            this.cacheConfig.autoInvalidate
          );
          if (fromCache === void 0) {
            let result;
            try {
              result = await query();
            } catch (e2) {
              throw new DrizzleQueryError(queryString, params, e2);
            }
            await this.cache.put(
              this.cacheConfig.tag ?? await hashQuery(queryString, params),
              result,
              // make sure we send tables that were used in a query only if user wants to invalidate it on each write
              this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [],
              this.cacheConfig.tag !== void 0,
              this.cacheConfig.config
            );
            return result;
          }
          return fromCache;
        }
        try {
          return await query();
        } catch (e2) {
          throw new DrizzleQueryError(queryString, params, e2);
        }
      }
      getQuery() {
        return this.query;
      }
      mapRunResult(result, _isFromBatch) {
        return result;
      }
      mapAllResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      mapGetResult(_result, _isFromBatch) {
        throw new Error("Not implemented");
      }
      execute(placeholderValues) {
        if (this.mode === "async") {
          return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
      }
      mapResult(response, isFromBatch) {
        switch (this.executeMethod) {
          case "run": {
            return this.mapRunResult(response, isFromBatch);
          }
          case "all": {
            return this.mapAllResult(response, isFromBatch);
          }
          case "get": {
            return this.mapGetResult(response, isFromBatch);
          }
        }
      }
    };
    SQLiteSession = class {
      static {
        __name(this, "SQLiteSession");
      }
      constructor(dialect) {
        this.dialect = dialect;
      }
      static [entityKind] = "SQLiteSession";
      prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
        return this.prepareQuery(
          query,
          fields,
          executeMethod,
          isResponseInArrayMode,
          customResultMapper,
          queryMetadata,
          cacheConfig
        );
      }
      run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
          return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
        } catch (err) {
          throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
        }
      }
      /** @internal */
      extractRawRunValueFromBatchResult(result) {
        return result;
      }
      all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
      }
      /** @internal */
      extractRawAllValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
      }
      /** @internal */
      extractRawGetValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
      values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
      }
      async count(sql2) {
        const result = await this.values(sql2);
        return result[0][0];
      }
      /** @internal */
      extractRawValuesValueFromBatchResult(_result) {
        throw new Error("Not implemented");
      }
    };
    SQLiteTransaction = class extends BaseSQLiteDatabase {
      static {
        __name(this, "SQLiteTransaction");
      }
      constructor(resultType, dialect, session, schema2, nestedIndex = 0) {
        super(resultType, dialect, session, schema2);
        this.schema = schema2;
        this.nestedIndex = nestedIndex;
      }
      static [entityKind] = "SQLiteTransaction";
      rollback() {
        throw new TransactionRollbackError();
      }
    };
    ConsoleLogWriter = class {
      static {
        __name(this, "ConsoleLogWriter");
      }
      static [entityKind] = "ConsoleLogWriter";
      write(message2) {
        console.log(message2);
      }
    };
    DefaultLogger = class {
      static {
        __name(this, "DefaultLogger");
      }
      static [entityKind] = "DefaultLogger";
      writer;
      constructor(config3) {
        this.writer = config3?.writer ?? new ConsoleLogWriter();
      }
      logQuery(query, params) {
        const stringifiedParams = params.map((p) => {
          try {
            return JSON.stringify(p);
          } catch {
            return String(p);
          }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
        this.writer.write(`Query: ${query}${paramsStr}`);
      }
    };
    NoopLogger = class {
      static {
        __name(this, "NoopLogger");
      }
      static [entityKind] = "NoopLogger";
      logQuery() {
      }
    };
    SQLiteD1Session = class extends SQLiteSession {
      static {
        __name(this, "SQLiteD1Session");
      }
      constructor(client, dialect, schema2, options = {}) {
        super(dialect);
        this.client = client;
        this.schema = schema2;
        this.options = options;
        this.logger = options.logger ?? new NoopLogger();
        this.cache = options.cache ?? new NoopCache();
      }
      static [entityKind] = "SQLiteD1Session";
      logger;
      cache;
      prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
        const stmt = this.client.prepare(query.sql);
        return new D1PreparedQuery(
          stmt,
          query,
          this.logger,
          this.cache,
          queryMetadata,
          cacheConfig,
          fields,
          executeMethod,
          isResponseInArrayMode,
          customResultMapper
        );
      }
      async batch(queries) {
        const preparedQueries = [];
        const builtQueries = [];
        for (const query of queries) {
          const preparedQuery = query._prepare();
          const builtQuery = preparedQuery.getQuery();
          preparedQueries.push(preparedQuery);
          if (builtQuery.params.length > 0) {
            builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
          } else {
            const builtQuery2 = preparedQuery.getQuery();
            builtQueries.push(
              this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
            );
          }
        }
        const batchResults = await this.client.batch(builtQueries);
        return batchResults.map((result, i2) => preparedQueries[i2].mapResult(result, true));
      }
      extractRawAllValueFromBatchResult(result) {
        return result.results;
      }
      extractRawGetValueFromBatchResult(result) {
        return result.results[0];
      }
      extractRawValuesValueFromBatchResult(result) {
        return d1ToRawMapping(result.results);
      }
      async transaction(transaction, config3) {
        const tx = new D1Transaction("async", this.dialect, this, this.schema);
        await this.run(sql.raw(`begin${config3?.behavior ? " " + config3.behavior : ""}`));
        try {
          const result = await transaction(tx);
          await this.run(sql`commit`);
          return result;
        } catch (err) {
          await this.run(sql`rollback`);
          throw err;
        }
      }
    };
    D1Transaction = class _D1Transaction extends SQLiteTransaction {
      static {
        __name(this, "D1Transaction");
      }
      static [entityKind] = "D1Transaction";
      async transaction(transaction) {
        const savepointName = `sp${this.nestedIndex}`;
        const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
        await this.session.run(sql.raw(`savepoint ${savepointName}`));
        try {
          const result = await transaction(tx);
          await this.session.run(sql.raw(`release savepoint ${savepointName}`));
          return result;
        } catch (err) {
          await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
          throw err;
        }
      }
    };
    __name(d1ToRawMapping, "d1ToRawMapping");
    D1PreparedQuery = class extends SQLitePreparedQuery {
      static {
        __name(this, "D1PreparedQuery");
      }
      constructor(stmt, query, logger, cache2, queryMetadata, cacheConfig, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
        super("async", executeMethod, query, cache2, queryMetadata, cacheConfig);
        this.logger = logger;
        this._isResponseInArrayMode = _isResponseInArrayMode;
        this.customResultMapper = customResultMapper;
        this.fields = fields;
        this.stmt = stmt;
      }
      static [entityKind] = "D1PreparedQuery";
      /** @internal */
      customResultMapper;
      /** @internal */
      fields;
      /** @internal */
      stmt;
      async run(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return await this.queryWithCache(this.query.sql, params, async () => {
          return this.stmt.bind(...params).run();
        });
      }
      async all(placeholderValues) {
        const { fields, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return await this.queryWithCache(query.sql, params, async () => {
            return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
          });
        }
        const rows = await this.values(placeholderValues);
        return this.mapAllResult(rows);
      }
      mapAllResult(rows, isFromBatch) {
        if (isFromBatch) {
          rows = d1ToRawMapping(rows.results);
        }
        if (!this.fields && !this.customResultMapper) {
          return rows;
        }
        if (this.customResultMapper) {
          return this.customResultMapper(rows);
        }
        return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
      }
      async get(placeholderValues) {
        const { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;
        if (!fields && !customResultMapper) {
          const params = fillPlaceholders(query.params, placeholderValues ?? {});
          logger.logQuery(query.sql, params);
          return await this.queryWithCache(query.sql, params, async () => {
            return stmt.bind(...params).all().then(({ results }) => results[0]);
          });
        }
        const rows = await this.values(placeholderValues);
        if (!rows[0]) {
          return void 0;
        }
        if (customResultMapper) {
          return customResultMapper(rows);
        }
        return mapResultRow(fields, rows[0], joinsNotNullableMap);
      }
      mapGetResult(result, isFromBatch) {
        if (isFromBatch) {
          result = d1ToRawMapping(result.results)[0];
        }
        if (!this.fields && !this.customResultMapper) {
          return result;
        }
        if (this.customResultMapper) {
          return this.customResultMapper([result]);
        }
        return mapResultRow(this.fields, result, this.joinsNotNullableMap);
      }
      async values(placeholderValues) {
        const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
        this.logger.logQuery(this.query.sql, params);
        return await this.queryWithCache(this.query.sql, params, async () => {
          return this.stmt.bind(...params).raw();
        });
      }
      /** @internal */
      isResponseInArrayMode() {
        return this._isResponseInArrayMode;
      }
    };
    DrizzleD1Database = class extends BaseSQLiteDatabase {
      static {
        __name(this, "DrizzleD1Database");
      }
      static [entityKind] = "D1Database";
      async batch(batch) {
        return this.session.batch(batch);
      }
    };
    __name(drizzle, "drizzle");
    schema = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      articles,
      authors,
      categories,
      media,
      pinTemplates,
      pinterestBoards,
      pinterestPins,
      siteSettings,
      tags
    }, Symbol.toStringTag, { value: "Module" }));
    __name(createDb, "createDb");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/hydration_PCOoIFzn.mjs
function safeParseJson(json) {
  if (!json) return null;
  try {
    return typeof json === "string" ? JSON.parse(json) : json;
  } catch {
    return null;
  }
}
function getImageSlot(imagesJson, slot = "thumbnail") {
  const images = safeParseJson(imagesJson);
  if (!images) return null;
  return images[slot] || null;
}
function getImageSrcSet(imagesJson, slot = "thumbnail") {
  const imageSlot = getImageSlot(imagesJson, slot);
  if (!imageSlot?.variants) return "";
  return buildSrcSet(imageSlot.variants);
}
function extractImage(imagesJson, slot = "thumbnail", targetWidth) {
  const images = safeParseJson(imagesJson);
  if (!images) return {};
  const imageSlot = images[slot];
  if (!imageSlot) return {};
  const variant = pickVariantByWidth(imageSlot.variants, targetWidth);
  const normalizedVariantUrl = normalizeImageUrl(variant?.url);
  if (normalizedVariantUrl) {
    return {
      imageUrl: normalizedVariantUrl,
      imageAlt: imageSlot.alt,
      imageWidth: variant.width,
      imageHeight: variant.height
    };
  }
  const normalizedSlotUrl = normalizeImageUrl(imageSlot.url);
  if (normalizedSlotUrl) {
    return {
      imageUrl: normalizedSlotUrl,
      imageAlt: imageSlot.alt,
      imageWidth: imageSlot.width,
      imageHeight: imageSlot.height
    };
  }
  return {};
}
function extractSeo(seoJson) {
  const seo = safeParseJson(seoJson);
  if (!seo) return {};
  return {
    metaTitle: seo.metaTitle,
    metaDescription: seo.metaDescription,
    ogImage: seo.ogImage,
    canonical: seo.canonical ?? void 0
  };
}
function extractTagStyle(styleJson) {
  const style = safeParseJson(styleJson);
  if (!style) return {};
  return {
    color: style.color,
    icon: style.svg_code,
    svgCode: style.svg_code,
    variant: style.variant
  };
}
function hydrateArticle(article) {
  const image = extractImage(article.imagesJson);
  let authorAvatar = extractImage(article.authorImagesJson, "avatar").imageUrl;
  if (!authorAvatar && article.cachedAuthorJson) {
    const cachedAuthor = safeParseJson(article.cachedAuthorJson);
    authorAvatar = cachedAuthor?.avatar;
  }
  if (!authorAvatar && article.author?.imagesJson) {
    authorAvatar = extractImage(article.author.imagesJson, "avatar").imageUrl;
  }
  authorAvatar = normalizeImageUrl(authorAvatar);
  const seo = extractSeo(article.seoJson);
  const route = article.type === "recipe" ? `/recipes/${article.slug}` : `/articles/${article.slug}`;
  return {
    ...article,
    ...image,
    ...seo,
    contentJson: safeParseJson(article.contentJson),
    recipeJson: safeParseJson(article.recipeJson),
    roundupJson: safeParseJson(article.roundupJson),
    faqsJson: safeParseJson(article.faqsJson),
    label: article.headline,
    // Alias for UI consistency
    route,
    authorAvatar
  };
}
function hydrateCategory(category) {
  const image = extractImage(category.imagesJson);
  const seo = extractSeo(category.seoJson);
  const config3 = safeParseJson(category.configJson);
  const numEntriesPerPage = config3?.postsPerPage;
  const tldr = config3?.tldr;
  const layoutMode = config3?.layout;
  const cardStyle = config3?.cardStyle;
  const showInNav = config3?.showInNav;
  const showInFooter = config3?.showInFooter;
  const showSidebar = config3?.showSidebar;
  const showFilters = config3?.showFilters;
  const showBreadcrumb = config3?.showBreadcrumb;
  const showPagination = config3?.showPagination;
  const sortBy = config3?.sortBy;
  const sortOrder = config3?.sortOrder;
  const headerStyle = config3?.headerStyle;
  const rawIconSvg = category.iconSvg ?? category.icon_svg ?? config3?.iconSvg ?? config3?.icon_svg;
  const iconSvg = typeof rawIconSvg === "string" && rawIconSvg.trim() ? rawIconSvg.trim() : void 0;
  return {
    ...category,
    ...image,
    ...seo,
    imagesJson: safeParseJson(category.imagesJson),
    seoJson: safeParseJson(category.seoJson),
    route: `/categories/${category.slug}`,
    ...iconSvg ? { iconSvg } : {},
    ...typeof numEntriesPerPage === "number" ? { numEntriesPerPage } : {},
    ...typeof tldr === "string" ? { tldr } : {},
    ...layoutMode ? { layoutMode } : {},
    ...cardStyle ? { cardStyle } : {},
    ...typeof showInNav === "boolean" ? { showInNav } : {},
    ...typeof showInFooter === "boolean" ? { showInFooter } : {},
    ...typeof showSidebar === "boolean" ? { showSidebar } : {},
    ...typeof showFilters === "boolean" ? { showFilters } : {},
    ...typeof showBreadcrumb === "boolean" ? { showBreadcrumb } : {},
    ...typeof showPagination === "boolean" ? { showPagination } : {},
    ...sortBy ? { sortBy } : {},
    ...sortOrder ? { sortOrder } : {},
    ...headerStyle ? { headerStyle } : {}
  };
}
function hydrateAuthor(author) {
  const image = extractImage(author.imagesJson, "avatar");
  const seo = extractSeo(author.seoJson);
  return {
    ...author,
    ...image,
    ...seo,
    imagesJson: safeParseJson(author.imagesJson),
    seoJson: safeParseJson(author.seoJson),
    job: author.jobTitle,
    // Alias for template compatibility
    route: `/authors/${author.slug}`
  };
}
function hydrateTag(tag2) {
  const style = extractTagStyle(tag2.styleJson);
  return {
    ...tag2,
    ...style,
    styleJson: safeParseJson(tag2.styleJson),
    route: `/tags/${tag2.slug}`
  };
}
function hydrateArticles(articles2) {
  return articles2.map(hydrateArticle);
}
function hydrateCategories(categories2) {
  return categories2.map(hydrateCategory);
}
function hydrateTags(tags2) {
  return tags2.map(hydrateTag);
}
var MessagePort4, MessageChannelPolyfill3, LOCAL_IMAGE_HOST_RE, normalizeImageUrl, buildSrcSet, FALLBACK_VARIANT_ORDER, FALLBACK_VARIANT_ORDER_FOR_TARGET, pickVariantByWidth;
var init_hydration_PCOoIFzn = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/hydration_PCOoIFzn.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(safeParseJson, "safeParseJson");
    __name(getImageSlot, "getImageSlot");
    LOCAL_IMAGE_HOST_RE = /^https?:\/\/(localhost|127\.0\.0\.1)(:\d+)?/i;
    normalizeImageUrl = /* @__PURE__ */ __name((url) => {
      if (!url) return url;
      const trimmed = url.trim();
      if (!trimmed || !LOCAL_IMAGE_HOST_RE.test(trimmed)) return trimmed;
      try {
        const parsed = new URL(trimmed);
        return `${parsed.pathname}${parsed.search}${parsed.hash}`;
      } catch {
        return trimmed.replace(LOCAL_IMAGE_HOST_RE, "");
      }
    }, "normalizeImageUrl");
    buildSrcSet = /* @__PURE__ */ __name((variants) => {
      if (!variants) return "";
      const entries = [];
      const ordered = ["xs", "sm", "md", "lg", "original"];
      for (const key of ordered) {
        const variant = variants[key];
        const normalizedUrl = normalizeImageUrl(variant?.url);
        if (normalizedUrl && variant?.width) {
          entries.push(`${normalizedUrl} ${variant.width}w`);
        }
      }
      return entries.join(", ");
    }, "buildSrcSet");
    __name(getImageSrcSet, "getImageSrcSet");
    FALLBACK_VARIANT_ORDER = ["lg", "md", "sm", "original", "xs"];
    FALLBACK_VARIANT_ORDER_FOR_TARGET = ["xs", "sm", "md", "lg", "original"];
    pickVariantByWidth = /* @__PURE__ */ __name((variants, targetWidth) => {
      if (!variants) return null;
      const entries = Object.entries(variants).filter(([, variant]) => variant && typeof variant.url === "string").map(([key, variant]) => ({ key, ...variant }));
      if (!entries.length) return null;
      const withWidth = entries.filter((variant) => typeof variant.width === "number" && (variant.width || 0) > 0).sort((a2, b) => (a2.width || 0) - (b.width || 0));
      if (targetWidth && withWidth.length > 0) {
        const match = withWidth.find((variant) => (variant.width || 0) >= targetWidth);
        return match || withWidth[withWidth.length - 1] || null;
      }
      const fallbackOrder = targetWidth ? FALLBACK_VARIANT_ORDER_FOR_TARGET : FALLBACK_VARIANT_ORDER;
      for (const key of fallbackOrder) {
        const candidate = variants[key];
        if (candidate?.url) return candidate;
      }
      return entries[0] || null;
    }, "pickVariantByWidth");
    __name(extractImage, "extractImage");
    __name(extractSeo, "extractSeo");
    __name(extractTagStyle, "extractTagStyle");
    __name(hydrateArticle, "hydrateArticle");
    __name(hydrateCategory, "hydrateCategory");
    __name(hydrateAuthor, "hydrateAuthor");
    __name(hydrateTag, "hydrateTag");
    __name(hydrateArticles, "hydrateArticles");
    __name(hydrateCategories, "hydrateCategories");
    __name(hydrateTags, "hydrateTags");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/articles.service_DgNeye45.mjs
async function getArticles(db, options) {
  const drizzle2 = createDb(db);
  const conditions = [];
  conditions.push(isNull(articles.deletedAt));
  if (options?.isOnline === true) {
    conditions.push(eq(articles.isOnline, true));
  }
  if (options?.type) {
    conditions.push(eq(articles.type, options.type));
  }
  if (options?.categoryId) {
    conditions.push(eq(articles.categoryId, options.categoryId));
  }
  if (options?.authorId) {
    conditions.push(eq(articles.authorId, options.authorId));
  }
  if (options?.categorySlug && !options.categoryId) {
    conditions.push(eq(categories.slug, options.categorySlug));
  }
  if (options?.authorSlug && !options.authorId) {
    conditions.push(eq(authors.slug, options.authorSlug));
  }
  if (options?.search) {
    const searchPattern = `%${options.search}%`;
    conditions.push(
      or(
        like(articles.headline, searchPattern),
        like(articles.shortDescription, searchPattern)
      )
    );
  }
  const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
  const sortColumn = options?.sortBy === "title" ? articles.headline : options?.sortBy === "viewCount" ? articles.viewCount : articles.publishedAt;
  const orderByClause = options?.sortOrder === "asc" ? asc(sortColumn) : desc(sortColumn);
  const items = await drizzle2.select({
    ...getTableColumns(articles),
    categoryLabel: categories.label,
    categorySlug: categories.slug,
    categoryColor: categories.color,
    authorName: authors.name,
    authorSlug: authors.slug,
    authorImagesJson: authors.imagesJson
  }).from(articles).leftJoin(categories, eq(articles.categoryId, categories.id)).leftJoin(authors, eq(articles.authorId, authors.id)).where(whereClause).orderBy(orderByClause).limit(options?.limit || 100).offset(options?.offset || 0);
  const [{ count: total }] = await drizzle2.select({ count: sql`count(*)` }).from(articles).leftJoin(categories, eq(articles.categoryId, categories.id)).leftJoin(authors, eq(articles.authorId, authors.id)).where(whereClause);
  return {
    items: hydrateArticles(items),
    total: Number(total)
  };
}
async function getArticleBySlug(db, slug, type) {
  const drizzle2 = createDb(db);
  const conditions = [eq(articles.slug, slug), isNull(articles.deletedAt)];
  if (type) {
    conditions.push(eq(articles.type, type));
  }
  const result = await drizzle2.query.articles.findFirst({
    where: and(...conditions)
  });
  return result ? hydrateArticle(result) : null;
}
async function createArticle(db, article) {
  const drizzle2 = createDb(db);
  const [inserted] = await drizzle2.insert(articles).values(article).returning();
  return inserted || null;
}
async function incrementViewCount(db, slug) {
  const drizzle2 = createDb(db);
  await drizzle2.update(articles).set({ viewCount: sql`${articles.viewCount} + 1` }).where(eq(articles.slug, slug));
  return true;
}
async function getArticleById(db, id) {
  const drizzle2 = createDb(db);
  const result = await drizzle2.query.articles.findFirst({
    where: and(eq(articles.id, id), isNull(articles.deletedAt))
  });
  return result ? hydrateArticle(result) : null;
}
async function updateArticleById(db, id, patch) {
  const drizzle2 = createDb(db);
  const processedPatch = { ...patch };
  const jsonFields = [
    "imagesJson",
    "contentJson",
    "recipeJson",
    "roundupJson",
    "faqsJson",
    "seoJson",
    "configJson",
    "jsonldJson",
    "relatedArticlesJson",
    "cachedTagsJson",
    "cachedCategoryJson",
    "cachedAuthorJson",
    "cachedEquipmentJson",
    "cachedRatingJson",
    "cachedTocJson",
    "cachedRecipeJson",
    "cachedCardJson"
  ];
  for (const field of jsonFields) {
    if (field in processedPatch && processedPatch[field] !== void 0) {
      const value = processedPatch[field];
      if (typeof value === "object" && value !== null) {
        processedPatch[field] = JSON.stringify(value);
      }
    }
  }
  const updateData = {
    ...processedPatch,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  const result = await drizzle2.update(articles).set(updateData).where(and(eq(articles.id, id), isNull(articles.deletedAt))).returning({ id: articles.id });
  return result.length > 0;
}
async function deleteArticleById(db, id) {
  const drizzle2 = createDb(db);
  const result = await drizzle2.update(articles).set({ deletedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(and(eq(articles.id, id), isNull(articles.deletedAt))).returning({ id: articles.id });
  return result.length > 0;
}
async function toggleOnlineById(db, id) {
  const drizzle2 = createDb(db);
  const current = await drizzle2.query.articles.findFirst({
    where: and(eq(articles.id, id), isNull(articles.deletedAt)),
    columns: { isOnline: true }
  });
  if (!current) return null;
  const newValue = !current.isOnline;
  await drizzle2.update(articles).set({ isOnline: newValue, updatedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(articles.id, id));
  return { isOnline: newValue };
}
async function toggleFavoriteById(db, id) {
  const drizzle2 = createDb(db);
  const current = await drizzle2.query.articles.findFirst({
    where: and(eq(articles.id, id), isNull(articles.deletedAt)),
    columns: { isFavorite: true }
  });
  if (!current) return null;
  const newValue = !current.isFavorite;
  await drizzle2.update(articles).set({ isFavorite: newValue, updatedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(articles.id, id));
  return { isFavorite: newValue };
}
async function syncCachedFields(db, id) {
  const drizzle2 = createDb(db);
  const article = await drizzle2.select({
    ...getTableColumns(articles),
    authorName: authors.name,
    authorSlug: authors.slug,
    authorAvatar: authors.imagesJson,
    categoryLabel: categories.label,
    categorySlug: categories.slug,
    categoryColor: categories.color
  }).from(articles).leftJoin(authors, eq(articles.authorId, authors.id)).leftJoin(categories, eq(articles.categoryId, categories.id)).where(eq(articles.id, id)).get();
  if (!article) return false;
  const updateData = {};
  if (article.authorId) {
    const hydrator = hydrateArticle(article);
    updateData.cachedAuthorJson = JSON.stringify({
      name: article.authorName,
      slug: article.authorSlug,
      avatar: hydrator.authorAvatar || null
    });
  }
  if (article.categoryId) {
    updateData.cachedCategoryJson = JSON.stringify({
      label: article.categoryLabel,
      slug: article.categorySlug,
      color: article.categoryColor
    });
  }
  await drizzle2.update(articles).set(updateData).where(eq(articles.id, id));
  return true;
}
var MessagePort4, MessageChannelPolyfill3;
var init_articles_service_DgNeye45 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/articles.service_DgNeye45.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    init_hydration_PCOoIFzn();
    init_templates_schema_DMbF8Dv3();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getArticles, "getArticles");
    __name(getArticleBySlug, "getArticleBySlug");
    __name(createArticle, "createArticle");
    __name(incrementViewCount, "incrementViewCount");
    __name(getArticleById, "getArticleById");
    __name(updateArticleById, "updateArticleById");
    __name(deleteArticleById, "deleteArticleById");
    __name(toggleOnlineById, "toggleOnlineById");
    __name(toggleFavoriteById, "toggleFavoriteById");
    __name(syncCachedFields, "syncCachedFields");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/error-handler_D5quUcAZ.mjs
function formatErrorResponse(error5) {
  let appError;
  if (error5 instanceof AppError) {
    appError = error5;
  } else if (error5 instanceof Error) {
    appError = new AppError(
      ErrorCodes.INTERNAL_ERROR,
      error5.message,
      500
    );
  } else {
    appError = new AppError(
      ErrorCodes.INTERNAL_ERROR,
      "An unexpected error occurred",
      500
    );
  }
  console.error(`[${appError.code}] ${appError.message}`, appError.details);
  return {
    body: JSON.stringify({
      success: false,
      error: appError.message,
      code: appError.code,
      ...appError.details && { details: appError.details }
    }),
    status: appError.statusCode,
    headers: {
      "Content-Type": "application/json"
    }
  };
}
function formatSuccessResponse(data, options) {
  const response = {
    success: true,
    data
  };
  if (options?.pagination) {
    response.pagination = options.pagination;
  }
  const headers = {
    "Content-Type": "application/json"
  };
  if (options?.cacheControl) {
    headers["Cache-Control"] = options.cacheControl;
  }
  return {
    body: JSON.stringify(response),
    status: 200,
    headers
  };
}
function validatePaginationParams(limitParam, pageParam) {
  const limit = Math.min(Math.max(parseInt(limitParam || "12"), 1), 100);
  const page62 = Math.max(parseInt(pageParam || "1"), 1);
  const offset = (page62 - 1) * limit;
  return {
    valid: true,
    limit,
    page: page62,
    offset
  };
}
var MessagePort4, MessageChannelPolyfill3, AppError, ErrorCodes;
var init_error_handler_D5quUcAZ = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/error-handler_D5quUcAZ.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    AppError = class extends Error {
      static {
        __name(this, "AppError");
      }
      code;
      statusCode;
      details;
      constructor(code, message2, statusCode = 500, details) {
        super(message2);
        this.code = code;
        this.statusCode = statusCode;
        this.details = details;
        this.name = "AppError";
      }
    };
    ErrorCodes = {
      NOT_FOUND: "NOT_FOUND",
      VALIDATION_ERROR: "VALIDATION_ERROR",
      UNAUTHORIZED: "UNAUTHORIZED",
      FORBIDDEN: "FORBIDDEN",
      INTERNAL_ERROR: "INTERNAL_ERROR",
      DATABASE_ERROR: "DATABASE_ERROR",
      INVALID_REQUEST: "INVALID_REQUEST"
    };
    __name(formatErrorResponse, "formatErrorResponse");
    __name(formatSuccessResponse, "formatSuccessResponse");
    __name(validatePaginationParams, "validatePaginationParams");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/auth.service_GsDnjv--.mjs
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i2 = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i2);
    i2 += buffer.length;
  }
  return buf;
}
function encode$1(string) {
  const bytes = new Uint8Array(string.length);
  for (let i2 = 0; i2 < string.length; i2++) {
    const code = string.charCodeAt(i2);
    if (code > 127) {
      throw new TypeError("non-ASCII string encountered in encode()");
    }
    bytes[i2] = code;
  }
  return bytes;
}
function encodeBase642(input) {
  if (Uint8Array.prototype.toBase64) {
    return input.toBase64();
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i2 = 0; i2 < input.length; i2 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, input.subarray(i2, i2 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
}
function decodeBase642(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary2 = atob(encoded);
  const bytes = new Uint8Array(binary2.length);
  for (let i2 = 0; i2 < binary2.length; i2++) {
    bytes[i2] = binary2.charCodeAt(i2);
  }
  return bytes;
}
function decode(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder3.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder3.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return decodeBase642(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
function encode(input) {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder2.encode(unencoded);
  }
  if (Uint8Array.prototype.toBase64) {
    return unencoded.toBase64({ alphabet: "base64url", omitPadding: true });
  }
  return encodeBase642(unencoded).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (usage && !key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg, usage) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg))
        throw unusable(alg);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}
function message(msg, actual, ...types2) {
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function isDisjoint(...headers) {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
function checkKeyLength(alg, key) {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
async function jwkToKey(jwk) {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
}
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
async function normalizeKey3(key, alg) {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode(key.k);
    }
    return handleJWK(key, key, alg, true);
  }
  throw new Error("unreachable");
}
function checkKeyType(alg, key, usage) {
  switch (alg.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      symmetricTypeCheck(alg, key, usage);
      break;
    default:
      asymmetricTypeCheck(alg, key, usage);
  }
}
function subtleAlgorithm(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: parseInt(alg.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
async function getSigKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg, usage);
  return key;
}
async function verify(alg, key, signature, data) {
  const cryptoKey = await getSigKey(alg, key, "verify");
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
}
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder3.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType(alg, key, "verify");
  const data = concat(jws.protected !== void 0 ? encode$1(jws.protected) : new Uint8Array(), encode$1("."), typeof jws.payload === "string" ? b64 ? encode$1(jws.payload) : encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k = await normalizeKey3(key, alg);
  const verified = await verify(alg, k, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: k };
  }
  return result;
}
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder3.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
function secs(str) {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}
function validateInput2(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder3.decode(encodedPayload));
  } catch {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
async function sign(alg, key, data) {
  const cryptoKey = await getSigKey(alg, key, "sign");
  checkKeyLength(alg, cryptoKey);
  const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
}
async function generateJWT(payload, secret, expiresIn = "24h") {
  const secretKey = new TextEncoder().encode(secret);
  return new SignJWT({ ...payload }).setProtectedHeader({ alg: "HS256" }).setIssuedAt().setExpirationTime(expiresIn).sign(secretKey);
}
async function verifyAuthToken(authHeader, secret) {
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return null;
  }
  const token = authHeader.substring(7);
  try {
    const secretKey = new TextEncoder().encode(secret);
    const { payload } = await jwtVerify(token, secretKey);
    return payload;
  } catch (error5) {
    return null;
  }
}
function hasRole(authContext, requiredRole) {
  if (!authContext?.isAuthenticated) {
    return false;
  }
  const roleHierarchy = {
    admin: 3,
    editor: 2,
    viewer: 1
  };
  const userRoleLevel = roleHierarchy[authContext.role] || 0;
  const requiredRoleLevel = roleHierarchy[requiredRole] || 0;
  return userRoleLevel >= requiredRoleLevel;
}
async function extractAuthContext(request, secret) {
  const authHeader = request.headers.get("Authorization");
  const token = await verifyAuthToken(authHeader, secret);
  if (!token) {
    return {
      userId: "",
      role: "viewer",
      isAuthenticated: false
    };
  }
  return {
    userId: token.sub,
    role: token.role,
    isAuthenticated: true
  };
}
function createAuthError(message2, statusCode = 401) {
  return new Response(
    JSON.stringify({
      success: false,
      error: message2,
      code: statusCode === 401 ? "UNAUTHORIZED" : "FORBIDDEN"
    }),
    {
      status: statusCode,
      headers: { "Content-Type": "application/json" }
    }
  );
}
var MessagePort4, MessageChannelPolyfill3, encoder2, decoder3, JOSEError, JWTClaimValidationFailed, JWTExpired, JOSENotSupported, JWSInvalid, JWTInvalid, JWSSignatureVerificationFailed, unusable, isAlgorithm, invalidKeyInput, withAlg, isCryptoKey, isKeyObject, isKeyLike, isObjectLike, isJWK, isPrivateJWK, isPublicJWK, isSecretJWK, cache, handleJWK, handleKeyObject, tag, jwkMatchesOp, symmetricTypeCheck, asymmetricTypeCheck, epoch, minute, hour, day, week, year, REGEX, normalizeTyp, checkAudiencePresence, JWTClaimsBuilder, FlattenedSign, CompactSign, SignJWT, AuthRoles;
var init_auth_service_GsDnjv = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/auth.service_GsDnjv--.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    encoder2 = new TextEncoder();
    decoder3 = new TextDecoder();
    __name(concat, "concat");
    __name(encode$1, "encode$1");
    __name(encodeBase642, "encodeBase64");
    __name(decodeBase642, "decodeBase64");
    __name(decode, "decode");
    __name(encode, "encode");
    JOSEError = class extends Error {
      static {
        __name(this, "JOSEError");
      }
      static code = "ERR_JOSE_GENERIC";
      code = "ERR_JOSE_GENERIC";
      constructor(message2, options) {
        super(message2, options);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static {
        __name(this, "JWTClaimValidationFailed");
      }
      static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
      code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
      claim;
      reason;
      payload;
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JWTExpired = class extends JOSEError {
      static {
        __name(this, "JWTExpired");
      }
      static code = "ERR_JWT_EXPIRED";
      code = "ERR_JWT_EXPIRED";
      claim;
      reason;
      payload;
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JOSENotSupported = class extends JOSEError {
      static {
        __name(this, "JOSENotSupported");
      }
      static code = "ERR_JOSE_NOT_SUPPORTED";
      code = "ERR_JOSE_NOT_SUPPORTED";
    };
    JWSInvalid = class extends JOSEError {
      static {
        __name(this, "JWSInvalid");
      }
      static code = "ERR_JWS_INVALID";
      code = "ERR_JWS_INVALID";
    };
    JWTInvalid = class extends JOSEError {
      static {
        __name(this, "JWTInvalid");
      }
      static code = "ERR_JWT_INVALID";
      code = "ERR_JWT_INVALID";
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      static {
        __name(this, "JWSSignatureVerificationFailed");
      }
      static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      constructor(message2 = "signature verification failed", options) {
        super(message2, options);
      }
    };
    unusable = /* @__PURE__ */ __name((name, prop = "algorithm.name") => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`), "unusable");
    isAlgorithm = /* @__PURE__ */ __name((algorithm, name) => algorithm.name === name, "isAlgorithm");
    __name(getHashLength, "getHashLength");
    __name(getNamedCurve, "getNamedCurve");
    __name(checkUsage, "checkUsage");
    __name(checkSigCryptoKey, "checkSigCryptoKey");
    __name(message, "message");
    invalidKeyInput = /* @__PURE__ */ __name((actual, ...types2) => message("Key must be ", actual, ...types2), "invalidKeyInput");
    withAlg = /* @__PURE__ */ __name((alg, actual, ...types2) => message(`Key for the ${alg} algorithm must be `, actual, ...types2), "withAlg");
    isCryptoKey = /* @__PURE__ */ __name((key) => {
      if (key?.[Symbol.toStringTag] === "CryptoKey")
        return true;
      try {
        return key instanceof CryptoKey;
      } catch {
        return false;
      }
    }, "isCryptoKey");
    isKeyObject = /* @__PURE__ */ __name((key) => key?.[Symbol.toStringTag] === "KeyObject", "isKeyObject");
    isKeyLike = /* @__PURE__ */ __name((key) => isCryptoKey(key) || isKeyObject(key), "isKeyLike");
    __name(isDisjoint, "isDisjoint");
    isObjectLike = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null, "isObjectLike");
    __name(isObject, "isObject");
    __name(checkKeyLength, "checkKeyLength");
    __name(subtleMapping, "subtleMapping");
    __name(jwkToKey, "jwkToKey");
    __name(validateCrit, "validateCrit");
    isJWK = /* @__PURE__ */ __name((key) => isObject(key) && typeof key.kty === "string", "isJWK");
    isPrivateJWK = /* @__PURE__ */ __name((key) => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string"), "isPrivateJWK");
    isPublicJWK = /* @__PURE__ */ __name((key) => key.kty !== "oct" && key.d === void 0 && key.priv === void 0, "isPublicJWK");
    isSecretJWK = /* @__PURE__ */ __name((key) => key.kty === "oct" && typeof key.k === "string", "isSecretJWK");
    handleJWK = /* @__PURE__ */ __name(async (key, jwk, alg, freeze = false) => {
      cache ||= /* @__PURE__ */ new WeakMap();
      let cached = cache.get(key);
      if (cached?.[alg]) {
        return cached[alg];
      }
      const cryptoKey = await jwkToKey({ ...jwk, alg });
      if (freeze)
        Object.freeze(key);
      if (!cached) {
        cache.set(key, { [alg]: cryptoKey });
      } else {
        cached[alg] = cryptoKey;
      }
      return cryptoKey;
    }, "handleJWK");
    handleKeyObject = /* @__PURE__ */ __name((keyObject, alg) => {
      cache ||= /* @__PURE__ */ new WeakMap();
      let cached = cache.get(keyObject);
      if (cached?.[alg]) {
        return cached[alg];
      }
      const isPublic = keyObject.type === "public";
      const extractable = isPublic ? true : false;
      let cryptoKey;
      if (keyObject.asymmetricKeyType === "x25519") {
        switch (alg) {
          case "ECDH-ES":
          case "ECDH-ES+A128KW":
          case "ECDH-ES+A192KW":
          case "ECDH-ES+A256KW":
            break;
          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
      }
      if (keyObject.asymmetricKeyType === "ed25519") {
        if (alg !== "EdDSA" && alg !== "Ed25519") {
          throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
          isPublic ? "verify" : "sign"
        ]);
      }
      switch (keyObject.asymmetricKeyType) {
        case "ml-dsa-44":
        case "ml-dsa-65":
        case "ml-dsa-87": {
          if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          }
          cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
            isPublic ? "verify" : "sign"
          ]);
        }
      }
      if (keyObject.asymmetricKeyType === "rsa") {
        let hash2;
        switch (alg) {
          case "RSA-OAEP":
            hash2 = "SHA-1";
            break;
          case "RS256":
          case "PS256":
          case "RSA-OAEP-256":
            hash2 = "SHA-256";
            break;
          case "RS384":
          case "PS384":
          case "RSA-OAEP-384":
            hash2 = "SHA-384";
            break;
          case "RS512":
          case "PS512":
          case "RSA-OAEP-512":
            hash2 = "SHA-512";
            break;
          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg.startsWith("RSA-OAEP")) {
          return keyObject.toCryptoKey({
            name: "RSA-OAEP",
            hash: hash2
          }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
        }
        cryptoKey = keyObject.toCryptoKey({
          name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
          hash: hash2
        }, extractable, [isPublic ? "verify" : "sign"]);
      }
      if (keyObject.asymmetricKeyType === "ec") {
        const nist = /* @__PURE__ */ new Map([
          ["prime256v1", "P-256"],
          ["secp384r1", "P-384"],
          ["secp521r1", "P-521"]
        ]);
        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
        if (!namedCurve) {
          throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg === "ES256" && namedCurve === "P-256") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg === "ES384" && namedCurve === "P-384") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg === "ES512" && namedCurve === "P-521") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg.startsWith("ECDH-ES")) {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDH",
            namedCurve
          }, extractable, isPublic ? [] : ["deriveBits"]);
        }
      }
      if (!cryptoKey) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      if (!cached) {
        cache.set(keyObject, { [alg]: cryptoKey });
      } else {
        cached[alg] = cryptoKey;
      }
      return cryptoKey;
    }, "handleKeyObject");
    __name(normalizeKey3, "normalizeKey");
    tag = /* @__PURE__ */ __name((key) => key?.[Symbol.toStringTag], "tag");
    jwkMatchesOp = /* @__PURE__ */ __name((alg, key, usage) => {
      if (key.use !== void 0) {
        let expected;
        switch (usage) {
          case "sign":
          case "verify":
            expected = "sig";
            break;
          case "encrypt":
          case "decrypt":
            expected = "enc";
            break;
        }
        if (key.use !== expected) {
          throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
        }
      }
      if (key.alg !== void 0 && key.alg !== alg) {
        throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg}" when present`);
      }
      if (Array.isArray(key.key_ops)) {
        let expectedKeyOp;
        switch (true) {
          case (usage === "sign" || usage === "verify"):
          case alg === "dir":
          case alg.includes("CBC-HS"):
            expectedKeyOp = usage;
            break;
          case alg.startsWith("PBES2"):
            expectedKeyOp = "deriveBits";
            break;
          case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
            if (!alg.includes("GCM") && alg.endsWith("KW")) {
              expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
            } else {
              expectedKeyOp = usage;
            }
            break;
          case (usage === "encrypt" && alg.startsWith("RSA")):
            expectedKeyOp = "wrapKey";
            break;
          case usage === "decrypt":
            expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
            break;
        }
        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
          throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
        }
      }
      return true;
    }, "jwkMatchesOp");
    symmetricTypeCheck = /* @__PURE__ */ __name((alg, key, usage) => {
      if (key instanceof Uint8Array)
        return;
      if (isJWK(key)) {
        if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
      }
      if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
      }
    }, "symmetricTypeCheck");
    asymmetricTypeCheck = /* @__PURE__ */ __name((alg, key, usage) => {
      if (isJWK(key)) {
        switch (usage) {
          case "decrypt":
          case "sign":
            if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation must be a private JWK`);
          case "encrypt":
          case "verify":
            if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation must be a public JWK`);
        }
      }
      if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
      }
      if (key.type === "secret") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (key.type === "public") {
        switch (usage) {
          case "sign":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
          case "decrypt":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
        }
      }
      if (key.type === "private") {
        switch (usage) {
          case "verify":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
          case "encrypt":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
        }
      }
    }, "asymmetricTypeCheck");
    __name(checkKeyType, "checkKeyType");
    __name(subtleAlgorithm, "subtleAlgorithm");
    __name(getSigKey, "getSigKey");
    __name(verify, "verify");
    __name(flattenedVerify, "flattenedVerify");
    __name(compactVerify, "compactVerify");
    epoch = /* @__PURE__ */ __name((date) => Math.floor(date.getTime() / 1e3), "epoch");
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    __name(secs, "secs");
    __name(validateInput2, "validateInput");
    normalizeTyp = /* @__PURE__ */ __name((value) => {
      if (value.includes("/")) {
        return value.toLowerCase();
      }
      return `application/${value.toLowerCase()}`;
    }, "normalizeTyp");
    checkAudiencePresence = /* @__PURE__ */ __name((audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    }, "checkAudiencePresence");
    __name(validateClaimsSet, "validateClaimsSet");
    JWTClaimsBuilder = class {
      static {
        __name(this, "JWTClaimsBuilder");
      }
      #payload;
      constructor(payload) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this.#payload = structuredClone(payload);
      }
      data() {
        return encoder2.encode(JSON.stringify(this.#payload));
      }
      get iss() {
        return this.#payload.iss;
      }
      set iss(value) {
        this.#payload.iss = value;
      }
      get sub() {
        return this.#payload.sub;
      }
      set sub(value) {
        this.#payload.sub = value;
      }
      get aud() {
        return this.#payload.aud;
      }
      set aud(value) {
        this.#payload.aud = value;
      }
      set jti(value) {
        this.#payload.jti = value;
      }
      set nbf(value) {
        if (typeof value === "number") {
          this.#payload.nbf = validateInput2("setNotBefore", value);
        } else if (value instanceof Date) {
          this.#payload.nbf = validateInput2("setNotBefore", epoch(value));
        } else {
          this.#payload.nbf = epoch(/* @__PURE__ */ new Date()) + secs(value);
        }
      }
      set exp(value) {
        if (typeof value === "number") {
          this.#payload.exp = validateInput2("setExpirationTime", value);
        } else if (value instanceof Date) {
          this.#payload.exp = validateInput2("setExpirationTime", epoch(value));
        } else {
          this.#payload.exp = epoch(/* @__PURE__ */ new Date()) + secs(value);
        }
      }
      set iat(value) {
        if (value === void 0) {
          this.#payload.iat = epoch(/* @__PURE__ */ new Date());
        } else if (value instanceof Date) {
          this.#payload.iat = validateInput2("setIssuedAt", epoch(value));
        } else if (typeof value === "string") {
          this.#payload.iat = validateInput2("setIssuedAt", epoch(/* @__PURE__ */ new Date()) + secs(value));
        } else {
          this.#payload.iat = validateInput2("setIssuedAt", value);
        }
      }
    };
    __name(jwtVerify, "jwtVerify");
    __name(sign, "sign");
    FlattenedSign = class {
      static {
        __name(this, "FlattenedSign");
      }
      #payload;
      #protectedHeader;
      #unprotectedHeader;
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this.#payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this.#protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.#protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.#unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.#unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this.#protectedHeader && !this.#unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this.#protectedHeader,
          ...this.#unprotectedHeader
        };
        const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, this.#protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this.#protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        checkKeyType(alg, key, "sign");
        let payloadS;
        let payloadB;
        if (b64) {
          payloadS = encode(this.#payload);
          payloadB = encode$1(payloadS);
        } else {
          payloadB = this.#payload;
          payloadS = "";
        }
        let protectedHeaderString;
        let protectedHeaderBytes;
        if (this.#protectedHeader) {
          protectedHeaderString = encode(JSON.stringify(this.#protectedHeader));
          protectedHeaderBytes = encode$1(protectedHeaderString);
        } else {
          protectedHeaderString = "";
          protectedHeaderBytes = new Uint8Array();
        }
        const data = concat(protectedHeaderBytes, encode$1("."), payloadB);
        const k = await normalizeKey3(key, alg);
        const signature = await sign(alg, k, data);
        const jws = {
          signature: encode(signature),
          payload: payloadS
        };
        if (this.#unprotectedHeader) {
          jws.header = this.#unprotectedHeader;
        }
        if (this.#protectedHeader) {
          jws.protected = protectedHeaderString;
        }
        return jws;
      }
    };
    CompactSign = class {
      static {
        __name(this, "CompactSign");
      }
      #flattened;
      constructor(payload) {
        this.#flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this.#flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this.#flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
    SignJWT = class {
      static {
        __name(this, "SignJWT");
      }
      #protectedHeader;
      #jwt;
      constructor(payload = {}) {
        this.#jwt = new JWTClaimsBuilder(payload);
      }
      setIssuer(issuer) {
        this.#jwt.iss = issuer;
        return this;
      }
      setSubject(subject) {
        this.#jwt.sub = subject;
        return this;
      }
      setAudience(audience) {
        this.#jwt.aud = audience;
        return this;
      }
      setJti(jwtId) {
        this.#jwt.jti = jwtId;
        return this;
      }
      setNotBefore(input) {
        this.#jwt.nbf = input;
        return this;
      }
      setExpirationTime(input) {
        this.#jwt.exp = input;
        return this;
      }
      setIssuedAt(input) {
        this.#jwt.iat = input;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this.#protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        const sig = new CompactSign(this.#jwt.data());
        sig.setProtectedHeader(this.#protectedHeader);
        if (Array.isArray(this.#protectedHeader?.crit) && this.#protectedHeader.crit.includes("b64") && this.#protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
    AuthRoles = {
      ADMIN: "admin",
      EDITOR: "editor",
      VIEWER: "viewer"
    };
    __name(generateJWT, "generateJWT");
    __name(verifyAuthToken, "verifyAuthToken");
    __name(hasRole, "hasRole");
    __name(extractAuthContext, "extractAuthContext");
    __name(createAuthError, "createAuthError");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/helpers_NuS9JhFo.mjs
function transformArticleRequestBody(body) {
  const transformed = { ...body };
  const jsonFields = [
    "imagesJson",
    "contentJson",
    "recipeJson",
    "roundupJson",
    "faqsJson",
    "seoJson",
    "configJson",
    "jsonldJson",
    "relatedArticlesJson",
    "cachedTagsJson",
    "cachedCategoryJson",
    "cachedAuthorJson",
    "cachedEquipmentJson",
    "cachedRecipeJson",
    "cachedCardJson"
  ];
  for (const field of jsonFields) {
    if (body[field] !== void 0) {
      transformed[field] = safeParseJson(body[field]);
    }
  }
  if (!body.imagesJson) {
    const images = {};
    if (body.imageUrl) {
      images.thumbnail = {
        url: body.imageUrl,
        alt: body.imageAlt || "",
        width: body.imageWidth,
        height: body.imageHeight
      };
    }
    if (body.coverUrl) {
      images.cover = {
        url: body.coverUrl,
        alt: body.coverAlt || "",
        width: body.coverWidth,
        height: body.coverHeight
      };
    }
    if (Object.keys(images).length > 0) {
      transformed.imagesJson = images;
    }
  }
  delete transformed.imageUrl;
  delete transformed.imageAlt;
  delete transformed.imageWidth;
  delete transformed.imageHeight;
  delete transformed.coverUrl;
  delete transformed.coverAlt;
  delete transformed.coverWidth;
  delete transformed.coverHeight;
  return transformed;
}
var MessagePort4, MessageChannelPolyfill3;
var init_helpers_NuS9JhFo = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/helpers_NuS9JhFo.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hydration_PCOoIFzn();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(transformArticleRequestBody, "transformArticleRequestBody");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/admin/articles/_id_.astro.mjs
var id_astro_exports = {};
__export(id_astro_exports, {
  page: () => page4,
  renderers: () => renderers
});
function parseArticleId(idParam) {
  if (!idParam) return null;
  const id = parseInt(idParam, 10);
  if (isNaN(id) || id <= 0) return null;
  return id;
}
var MessagePort4, MessageChannelPolyfill3, prerender3, GET2, PUT, DELETE, PATCH, _page4, page4;
var init_id_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/admin/articles/_id_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_helpers_NuS9JhFo();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender3 = false;
    __name(parseArticleId, "parseArticleId");
    GET2 = /* @__PURE__ */ __name(async ({ params, locals }) => {
      const id = parseArticleId(params.id);
      if (!id) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Valid numeric ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const article = await getArticleById(env3.DB, id);
        if (!article) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse(article);
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching article by ID:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch article", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const id = parseArticleId(params.id);
      if (!id) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Valid numeric ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const requestBody = await request.json();
        const transformedData = transformArticleRequestBody(requestBody);
        const success = await updateArticleById(env3.DB, id, transformedData);
        if (!success) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        await syncCachedFields(env3.DB, id);
        const updatedArticle = await getArticleById(env3.DB, id);
        const { body, status, headers } = formatSuccessResponse(updatedArticle);
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error updating article:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update article", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const id = parseArticleId(params.id);
      if (!id) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Valid numeric ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const success = await deleteArticleById(env3.DB, id);
        if (!success) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found or already deleted", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({ deleted: true, id });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting article:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete article", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    PATCH = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const id = parseArticleId(params.id);
      const url = new URL(request.url);
      const action = url.searchParams.get("action");
      if (!id) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Valid numeric ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      if (!action || !["toggle-online", "toggle-favorite"].includes(action)) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Valid action query param required: toggle-online or toggle-favorite", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        let result = null;
        if (action === "toggle-online") {
          result = await toggleOnlineById(env3.DB, id);
        } else if (action === "toggle-favorite") {
          result = await toggleFavoriteById(env3.DB, id);
        }
        if (!result) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        if (action === "toggle-online") {
          await syncCachedFields(env3.DB, id);
        }
        const { body, status, headers } = formatSuccessResponse({ id, ...result });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error toggling article status:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to toggle article status", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PATCH");
    _page4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE,
      GET: GET2,
      PATCH,
      PUT,
      prerender: prerender3
    }, Symbol.toStringTag, { value: "Module" }));
    page4 = /* @__PURE__ */ __name(() => _page4, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/articles/_slug_.astro.mjs
var slug_astro_exports = {};
__export(slug_astro_exports, {
  page: () => page5,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender4, GET3, _page5, page5;
var init_slug_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/articles/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender4 = false;
    GET3 = /* @__PURE__ */ __name(async ({ params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const article = await getArticleBySlug(db, slug);
        if (!article) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse(article, {
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching article:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch article",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET3,
      prerender: prerender4
    }, Symbol.toStringTag, { value: "Module" }));
    page5 = /* @__PURE__ */ __name(() => _page5, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/articles.astro.mjs
var articles_astro_exports = {};
__export(articles_astro_exports, {
  page: () => page6,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender5, GET4, POST, PUT2, _page6, page6;
var init_articles_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/articles.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_helpers_NuS9JhFo();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender5 = false;
    GET4 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      const url = new URL(request.url);
      const slug = url.searchParams.get("slug");
      const category = url.searchParams.get("category");
      const author = url.searchParams.get("author");
      const tag2 = url.searchParams.get("tag");
      const type = url.searchParams.get("type");
      const statusFilter = url.searchParams.get("status");
      const search = url.searchParams.get("search");
      const paginationValidation = validatePaginationParams(
        url.searchParams.get("limit"),
        url.searchParams.get("page")
      );
      const { limit, page: page62, offset } = paginationValidation;
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        if (slug) {
          const article = await getArticleBySlug(db, slug, type || void 0);
          if (!article) {
            const { body: body3, status: status3, headers: headers3 } = formatErrorResponse(
              new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
            );
            return new Response(body3, { status: status3, headers: headers3 });
          }
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse(article, {
            cacheControl: "public, max-age=3600"
          });
          return new Response(body2, { status: status2, headers: headers2 });
        }
        let isOnlineFilter;
        if (statusFilter === "online") {
          isOnlineFilter = true;
        } else if (statusFilter === "offline") {
          isOnlineFilter = false;
        } else {
          isOnlineFilter = void 0;
        }
        const articles2 = await getArticles(db, {
          type: type || void 0,
          categorySlug: category || void 0,
          authorSlug: author || void 0,
          tagSlug: tag2 || void 0,
          isOnline: isOnlineFilter,
          search: search || void 0,
          limit,
          offset
        });
        const { body, status, headers } = formatSuccessResponse(articles2.items, {
          pagination: {
            page: page62,
            limit,
            total: articles2.total,
            totalPages: Math.ceil(articles2.total / limit)
          },
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching articles:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch articles",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const reqBody = await request.json();
        const transformedData = transformArticleRequestBody(reqBody);
        const article = await createArticle(env3.DB, transformedData);
        if (article?.id) {
          await syncCachedFields(env3.DB, article.id);
        }
        const { body, status, headers } = formatSuccessResponse(article);
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating article:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create article", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    PUT2 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Method not allowed - use /api/articles/:slug for updates", 405)
        );
        return new Response(body, { status, headers });
      } catch (error5) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Internal Error", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    _page6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET4,
      POST,
      PUT: PUT2,
      prerender: prerender5
    }, Symbol.toStringTag, { value: "Module" }));
    page6 = /* @__PURE__ */ __name(() => _page6, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/auth/login.astro.mjs
var login_astro_exports = {};
__export(login_astro_exports, {
  page: () => page7,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender6, POST2, _page7, page7;
var init_login_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/auth/login.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender6 = false;
    POST2 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const body = await request.json();
        const { username, password } = body;
        const env3 = locals.runtime?.env || {};
        const adminUsername = env3.ADMIN_USERNAME || "admin@freecipies.com";
        const adminPassword = env3.ADMIN_PASSWORD || "admin123";
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        if (!adminUsername || !adminPassword || !jwtSecret) ;
        if (username !== adminUsername || password !== adminPassword) {
          return new Response(JSON.stringify({ error: "Invalid credentials" }), {
            status: 401,
            headers: { "Content-Type": "application/json" }
          });
        }
        const token = await generateJWT(
          { sub: username, role: AuthRoles.ADMIN },
          jwtSecret,
          "24h"
        );
        return new Response(JSON.stringify({
          token,
          user: {
            username,
            role: AuthRoles.ADMIN
          }
        }), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      } catch (error5) {
        console.error("Login error:", error5);
        return new Response(JSON.stringify({ error: "Invalid request" }), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
    }, "POST");
    _page7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST2,
      prerender: prerender6
    }, Symbol.toStringTag, { value: "Module" }));
    page7 = /* @__PURE__ */ __name(() => _page7, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/auth/refresh.astro.mjs
var refresh_astro_exports = {};
__export(refresh_astro_exports, {
  page: () => page8,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender7, POST3, _page8, page8;
var init_refresh_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/auth/refresh.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender7 = false;
    POST3 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env || {};
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        if (!jwtSecret) ;
        const authHeader = request.headers.get("Authorization");
        const payload = await verifyAuthToken(authHeader, jwtSecret);
        if (!payload) {
          return new Response(JSON.stringify({ error: "Invalid or expired session" }), {
            status: 401,
            headers: { "Content-Type": "application/json" }
          });
        }
        const token = await generateJWT(
          { sub: payload.sub, role: payload.role },
          jwtSecret,
          "24h"
        );
        return new Response(JSON.stringify({
          token,
          user: {
            username: payload.sub,
            role: payload.role
          }
        }), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      } catch (error5) {
        console.error("Refresh error:", error5);
        return new Response(JSON.stringify({ error: "Failed to refresh session" }), { status: 500 });
      }
    }, "POST");
    _page8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST3,
      prerender: prerender7
    }, Symbol.toStringTag, { value: "Module" }));
    page8 = /* @__PURE__ */ __name(() => _page8, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/auth/verify.astro.mjs
var verify_astro_exports = {};
__export(verify_astro_exports, {
  page: () => page9,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender8, GET5, _page9, page9;
var init_verify_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/auth/verify.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender8 = false;
    GET5 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env || {};
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        if (!jwtSecret) ;
        const authHeader = request.headers.get("Authorization");
        const token = await verifyAuthToken(authHeader, jwtSecret);
        if (!token) {
          return new Response(JSON.stringify({ valid: false }), {
            status: 401,
            headers: { "Content-Type": "application/json" }
          });
        }
        return new Response(JSON.stringify({
          valid: true,
          user: {
            username: token.sub,
            role: token.role
          }
        }), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      } catch (error5) {
        return new Response(JSON.stringify({ error: "Verification failed" }), {
          status: 400,
          headers: { "Content-Type": "application/json" }
        });
      }
    }, "GET");
    _page9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET5,
      prerender: prerender8
    }, Symbol.toStringTag, { value: "Module" }));
    page9 = /* @__PURE__ */ __name(() => _page9, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/authors.service_DDYOeshw.mjs
async function getAuthors(db, options) {
  const drizzle2 = createDb(db);
  const conditions = [isNull(authors.deletedAt)];
  if (options?.isOnline !== void 0) {
    conditions.push(eq(authors.isOnline, options.isOnline));
  }
  return await drizzle2.select().from(authors).where(and(...conditions)).orderBy(asc(authors.sortOrder), asc(authors.name));
}
async function getAuthorBySlug(db, slug) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.authors.findFirst({
    where: and(eq(authors.slug, slug), isNull(authors.deletedAt))
  }) || null;
}
async function getAuthorById(db, id) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.authors.findFirst({
    where: and(eq(authors.id, id), isNull(authors.deletedAt))
  }) || null;
}
async function createAuthor(db, author) {
  const drizzle2 = createDb(db);
  const [inserted] = await drizzle2.insert(authors).values(author).returning();
  return inserted || null;
}
async function updateAuthor(db, slug, author) {
  const drizzle2 = createDb(db);
  const updateData = {
    ...author,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await drizzle2.update(authors).set(updateData).where(eq(authors.slug, slug));
  return getAuthorBySlug(db, slug);
}
async function deleteAuthor(db, slug) {
  const drizzle2 = createDb(db);
  await drizzle2.update(authors).set({ deletedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(authors.slug, slug));
  return true;
}
async function updateAuthorById(db, id, author) {
  const drizzle2 = createDb(db);
  const updateData = {
    ...author,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await drizzle2.update(authors).set(updateData).where(eq(authors.id, id));
  return getAuthorById(db, id);
}
var MessagePort4, MessageChannelPolyfill3;
var init_authors_service_DDYOeshw = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/authors.service_DDYOeshw.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getAuthors, "getAuthors");
    __name(getAuthorBySlug, "getAuthorBySlug");
    __name(getAuthorById, "getAuthorById");
    __name(createAuthor, "createAuthor");
    __name(updateAuthor, "updateAuthor");
    __name(deleteAuthor, "deleteAuthor");
    __name(updateAuthorById, "updateAuthorById");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/index_CjdOo55e.mjs
var index_CjdOo55e_exports = {};
__export(index_CjdOo55e_exports, {
  authors: () => authors,
  createAuthor: () => createAuthor,
  deleteAuthor: () => deleteAuthor,
  getAuthorById: () => getAuthorById,
  getAuthorBySlug: () => getAuthorBySlug,
  getAuthors: () => getAuthors,
  parseBioJson: () => parseBioJson,
  parseImagesJson: () => parseImagesJson,
  parseSeoJson: () => parseSeoJson,
  transformAuthorRequestBody: () => transformAuthorRequestBody,
  transformAuthorResponse: () => transformAuthorResponse,
  updateAuthor: () => updateAuthor,
  updateAuthorById: () => updateAuthorById
});
function parseImagesJson(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      const images = typeof parsed === "object" && parsed ? parsed : {};
      const normalized = {
        avatar: normalizeImageSlot(images.avatar),
        cover: normalizeImageSlot(images.cover),
        banner: normalizeImageSlot(images.banner)
      };
      return JSON.stringify(normalized);
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    const normalized = {
      avatar: normalizeImageSlot(value.avatar),
      cover: normalizeImageSlot(value.cover),
      banner: normalizeImageSlot(value.banner)
    };
    return JSON.stringify(normalized);
  }
  return "{}";
}
function parseBioJson(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      return JSON.stringify(normalizeBioJsonObject(parsed));
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    return JSON.stringify(normalizeBioJsonObject(value));
  }
  return "{}";
}
function parseSeoJson(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      return JSON.stringify(normalizeSeoJsonObject(parsed));
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    return JSON.stringify(normalizeSeoJsonObject(value));
  }
  return "{}";
}
function transformAuthorRequestBody(body) {
  const transformed = { ...body };
  const hasLegacyImageFields = ["imageUrl", "imageAlt", "imageWidth", "imageHeight"].some((key) => Object.prototype.hasOwnProperty.call(body, key));
  if (body.imagesJson !== void 0) {
    transformed.imagesJson = parseImagesJson(body.imagesJson);
  } else if (hasLegacyImageFields) {
    const images = {};
    if (body.imageUrl) {
      images.avatar = {
        alt: body.imageAlt,
        variants: {
          original: {
            url: body.imageUrl,
            width: body.imageWidth ?? 0,
            height: body.imageHeight ?? 0
          }
        }
      };
    }
    transformed.imagesJson = JSON.stringify(images);
    delete transformed.imageUrl;
    delete transformed.imageAlt;
    delete transformed.imageWidth;
    delete transformed.imageHeight;
  }
  if (body.bioJson !== void 0) {
    transformed.bioJson = parseBioJson(body.bioJson);
  } else if (body.introduction || body.fullBio || body.socialLinks || body.headline || body.subtitle) {
    transformed.bioJson = parseBioJson({
      introduction: body.introduction,
      fullBio: body.fullBio,
      socialLinks: body.socialLinks,
      headline: body.headline,
      subtitle: body.subtitle
    });
  }
  if (body.seoJson !== void 0) {
    transformed.seoJson = parseSeoJson(body.seoJson);
  } else if (body.metaTitle || body.metaDescription || body.canonicalUrl || body.canonical) {
    transformed.seoJson = parseSeoJson({
      metaTitle: body.metaTitle,
      metaDescription: body.metaDescription,
      canonical: body.canonical,
      canonicalUrl: body.canonicalUrl
    });
  }
  return transformed;
}
function transformAuthorResponse(author) {
  if (!author) return author;
  const response = { ...author };
  if (author.imagesJson) {
    try {
      const images = JSON.parse(author.imagesJson);
      if (images.avatar) {
        const variant = getBestVariant(images.avatar.variants);
        response.imageUrl = variant?.url;
        response.imageAlt = images.avatar.alt;
        response.imageWidth = variant?.width;
        response.imageHeight = variant?.height;
      }
    } catch {
    }
  }
  if (author.seoJson) {
    try {
      const seo = JSON.parse(author.seoJson);
      if (!response.metaTitle) response.metaTitle = seo.metaTitle;
      if (!response.metaDescription) response.metaDescription = seo.metaDescription;
      if (!response.canonicalUrl && seo.canonical) response.canonicalUrl = seo.canonical;
    } catch {
    }
  }
  return response;
}
var MessagePort4, MessageChannelPolyfill3, getBestVariant, normalizeSocialLinks, normalizeBioJsonObject, normalizeSeoJsonObject, normalizeImageSlot;
var init_index_CjdOo55e = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/index_CjdOo55e.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    getBestVariant = /* @__PURE__ */ __name((variants) => {
      return variants?.lg || variants?.md || variants?.sm || variants?.original || variants?.xs;
    }, "getBestVariant");
    normalizeSocialLinks = /* @__PURE__ */ __name((value) => {
      if (!value) return void 0;
      if (Array.isArray(value)) {
        return value.filter((entry) => entry && typeof entry === "object").map((entry) => ({
          network: entry.network,
          url: entry.url,
          label: entry.label
        })).filter((entry) => entry.network && entry.url);
      }
      if (typeof value === "object") {
        return Object.entries(value).filter(([, url]) => typeof url === "string" && url.trim().length > 0).map(([network, url]) => ({ network, url: String(url).trim() }));
      }
      return void 0;
    }, "normalizeSocialLinks");
    normalizeBioJsonObject = /* @__PURE__ */ __name((value) => {
      if (!value || typeof value !== "object") return {};
      const short = value.short ?? value.introduction ?? value.headline ?? void 0;
      const long = value.long ?? value.fullBio ?? value.subtitle ?? void 0;
      const introduction = value.introduction ?? (typeof value.short === "string" ? value.short : void 0);
      const fullBio = value.fullBio ?? (typeof value.long === "string" ? value.long : void 0);
      const socials = normalizeSocialLinks(value.socials ?? value.socialLinks);
      const legacySocialLinks = value.socialLinks && typeof value.socialLinks === "object" && !Array.isArray(value.socialLinks) ? Object.fromEntries(
        Object.entries(value.socialLinks).filter(([, url]) => typeof url === "string" && url.trim().length > 0)
      ) : void 0;
      const socialLinksFromArray = !legacySocialLinks && socials ? Object.fromEntries(socials.map((entry) => [entry.network, entry.url])) : void 0;
      const normalized = {};
      if (value.headline) normalized.headline = value.headline;
      if (value.subtitle) normalized.subtitle = value.subtitle;
      if (introduction) normalized.introduction = introduction;
      if (fullBio) normalized.fullBio = fullBio;
      if (Array.isArray(value.expertise)) normalized.expertise = value.expertise;
      if (legacySocialLinks && Object.keys(legacySocialLinks).length > 0) {
        normalized.socialLinks = legacySocialLinks;
      } else if (socialLinksFromArray && Object.keys(socialLinksFromArray).length > 0) {
        normalized.socialLinks = socialLinksFromArray;
      }
      if (short) normalized.short = short;
      if (long) normalized.long = long;
      if (socials && socials.length > 0) normalized.socials = socials;
      return normalized;
    }, "normalizeBioJsonObject");
    normalizeSeoJsonObject = /* @__PURE__ */ __name((value) => {
      if (!value || typeof value !== "object") return {};
      return {
        metaTitle: value.metaTitle,
        metaDescription: value.metaDescription,
        noIndex: value.noIndex,
        canonical: value.canonical ?? value.canonicalUrl,
        ogImage: value.ogImage,
        ogTitle: value.ogTitle,
        ogDescription: value.ogDescription,
        twitterCard: value.twitterCard,
        robots: value.robots
      };
    }, "normalizeSeoJsonObject");
    normalizeImageSlot = /* @__PURE__ */ __name((slot) => {
      if (!slot || typeof slot !== "object") return slot;
      if (slot.variants && typeof slot.variants === "object") {
        return slot;
      }
      if (slot.url) {
        return {
          ...slot,
          variants: {
            original: {
              url: slot.url,
              width: slot.width ?? 0,
              height: slot.height ?? 0
            }
          }
        };
      }
      return slot;
    }, "normalizeImageSlot");
    __name(parseImagesJson, "parseImagesJson");
    __name(parseBioJson, "parseBioJson");
    __name(parseSeoJson, "parseSeoJson");
    __name(transformAuthorRequestBody, "transformAuthorRequestBody");
    __name(transformAuthorResponse, "transformAuthorResponse");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/authors/_slug_.astro.mjs
var slug_astro_exports2 = {};
__export(slug_astro_exports2, {
  page: () => page10,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender9, getAvatarUrlFromImagesJson, GET6, PUT3, DELETE2, _page10, page10;
var init_slug_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/authors/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    init_index_CjdOo55e();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender9 = false;
    getAvatarUrlFromImagesJson = /* @__PURE__ */ __name((value) => {
      if (!value) return null;
      try {
        const parsed = typeof value === "string" ? JSON.parse(value) : value;
        const avatar = parsed?.avatar;
        if (!avatar) return null;
        if (avatar.variants && typeof avatar.variants === "object") {
          const variant = avatar.variants.lg || avatar.variants.md || avatar.variants.sm || avatar.variants.original || avatar.variants.xs;
          return variant?.url || null;
        }
        return avatar.url || null;
      } catch {
        return null;
      }
    }, "getAvatarUrlFromImagesJson");
    GET6 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      console.log(`[DEBUG] GET /api/authors/[slug] called with slug: "${slug}"`);
      if (!slug) {
        console.log("[DEBUG] Slug is missing");
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug or ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        console.log("[DEBUG] Connecting to DB...");
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const isNumeric = /^\d+$/.test(slug);
        let author;
        if (isNumeric) {
          const { getAuthorById: getAuthorById2 } = await Promise.resolve().then(() => (init_index_CjdOo55e(), index_CjdOo55e_exports));
          author = await getAuthorById2(db, parseInt(slug));
        } else {
          author = await getAuthorBySlug(db, slug);
        }
        if (!author) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Author not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const responseAuthor = transformAuthorResponse(author);
        const { body, status, headers } = formatSuccessResponse(responseAuthor, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching author:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch author",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT3 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug or ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        const transformedBody = transformAuthorRequestBody(body);
        const isNumeric = /^\d+$/.test(slug);
        let author;
        let existingAuthor;
        if (isNumeric) {
          const { getAuthorById: getAuthorById2, updateAuthorById: updateAuthorById2 } = await Promise.resolve().then(() => (init_index_CjdOo55e(), index_CjdOo55e_exports));
          existingAuthor = await getAuthorById2(env3.DB, parseInt(slug));
          const oldImageUrl = getAvatarUrlFromImagesJson(existingAuthor?.imagesJson);
          const shouldCheckImage = transformedBody.imagesJson !== void 0;
          const newImageUrl = shouldCheckImage ? getAvatarUrlFromImagesJson(transformedBody.imagesJson) : null;
          if (shouldCheckImage && oldImageUrl && newImageUrl !== oldImageUrl && env3.IMAGES) {
            try {
              const keyMatch = oldImageUrl.match(/\/images\/(.+)$/);
              if (keyMatch) {
                const oldKey = keyMatch[1];
                await env3.IMAGES.delete(oldKey);
                await env3.DB.prepare("DELETE FROM media WHERE r2_key = ?").bind(oldKey).run();
              }
            } catch (deleteErr) {
              console.warn("Failed to delete old author image:", deleteErr);
            }
          }
          author = await updateAuthorById2(env3.DB, parseInt(slug), transformedBody);
        } else {
          existingAuthor = await getAuthorBySlug(env3.DB, slug);
          const oldImageUrl = getAvatarUrlFromImagesJson(existingAuthor?.imagesJson);
          const shouldCheckImage = transformedBody.imagesJson !== void 0;
          const newImageUrl = shouldCheckImage ? getAvatarUrlFromImagesJson(transformedBody.imagesJson) : null;
          if (shouldCheckImage && oldImageUrl && newImageUrl !== oldImageUrl && env3.IMAGES) {
            try {
              const keyMatch = oldImageUrl.match(/\/images\/(.+)$/);
              if (keyMatch) {
                const oldKey = keyMatch[1];
                await env3.IMAGES.delete(oldKey);
                await env3.DB.prepare("DELETE FROM media WHERE r2_key = ?").bind(oldKey).run();
              }
            } catch (deleteErr) {
              console.warn("Failed to delete old author image:", deleteErr);
            }
          }
          author = await updateAuthor(env3.DB, slug, transformedBody);
        }
        if (!author) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Author not found", 404)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        const responseAuthor = transformAuthorResponse(author);
        const { body: respBody, status, headers } = formatSuccessResponse(responseAuthor);
        return new Response(respBody, { status, headers });
      } catch (error5) {
        console.error("Error updating author:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update author", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE2 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const success = await deleteAuthor(env3.DB, slug);
        if (!success) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Author not found or failed to delete", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({ deleted: true });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting author:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete author", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE2,
      GET: GET6,
      PUT: PUT3,
      prerender: prerender9
    }, Symbol.toStringTag, { value: "Module" }));
    page10 = /* @__PURE__ */ __name(() => _page10, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/authors.astro.mjs
var authors_astro_exports = {};
__export(authors_astro_exports, {
  page: () => page11,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender10, GET7, POST4, _page11, page11;
var init_authors_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/authors.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    init_index_CjdOo55e();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender10 = false;
    GET7 = /* @__PURE__ */ __name(async ({ url, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const isOnlineParam = url.searchParams.get("isOnline");
        const options = isOnlineParam !== null ? { isOnline: isOnlineParam === "true" } : void 0;
        const authors2 = await getAuthors(env3.DB, options);
        const responseAuthors = authors2.map(transformAuthorResponse);
        const { body, status, headers } = formatSuccessResponse(responseAuthors, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching authors:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch authors", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST4 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        const transformedBody = transformAuthorRequestBody(body);
        if (!body.name || !body.slug || !body.email) {
          const { body: errBody, status, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Missing required fields: name, slug, email", 400)
          );
          return new Response(errBody, { status, headers: headers2 });
        }
        const author = await createAuthor(env3.DB, transformedBody);
        const responseAuthor = transformAuthorResponse(author);
        if (!author) {
          const { body: errBody, status, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create author", 500)
          );
          return new Response(errBody, { status, headers: headers2 });
        }
        const { body: respBody, headers } = formatSuccessResponse(responseAuthor);
        return new Response(respBody, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating author:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create author", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET7,
      POST: POST4,
      prerender: prerender10
    }, Symbol.toStringTag, { value: "Module" }));
    page11 = /* @__PURE__ */ __name(() => _page11, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/authors.astro2.mjs
var authors_astro2_exports = {};
__export(authors_astro2_exports, {
  page: () => page12,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender11, GET8, POST5, _page12, page12;
var init_authors_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/authors.astro2.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    init_index_CjdOo55e();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender11 = false;
    GET8 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const authors2 = await getAuthors(db);
        const responseAuthors = authors2.map(transformAuthorResponse);
        const { body, status, headers } = formatSuccessResponse(responseAuthors, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching authors:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch authors",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST5 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const reqBody = await request.json();
        const transformedBody = transformAuthorRequestBody(reqBody);
        const author = await createAuthor(env3.DB, transformedBody);
        const responseAuthor = transformAuthorResponse(author);
        const { body, status, headers } = formatSuccessResponse(responseAuthor);
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating author:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create author", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET8,
      POST: POST5,
      prerender: prerender11
    }, Symbol.toStringTag, { value: "Module" }));
    page12 = /* @__PURE__ */ __name(() => _page12, "page");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs
var access, copyFile, cp, open, opendir, rename, truncate, rm, rmdir, mkdir, readdir, readlink, symlink, lstat, stat, link, unlink, chmod, lchmod, lchown, chown, utimes, lutimes, realpath, mkdtemp, writeFile, appendFile, readFile, watch2, statfs, glob;
var init_promises = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    access = /* @__PURE__ */ notImplemented("fs.access");
    copyFile = /* @__PURE__ */ notImplemented("fs.copyFile");
    cp = /* @__PURE__ */ notImplemented("fs.cp");
    open = /* @__PURE__ */ notImplemented("fs.open");
    opendir = /* @__PURE__ */ notImplemented("fs.opendir");
    rename = /* @__PURE__ */ notImplemented("fs.rename");
    truncate = /* @__PURE__ */ notImplemented("fs.truncate");
    rm = /* @__PURE__ */ notImplemented("fs.rm");
    rmdir = /* @__PURE__ */ notImplemented("fs.rmdir");
    mkdir = /* @__PURE__ */ notImplemented("fs.mkdir");
    readdir = /* @__PURE__ */ notImplemented("fs.readdir");
    readlink = /* @__PURE__ */ notImplemented("fs.readlink");
    symlink = /* @__PURE__ */ notImplemented("fs.symlink");
    lstat = /* @__PURE__ */ notImplemented("fs.lstat");
    stat = /* @__PURE__ */ notImplemented("fs.stat");
    link = /* @__PURE__ */ notImplemented("fs.link");
    unlink = /* @__PURE__ */ notImplemented("fs.unlink");
    chmod = /* @__PURE__ */ notImplemented("fs.chmod");
    lchmod = /* @__PURE__ */ notImplemented("fs.lchmod");
    lchown = /* @__PURE__ */ notImplemented("fs.lchown");
    chown = /* @__PURE__ */ notImplemented("fs.chown");
    utimes = /* @__PURE__ */ notImplemented("fs.utimes");
    lutimes = /* @__PURE__ */ notImplemented("fs.lutimes");
    realpath = /* @__PURE__ */ notImplemented("fs.realpath");
    mkdtemp = /* @__PURE__ */ notImplemented("fs.mkdtemp");
    writeFile = /* @__PURE__ */ notImplemented("fs.writeFile");
    appendFile = /* @__PURE__ */ notImplemented("fs.appendFile");
    readFile = /* @__PURE__ */ notImplemented("fs.readFile");
    watch2 = /* @__PURE__ */ notImplemented("fs.watch");
    statfs = /* @__PURE__ */ notImplemented("fs.statfs");
    glob = /* @__PURE__ */ notImplemented("fs.glob");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  EXTENSIONLESS_FORMAT_JAVASCRIPT: () => EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM: () => EXTENSIONLESS_FORMAT_WASM,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_DIRENT_BLOCK: () => UV_DIRENT_BLOCK,
  UV_DIRENT_CHAR: () => UV_DIRENT_CHAR,
  UV_DIRENT_DIR: () => UV_DIRENT_DIR,
  UV_DIRENT_FIFO: () => UV_DIRENT_FIFO,
  UV_DIRENT_FILE: () => UV_DIRENT_FILE,
  UV_DIRENT_LINK: () => UV_DIRENT_LINK,
  UV_DIRENT_SOCKET: () => UV_DIRENT_SOCKET,
  UV_DIRENT_UNKNOWN: () => UV_DIRENT_UNKNOWN,
  UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  UV_FS_SYMLINK_DIR: () => UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: () => UV_FS_SYMLINK_JUNCTION,
  W_OK: () => W_OK,
  X_OK: () => X_OK
});
var UV_FS_SYMLINK_DIR, UV_FS_SYMLINK_JUNCTION, O_RDONLY, O_WRONLY, O_RDWR, UV_DIRENT_UNKNOWN, UV_DIRENT_FILE, UV_DIRENT_DIR, UV_DIRENT_LINK, UV_DIRENT_FIFO, UV_DIRENT_SOCKET, UV_DIRENT_CHAR, UV_DIRENT_BLOCK, EXTENSIONLESS_FORMAT_JAVASCRIPT, EXTENSIONLESS_FORMAT_WASM, S_IFMT, S_IFREG, S_IFDIR, S_IFCHR, S_IFBLK, S_IFIFO, S_IFLNK, S_IFSOCK, O_CREAT, O_EXCL, UV_FS_O_FILEMAP, O_NOCTTY, O_TRUNC, O_APPEND, O_DIRECTORY, O_NOATIME, O_NOFOLLOW, O_SYNC, O_DSYNC, O_DIRECT, O_NONBLOCK, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH, F_OK, R_OK, W_OK, X_OK, UV_FS_COPYFILE_EXCL, COPYFILE_EXCL, UV_FS_COPYFILE_FICLONE, COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE_FORCE, COPYFILE_FICLONE_FORCE;
var init_constants = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_FS_SYMLINK_DIR = 1;
    UV_FS_SYMLINK_JUNCTION = 2;
    O_RDONLY = 0;
    O_WRONLY = 1;
    O_RDWR = 2;
    UV_DIRENT_UNKNOWN = 0;
    UV_DIRENT_FILE = 1;
    UV_DIRENT_DIR = 2;
    UV_DIRENT_LINK = 3;
    UV_DIRENT_FIFO = 4;
    UV_DIRENT_SOCKET = 5;
    UV_DIRENT_CHAR = 6;
    UV_DIRENT_BLOCK = 7;
    EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
    EXTENSIONLESS_FORMAT_WASM = 1;
    S_IFMT = 61440;
    S_IFREG = 32768;
    S_IFDIR = 16384;
    S_IFCHR = 8192;
    S_IFBLK = 24576;
    S_IFIFO = 4096;
    S_IFLNK = 40960;
    S_IFSOCK = 49152;
    O_CREAT = 64;
    O_EXCL = 128;
    UV_FS_O_FILEMAP = 0;
    O_NOCTTY = 256;
    O_TRUNC = 512;
    O_APPEND = 1024;
    O_DIRECTORY = 65536;
    O_NOATIME = 262144;
    O_NOFOLLOW = 131072;
    O_SYNC = 1052672;
    O_DSYNC = 4096;
    O_DIRECT = 16384;
    O_NONBLOCK = 2048;
    S_IRWXU = 448;
    S_IRUSR = 256;
    S_IWUSR = 128;
    S_IXUSR = 64;
    S_IRWXG = 56;
    S_IRGRP = 32;
    S_IWGRP = 16;
    S_IXGRP = 8;
    S_IRWXO = 7;
    S_IROTH = 4;
    S_IWOTH = 2;
    S_IXOTH = 1;
    F_OK = 0;
    R_OK = 4;
    W_OK = 2;
    X_OK = 1;
    UV_FS_COPYFILE_EXCL = 1;
    COPYFILE_EXCL = 1;
    UV_FS_COPYFILE_FICLONE = 2;
    COPYFILE_FICLONE = 2;
    UV_FS_COPYFILE_FICLONE_FORCE = 4;
    COPYFILE_FICLONE_FORCE = 4;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs/promises.mjs
var promises_default;
var init_promises2 = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/fs/promises.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises();
    init_constants();
    init_promises();
    promises_default = {
      constants: constants_exports,
      access,
      appendFile,
      chmod,
      chown,
      copyFile,
      cp,
      glob,
      lchmod,
      lchown,
      link,
      lstat,
      lutimes,
      mkdir,
      mkdtemp,
      open,
      opendir,
      readFile,
      readdir,
      readlink,
      realpath,
      rename,
      rm,
      rmdir,
      stat,
      statfs,
      symlink,
      truncate,
      unlink,
      utimes,
      watch: watch2,
      writeFile
    };
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/branding/_---slug_.astro.mjs
var slug_astro_exports3 = {};
__export(slug_astro_exports3, {
  page: () => page13,
  renderers: () => renderers
});
import path from "node:path";
async function ensureLogosDir() {
  try {
    await promises_default.access(LOGOS_DIR);
  } catch {
    await promises_default.mkdir(LOGOS_DIR, { recursive: true });
  }
}
function getExtensionFromMimeType(mimeType) {
  const mimeToExt = {
    "image/svg+xml": "svg",
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/webp": "webp",
    "image/gif": "gif",
    "image/x-icon": "ico",
    "image/vnd.microsoft.icon": "ico"
  };
  return mimeToExt[mimeType] || "png";
}
var MessagePort4, MessageChannelPolyfill3, prerender12, LOGOS_DIR, VALID_LOGO_TYPES, VALID_IMAGE_TYPES, FAVICON_SIZES, GET9, POST6, PUT4, DELETE3, _page13, page13;
var init_slug_astro3 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/branding/_---slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises2();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender12 = false;
    LOGOS_DIR = path.join(process.cwd(), "public", "logos");
    __name(ensureLogosDir, "ensureLogosDir");
    __name(getExtensionFromMimeType, "getExtensionFromMimeType");
    VALID_LOGO_TYPES = ["main", "dark", "mobile"];
    VALID_IMAGE_TYPES = ["image/svg+xml", "image/png", "image/jpeg", "image/webp", "image/gif"];
    FAVICON_SIZES = [
      { name: "favicon-16x16.png", size: 16 },
      { name: "favicon-32x32.png", size: 32 },
      { name: "apple-touch-icon.png", size: 180 },
      { name: "android-chrome-192x192.png", size: 192 },
      { name: "android-chrome-512x512.png", size: 512 }
    ];
    GET9 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        await ensureLogosDir();
        const files = await promises_default.readdir(LOGOS_DIR);
        const branding = {
          logoMain: null,
          logoDark: null,
          logoMobile: null,
          favicon: null
        };
        for (const file of files) {
          if (file.startsWith("logo-main.")) {
            branding.logoMain = `/logos/${file}`;
          } else if (file.startsWith("logo-dark.")) {
            branding.logoDark = `/logos/${file}`;
          } else if (file.startsWith("logo-mobile.")) {
            branding.logoMobile = `/logos/${file}`;
          } else if (file.startsWith("favicon.") && !file.includes("-")) {
            branding.favicon = `/logos/${file}`;
          }
        }
        const faviconVariants = {};
        for (const { name } of FAVICON_SIZES) {
          if (files.includes(name)) {
            faviconVariants[name] = `/logos/${name}`;
          }
        }
        const { body, status, headers } = formatSuccessResponse({
          ...branding,
          faviconVariants
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Failed to get branding:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to get branding", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST6 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        await ensureLogosDir();
        const url = new URL(request.url);
        const pathParts = url.pathname.split("/").filter(Boolean);
        const action = pathParts[2];
        const type = pathParts[3];
        const formData = await request.formData();
        const file = formData.get("file");
        if (!file) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "No file provided", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        if (!VALID_IMAGE_TYPES.includes(file.type)) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid file type. Supported: SVG, PNG, JPG, WebP, GIF", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const extension = getExtensionFromMimeType(file.type);
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        if (action === "logo") {
          if (!type || !VALID_LOGO_TYPES.includes(type)) {
            const { body: body3, status: status3, headers: headers3 } = formatErrorResponse(
              new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid logo type. Use: main, dark, or mobile", 400)
            );
            return new Response(body3, { status: status3, headers: headers3 });
          }
          const files = await promises_default.readdir(LOGOS_DIR);
          for (const existingFile of files) {
            if (existingFile.startsWith(`logo-${type}.`)) {
              try {
                await promises_default.unlink(path.join(LOGOS_DIR, existingFile));
              } catch (e2) {
                if (e2.code !== "ENOENT") throw e2;
              }
            }
          }
          const filename = `logo-${type}.${extension}`;
          await promises_default.writeFile(path.join(LOGOS_DIR, filename), uint8Array);
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse({
            url: `/logos/${filename}`,
            type,
            filename
          });
          return new Response(body2, { status: status2, headers: headers2 });
        } else if (action === "favicon") {
          const faviconFilename = `favicon.${extension}`;
          await promises_default.writeFile(path.join(LOGOS_DIR, faviconFilename), uint8Array);
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse({
            url: `/logos/${faviconFilename}`,
            filename: faviconFilename,
            sizesToGenerate: FAVICON_SIZES
          });
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid action", 400)
        );
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Failed to upload branding asset:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to upload file", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    PUT4 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        await ensureLogosDir();
        const formData = await request.formData();
        const file = formData.get("file");
        const filename = formData.get("filename");
        if (!file || !filename) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Missing file or filename", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const validFilenames = FAVICON_SIZES.map((s2) => s2.name);
        if (!validFilenames.includes(filename)) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid favicon variant filename", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        await promises_default.writeFile(path.join(LOGOS_DIR, filename), uint8Array);
        const { body, status, headers } = formatSuccessResponse({
          url: `/logos/${filename}`,
          filename
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Failed to upload favicon variant:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to upload favicon variant", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE3 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const url = new URL(request.url);
        const pathParts = url.pathname.split("/").filter(Boolean);
        const action = pathParts[2];
        const type = pathParts[3];
        await ensureLogosDir();
        const files = await promises_default.readdir(LOGOS_DIR);
        if (action === "logo" && type && VALID_LOGO_TYPES.includes(type)) {
          for (const file of files) {
            if (file.startsWith(`logo-${type}.`)) {
              try {
                await promises_default.unlink(path.join(LOGOS_DIR, file));
              } catch (e2) {
                if (e2.code !== "ENOENT") throw e2;
              }
            }
          }
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse({
            message: `Logo ${type} deleted`
          });
          return new Response(body2, { status: status2, headers: headers2 });
        } else if (action === "favicon") {
          const faviconFiles = files.filter(
            (f) => f.startsWith("favicon") || f.startsWith("apple-touch-icon") || f.startsWith("android-chrome")
          );
          for (const file of faviconFiles) {
            try {
              await promises_default.unlink(path.join(LOGOS_DIR, file));
            } catch (e2) {
              if (e2.code !== "ENOENT") throw e2;
            }
          }
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse({
            message: "Favicon and all variants deleted"
          });
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid delete target", 400)
        );
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Failed to delete branding asset:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to delete file", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE3,
      GET: GET9,
      POST: POST6,
      PUT: PUT4,
      prerender: prerender12
    }, Symbol.toStringTag, { value: "Module" }));
    page13 = /* @__PURE__ */ __name(() => _page13, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/categories.service_BzGDlPlq.mjs
async function getCategories(db, options) {
  const drizzle2 = createDb(db);
  const conditions = [isNull(categories.deletedAt)];
  if (options?.isOnline !== void 0) {
    conditions.push(eq(categories.isOnline, options.isOnline));
  }
  if (options?.parentId !== void 0) {
    if (options.parentId === null) {
      conditions.push(isNull(categories.parentId));
    } else {
      conditions.push(eq(categories.parentId, options.parentId));
    }
  }
  return await drizzle2.select().from(categories).where(and(...conditions)).orderBy(asc(categories.sortOrder), asc(categories.label));
}
async function getCategoryBySlug(db, slug) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.categories.findFirst({
    where: and(eq(categories.slug, slug), isNull(categories.deletedAt))
  }) || null;
}
async function getCategoryById(db, id) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.categories.findFirst({
    where: and(eq(categories.id, id), isNull(categories.deletedAt))
  }) || null;
}
async function calculateDepth(db, parentId) {
  if (!parentId) return 0;
  const parent = await getCategoryById(db, parentId);
  if (!parent) return 0;
  return (parent.depth || 0) + 1;
}
async function createCategory(db, category) {
  const drizzle2 = createDb(db);
  const depth = await calculateDepth(db, category.parentId);
  const [inserted] = await drizzle2.insert(categories).values({
    ...category,
    depth
  }).returning();
  return inserted || null;
}
async function updateCategory(db, slug, category) {
  const drizzle2 = createDb(db);
  const depth = category.parentId !== void 0 ? await calculateDepth(db, category.parentId) : void 0;
  const updateData = {
    ...category,
    ...depth !== void 0 ? { depth } : {},
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await drizzle2.update(categories).set(updateData).where(eq(categories.slug, slug));
  return getCategoryBySlug(db, slug);
}
async function updateCategoryById(db, id, category) {
  const drizzle2 = createDb(db);
  const depth = category.parentId !== void 0 ? await calculateDepth(db, category.parentId) : void 0;
  const updateData = {
    ...category,
    ...depth !== void 0 ? { depth } : {},
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await drizzle2.update(categories).set(updateData).where(eq(categories.id, id));
  return getCategoryById(db, id);
}
async function deleteCategory(db, slug) {
  const drizzle2 = createDb(db);
  const result = await drizzle2.update(categories).set({ deletedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(categories.slug, slug));
  return (result.rowsAffected ?? 0) > 0;
}
async function deleteCategoryById(db, id) {
  const drizzle2 = createDb(db);
  const result = await drizzle2.update(categories).set({ deletedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(categories.id, id));
  return (result.rowsAffected ?? 0) > 0;
}
var MessagePort4, MessageChannelPolyfill3;
var init_categories_service_BzGDlPlq = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/categories.service_BzGDlPlq.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getCategories, "getCategories");
    __name(getCategoryBySlug, "getCategoryBySlug");
    __name(getCategoryById, "getCategoryById");
    __name(calculateDepth, "calculateDepth");
    __name(createCategory, "createCategory");
    __name(updateCategory, "updateCategory");
    __name(updateCategoryById, "updateCategoryById");
    __name(deleteCategory, "deleteCategory");
    __name(deleteCategoryById, "deleteCategoryById");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/helpers_Dlog4nju.mjs
function parseImagesJson2(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      const images = typeof parsed === "object" && parsed ? parsed : {};
      const normalized = {
        thumbnail: normalizeImageSlot2(images.thumbnail),
        cover: normalizeImageSlot2(images.cover)
      };
      return JSON.stringify(normalized);
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    const normalized = {
      thumbnail: normalizeImageSlot2(value.thumbnail),
      cover: normalizeImageSlot2(value.cover)
    };
    return JSON.stringify(normalized);
  }
  return "{}";
}
function parseSeoJson2(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      return JSON.stringify(normalizeSeoJsonObject2(parsed));
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    return JSON.stringify(normalizeSeoJsonObject2(value));
  }
  return "{}";
}
function parseConfigJson(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      return JSON.stringify(normalizeConfigJsonObject(parsed));
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    return JSON.stringify(normalizeConfigJsonObject(value));
  }
  return "{}";
}
function transformCategoryRequestBody(body) {
  const transformed = { ...body };
  const hasLegacyImageFields = ["imageUrl", "imageAlt", "imageWidth", "imageHeight"].some((key) => Object.prototype.hasOwnProperty.call(body, key));
  const configOverrides = {};
  if (body.numEntriesPerPage !== void 0) {
    configOverrides.postsPerPage = body.numEntriesPerPage;
    delete transformed.numEntriesPerPage;
  }
  if (body.postsPerPage !== void 0) {
    configOverrides.postsPerPage = body.postsPerPage;
    delete transformed.postsPerPage;
  }
  if (body.tldr !== void 0) {
    configOverrides.tldr = body.tldr;
    delete transformed.tldr;
  }
  if (body.showInNav !== void 0) {
    configOverrides.showInNav = body.showInNav;
    delete transformed.showInNav;
  }
  if (body.showInFooter !== void 0) {
    configOverrides.showInFooter = body.showInFooter;
    delete transformed.showInFooter;
  }
  if (body.layout !== void 0) {
    configOverrides.layout = body.layout;
    delete transformed.layout;
  }
  if (body.layoutMode !== void 0) {
    configOverrides.layout = body.layoutMode;
    delete transformed.layoutMode;
  }
  if (body.cardStyle !== void 0) {
    configOverrides.cardStyle = body.cardStyle;
    delete transformed.cardStyle;
  }
  if (body.showSidebar !== void 0) {
    configOverrides.showSidebar = body.showSidebar;
    delete transformed.showSidebar;
  }
  if (body.showFilters !== void 0) {
    configOverrides.showFilters = body.showFilters;
    delete transformed.showFilters;
  }
  if (body.showBreadcrumb !== void 0) {
    configOverrides.showBreadcrumb = body.showBreadcrumb;
    delete transformed.showBreadcrumb;
  }
  if (body.showPagination !== void 0) {
    configOverrides.showPagination = body.showPagination;
    delete transformed.showPagination;
  }
  if (body.sortBy !== void 0) {
    configOverrides.sortBy = body.sortBy;
    delete transformed.sortBy;
  }
  if (body.sortOrder !== void 0) {
    configOverrides.sortOrder = body.sortOrder;
    delete transformed.sortOrder;
  }
  if (body.headerStyle !== void 0) {
    configOverrides.headerStyle = body.headerStyle;
    delete transformed.headerStyle;
  }
  if (body.imagesJson !== void 0) {
    transformed.imagesJson = parseImagesJson2(body.imagesJson);
  } else if (hasLegacyImageFields) {
    const images = {};
    if (body.imageUrl) {
      images.thumbnail = {
        alt: body.imageAlt,
        variants: {
          original: {
            url: body.imageUrl,
            width: body.imageWidth ?? 0,
            height: body.imageHeight ?? 0
          }
        }
      };
    }
    transformed.imagesJson = JSON.stringify(images);
    delete transformed.imageUrl;
    delete transformed.imageAlt;
    delete transformed.imageWidth;
    delete transformed.imageHeight;
  }
  if (body.seoJson !== void 0) {
    transformed.seoJson = parseSeoJson2(body.seoJson);
  } else if (body.metaTitle || body.metaDescription || body.canonicalUrl || body.canonical || body.ogImage || body.ogTitle || body.ogDescription || body.twitterCard || body.robots || body.noIndex) {
    transformed.seoJson = parseSeoJson2({
      metaTitle: body.metaTitle,
      metaDescription: body.metaDescription,
      canonical: body.canonical,
      canonicalUrl: body.canonicalUrl,
      ogImage: body.ogImage,
      ogTitle: body.ogTitle,
      ogDescription: body.ogDescription,
      twitterCard: body.twitterCard,
      robots: body.robots,
      noIndex: body.noIndex
    });
  }
  if (body.configJson !== void 0 || Object.keys(configOverrides).length > 0) {
    const baseConfig = parseConfigJsonValue(body.configJson);
    transformed.configJson = parseConfigJson({ ...baseConfig, ...configOverrides });
  }
  const missing = [];
  if (!transformed.slug) missing.push("slug");
  if (!transformed.label) missing.push("label");
  if (!transformed.shortDescription) missing.push("shortDescription");
  if (missing.length) {
    const error5 = new Error(`Missing required fields: ${missing.join(", ")}`);
    error5.code = "VALIDATION_ERROR";
    throw error5;
  }
  return transformed;
}
function transformCategoryResponse(category) {
  if (!category) return category;
  const response = { ...category };
  if (!response.iconSvg && category.icon_svg) {
    response.iconSvg = category.icon_svg;
  }
  if (category.imagesJson) {
    try {
      const images = JSON.parse(category.imagesJson);
      const primarySlot = images.thumbnail ?? images.cover;
      const variant = getBestVariant2(primarySlot?.variants);
      response.imageUrl = variant?.url;
      response.imageAlt = primarySlot?.alt;
      response.imageWidth = variant?.width;
      response.imageHeight = variant?.height;
    } catch {
    }
  }
  if (category.seoJson) {
    try {
      const seo = JSON.parse(category.seoJson);
      if (!response.metaTitle) response.metaTitle = seo.metaTitle;
      if (!response.metaDescription) response.metaDescription = seo.metaDescription;
      if (!response.canonicalUrl && seo.canonical) response.canonicalUrl = seo.canonical;
      if (response.ogImage === void 0 && seo.ogImage !== void 0) response.ogImage = seo.ogImage;
      if (response.ogTitle === void 0 && seo.ogTitle !== void 0) response.ogTitle = seo.ogTitle;
      if (response.ogDescription === void 0 && seo.ogDescription !== void 0) response.ogDescription = seo.ogDescription;
      if (response.twitterCard === void 0 && seo.twitterCard !== void 0) response.twitterCard = seo.twitterCard;
      if (response.robots === void 0 && seo.robots !== void 0) response.robots = seo.robots;
      if (response.noIndex === void 0 && seo.noIndex !== void 0) response.noIndex = seo.noIndex;
    } catch {
    }
  }
  if (category.configJson) {
    try {
      const config3 = JSON.parse(category.configJson);
      const configIconSvg = config3?.iconSvg ?? config3?.icon_svg;
      if (!response.iconSvg && typeof configIconSvg === "string") {
        response.iconSvg = configIconSvg;
      }
      if (response.numEntriesPerPage === void 0 && typeof config3.postsPerPage === "number") {
        response.numEntriesPerPage = config3.postsPerPage;
      }
      if (response.tldr === void 0 && typeof config3.tldr === "string") {
        response.tldr = config3.tldr;
      }
      if (response.showInNav === void 0 && typeof config3.showInNav === "boolean") {
        response.showInNav = config3.showInNav;
      }
      if (response.showInFooter === void 0 && typeof config3.showInFooter === "boolean") {
        response.showInFooter = config3.showInFooter;
      }
      if (response.layoutMode === void 0 && typeof config3.layout === "string") {
        response.layoutMode = config3.layout;
      }
      if (response.cardStyle === void 0 && typeof config3.cardStyle === "string") {
        response.cardStyle = config3.cardStyle;
      }
      if (response.showSidebar === void 0 && typeof config3.showSidebar === "boolean") {
        response.showSidebar = config3.showSidebar;
      }
      if (response.showFilters === void 0 && typeof config3.showFilters === "boolean") {
        response.showFilters = config3.showFilters;
      }
      if (response.showBreadcrumb === void 0 && typeof config3.showBreadcrumb === "boolean") {
        response.showBreadcrumb = config3.showBreadcrumb;
      }
      if (response.showPagination === void 0 && typeof config3.showPagination === "boolean") {
        response.showPagination = config3.showPagination;
      }
      if (response.sortBy === void 0 && typeof config3.sortBy === "string") {
        response.sortBy = config3.sortBy;
      }
      if (response.sortOrder === void 0 && typeof config3.sortOrder === "string") {
        response.sortOrder = config3.sortOrder;
      }
      if (response.headerStyle === void 0 && typeof config3.headerStyle === "string") {
        response.headerStyle = config3.headerStyle;
      }
    } catch {
    }
  }
  return response;
}
var MessagePort4, MessageChannelPolyfill3, getBestVariant2, normalizeImageSlot2, normalizeSeoJsonObject2, normalizeConfigJsonObject, parseConfigJsonValue;
var init_helpers_Dlog4nju = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/helpers_Dlog4nju.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    getBestVariant2 = /* @__PURE__ */ __name((variants) => {
      return variants?.lg || variants?.md || variants?.sm || variants?.original || variants?.xs;
    }, "getBestVariant");
    normalizeImageSlot2 = /* @__PURE__ */ __name((slot) => {
      if (!slot || typeof slot !== "object") return slot;
      if (slot.variants && typeof slot.variants === "object") {
        return slot;
      }
      if (slot.url) {
        return {
          ...slot,
          variants: {
            original: {
              url: slot.url,
              width: slot.width ?? 0,
              height: slot.height ?? 0
            }
          }
        };
      }
      return slot;
    }, "normalizeImageSlot");
    normalizeSeoJsonObject2 = /* @__PURE__ */ __name((value) => {
      if (!value || typeof value !== "object") return {};
      return {
        metaTitle: value.metaTitle,
        metaDescription: value.metaDescription,
        noIndex: value.noIndex,
        canonical: value.canonical ?? value.canonicalUrl,
        ogImage: value.ogImage,
        ogTitle: value.ogTitle,
        ogDescription: value.ogDescription,
        twitterCard: value.twitterCard,
        robots: value.robots
      };
    }, "normalizeSeoJsonObject");
    normalizeConfigJsonObject = /* @__PURE__ */ __name((value) => {
      if (!value || typeof value !== "object") return {};
      const postsPerPage = value.postsPerPage ?? value.numEntriesPerPage ?? value.entriesPerPage;
      const layout = value.layout ?? value.layoutMode;
      const normalized = {};
      if (typeof postsPerPage === "number") normalized.postsPerPage = postsPerPage;
      if (typeof value.tldr === "string") normalized.tldr = value.tldr;
      if (typeof value.showInNav === "boolean") normalized.showInNav = value.showInNav;
      if (typeof value.showInFooter === "boolean") normalized.showInFooter = value.showInFooter;
      if (typeof layout === "string") normalized.layout = layout;
      if (typeof value.cardStyle === "string") normalized.cardStyle = value.cardStyle;
      if (typeof value.showSidebar === "boolean") normalized.showSidebar = value.showSidebar;
      if (typeof value.showFilters === "boolean") normalized.showFilters = value.showFilters;
      if (typeof value.showBreadcrumb === "boolean") normalized.showBreadcrumb = value.showBreadcrumb;
      if (typeof value.showPagination === "boolean") normalized.showPagination = value.showPagination;
      if (typeof value.sortBy === "string") normalized.sortBy = value.sortBy;
      if (typeof value.sortOrder === "string") normalized.sortOrder = value.sortOrder;
      if (typeof value.headerStyle === "string") normalized.headerStyle = value.headerStyle;
      return normalized;
    }, "normalizeConfigJsonObject");
    parseConfigJsonValue = /* @__PURE__ */ __name((value) => {
      if (!value) return {};
      if (typeof value === "string") {
        try {
          const parsed = JSON.parse(value);
          return typeof parsed === "object" && parsed ? parsed : {};
        } catch {
          return {};
        }
      }
      if (typeof value === "object") return value;
      return {};
    }, "parseConfigJsonValue");
    __name(parseImagesJson2, "parseImagesJson");
    __name(parseSeoJson2, "parseSeoJson");
    __name(parseConfigJson, "parseConfigJson");
    __name(transformCategoryRequestBody, "transformCategoryRequestBody");
    __name(transformCategoryResponse, "transformCategoryResponse");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/categories/_slug_.astro.mjs
var slug_astro_exports4 = {};
__export(slug_astro_exports4, {
  page: () => page14,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender13, getThumbnailUrlFromImagesJson, GET10, PUT5, DELETE4, _page14, page14;
var init_slug_astro4 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/categories/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_categories_service_BzGDlPlq();
    init_helpers_Dlog4nju();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender13 = false;
    getThumbnailUrlFromImagesJson = /* @__PURE__ */ __name((value) => {
      if (!value) return null;
      try {
        const parsed = typeof value === "string" ? JSON.parse(value) : value;
        const primarySlot = parsed?.thumbnail ?? parsed?.cover;
        if (!primarySlot) return null;
        if (primarySlot.variants && typeof primarySlot.variants === "object") {
          const variant = primarySlot.variants.lg || primarySlot.variants.md || primarySlot.variants.sm || primarySlot.variants.original || primarySlot.variants.xs;
          return variant?.url || null;
        }
        return primarySlot.url || null;
      } catch {
        return null;
      }
    }, "getThumbnailUrlFromImagesJson");
    GET10 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug or ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const isNumeric = /^\d+$/.test(slug);
        const category = isNumeric ? await getCategoryById(db, parseInt(slug, 10)) : await getCategoryBySlug(db, slug);
        if (!category) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Category not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const responseCategory = transformCategoryResponse(category);
        const { body, status, headers } = formatSuccessResponse(responseCategory, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching category:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch category",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT5 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug or ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        const transformedBody = transformCategoryRequestBody(body);
        console.log("Backend received iconSvg:", transformedBody.iconSvg ? transformedBody.iconSvg.substring(0, 50) : "NOT PRESENT");
        const isNumeric = /^\d+$/.test(slug);
        const existingCategory = isNumeric ? await getCategoryById(env3.DB, parseInt(slug, 10)) : await getCategoryBySlug(env3.DB, slug);
        const oldImageUrl = getThumbnailUrlFromImagesJson(existingCategory?.imagesJson);
        const shouldCheckImage = transformedBody.imagesJson !== void 0;
        const newImageUrl = shouldCheckImage ? getThumbnailUrlFromImagesJson(transformedBody.imagesJson) : null;
        console.log("Image update check:", {
          oldImageUrl,
          newImageUrl,
          bodyImagesJsonProvided: shouldCheckImage,
          shouldDelete: shouldCheckImage && oldImageUrl && newImageUrl !== oldImageUrl
        });
        if (shouldCheckImage && oldImageUrl && newImageUrl !== oldImageUrl) {
          try {
            const keyMatch = oldImageUrl.match(/\/images\/(.+)$/);
            if (keyMatch && env3.IMAGES) {
              const oldKey = keyMatch[1];
              console.log(`Deleting old category image with key: ${oldKey}`);
              await env3.IMAGES.delete(oldKey);
              const deleteResult = await env3.DB.prepare(
                "DELETE FROM media WHERE r2_key = ? OR url = ?"
              ).bind(oldKey, oldImageUrl).run();
              console.log(`Deleted category image. Key: ${oldKey}, Media rows affected: ${deleteResult.meta?.changes || 0}`);
            }
          } catch (deleteErr) {
            console.warn("Failed to delete old category image:", deleteErr);
          }
        }
        const category = isNumeric ? await updateCategoryById(env3.DB, parseInt(slug, 10), transformedBody) : await updateCategory(env3.DB, slug, transformedBody);
        if (!category) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Category not found", 404)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        const responseCategory = transformCategoryResponse(category);
        const { body: respBody, status, headers } = formatSuccessResponse(responseCategory);
        return new Response(respBody, { status, headers });
      } catch (error5) {
        console.error("Error updating category:", error5);
        const appErr = error5 instanceof AppError ? error5 : error5?.code === "VALIDATION_ERROR" ? new AppError(ErrorCodes.VALIDATION_ERROR, error5.message, 400) : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update category", 500);
        const { body, status, headers } = formatErrorResponse(appErr);
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE4 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug or ID is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const isNumeric = /^\d+$/.test(slug);
        const success = isNumeric ? await deleteCategoryById(env3.DB, parseInt(slug, 10)) : await deleteCategory(env3.DB, slug);
        if (!success) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Category not found or failed to delete", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({ deleted: true });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting category:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete category", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE4,
      GET: GET10,
      PUT: PUT5,
      prerender: prerender13
    }, Symbol.toStringTag, { value: "Module" }));
    page14 = /* @__PURE__ */ __name(() => _page14, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/categories.astro.mjs
var categories_astro_exports = {};
__export(categories_astro_exports, {
  page: () => page15,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender14, GET11, POST7, _page15, page15;
var init_categories_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/categories.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_categories_service_BzGDlPlq();
    init_helpers_Dlog4nju();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender14 = false;
    GET11 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const categories2 = await getCategories(db);
        const responseCategories = categories2.map(transformCategoryResponse);
        const { body, status, headers } = formatSuccessResponse(responseCategories, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching categories:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch categories",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST7 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const reqBody = await request.json();
        const transformedBody = transformCategoryRequestBody(reqBody);
        const category = await createCategory(env3.DB, transformedBody);
        const responseCategory = transformCategoryResponse(category);
        const { body, status, headers } = formatSuccessResponse(responseCategory);
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating category:", error5);
        const appErr = error5 instanceof AppError ? error5 : error5?.code === "VALIDATION_ERROR" ? new AppError(ErrorCodes.VALIDATION_ERROR, error5.message, 400) : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create category", 500);
        const { body, status, headers } = formatErrorResponse(appErr);
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET11,
      POST: POST7,
      prerender: prerender14
    }, Symbol.toStringTag, { value: "Module" }));
    page15 = /* @__PURE__ */ __name(() => _page15, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/content.astro.mjs
var content_astro_exports = {};
__export(content_astro_exports, {
  page: () => page16,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender15, GET12, _page16, page16;
var init_content_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/content.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender15 = false;
    GET12 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      const url = new URL(request.url);
      const type = url.searchParams.get("type");
      const category = url.searchParams.get("category");
      const author = url.searchParams.get("author");
      const search = url.searchParams.get("search");
      const page62 = Math.max(1, parseInt(url.searchParams.get("page") || "1"));
      const limit = Math.min(100, Math.max(1, parseInt(url.searchParams.get("limit") || "12")));
      const onlineParam = url.searchParams.get("online");
      const offset = (page62 - 1) * limit;
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const options = {
          limit,
          offset
        };
        if (type && ["article", "recipe", "roundup"].includes(type)) {
          options.type = type;
        }
        if (category) {
          options.categorySlug = category;
        }
        if (author) {
          options.authorSlug = author;
        }
        if (search && search.trim()) {
          options.search = search.trim();
        }
        if (onlineParam === "false") {
          options.isOnline = false;
        } else if (onlineParam === "true" || !onlineParam) {
          options.isOnline = true;
        }
        const result = await getArticles(db, options);
        const items = result.items.map((article) => {
          let cachedCard = null;
          if (article.cachedCardJson) {
            try {
              cachedCard = typeof article.cachedCardJson === "string" ? JSON.parse(article.cachedCardJson) : article.cachedCardJson;
            } catch {
              cachedCard = null;
            }
          }
          let thumbnail = null;
          if (article.imagesJson) {
            try {
              const images = typeof article.imagesJson === "string" ? JSON.parse(article.imagesJson) : article.imagesJson;
              thumbnail = images.thumbnail || images.cover;
            } catch {
              thumbnail = null;
            }
          }
          return {
            id: article.id,
            type: article.type,
            slug: article.slug,
            headline: article.headline,
            shortDescription: article.shortDescription,
            thumbnail,
            categoryLabel: article.categoryLabel,
            categorySlug: article.categorySlug,
            categoryColor: article.categoryColor,
            authorName: article.authorName,
            authorSlug: article.authorSlug,
            publishedAt: article.publishedAt,
            isOnline: article.isOnline,
            // Type-specific fields from cache
            ...cachedCard || {}
          };
        });
        const { body, status, headers } = formatSuccessResponse({
          items,
          pagination: {
            page: page62,
            limit,
            total: result.total,
            totalPages: Math.ceil(result.total / limit),
            hasMore: page62 * limit < result.total
          },
          filters: {
            type: type || "all",
            category: category || null,
            author: author || null,
            search: search || null
          }
        }, {
          cacheControl: "public, max-age=60"
          // Short cache for listings
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching content:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch content",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET12,
      prerender: prerender15
    }, Symbol.toStringTag, { value: "Module" }));
    page16 = /* @__PURE__ */ __name(() => _page16, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/images/_---path_.astro.mjs
var path_astro_exports2 = {};
__export(path_astro_exports2, {
  page: () => page17,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender16, GET13, _page17, page17;
var init_path_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/images/_---path_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender16 = false;
    GET13 = /* @__PURE__ */ __name(async ({ params, locals, request }) => {
      const env3 = locals.runtime?.env;
      if (!env3?.IMAGES) {
        const { body, status, headers: headers2 } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500)
        );
        return new Response(body, { status, headers: headers2 });
      }
      const pathParam = params.path;
      const key = Array.isArray(pathParam) ? pathParam.join("/") : pathParam;
      if (!key || key.includes("..")) {
        const { body, status, headers: headers2 } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid image path", 400)
        );
        return new Response(body, { status, headers: headers2 });
      }
      const ifNoneMatch = request.headers.get("If-None-Match");
      const object = await env3.IMAGES.get(key);
      if (!object) {
        const { body, status, headers: headers2 } = formatErrorResponse(
          new AppError(ErrorCodes.NOT_FOUND, "Image not found", 404)
        );
        return new Response(body, { status, headers: headers2 });
      }
      if (ifNoneMatch && ifNoneMatch === object.httpEtag) {
        return new Response(null, { status: 304 });
      }
      const headers = new Headers();
      const metadata = object.httpMetadata;
      if (metadata?.contentType) {
        headers.set("Content-Type", metadata.contentType);
      }
      if (metadata?.contentDisposition) {
        headers.set("Content-Disposition", metadata.contentDisposition);
      }
      if (metadata?.cacheControl) {
        headers.set("Cache-Control", metadata.cacheControl);
      } else {
        headers.set("Cache-Control", "public, max-age=31536000, immutable");
      }
      if (metadata?.contentEncoding) {
        headers.set("Content-Encoding", metadata.contentEncoding);
      }
      if (metadata?.contentLanguage) {
        headers.set("Content-Language", metadata.contentLanguage);
      }
      if (!headers.get("Content-Type")) {
        headers.set("Content-Type", "application/octet-stream");
      }
      if (object.httpEtag) {
        headers.set("ETag", object.httpEtag);
      }
      headers.set("Accept-Ranges", "bytes");
      return new Response(object.body, { status: 200, headers });
    }, "GET");
    _page17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET13,
      prerender: prerender16
    }, Symbol.toStringTag, { value: "Module" }));
    page17 = /* @__PURE__ */ __name(() => _page17, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/media.service_BzvilGys.mjs
async function getMedia(db, options) {
  const drizzle2 = createDb(db);
  const conditions = [isNull(media.deletedAt)];
  if (options?.folder) {
    conditions.push(eq(media.folder, options.folder));
  }
  if (options?.search) {
    const searchPattern = `%${options.search}%`;
    conditions.push(
      or(
        like(media.name, searchPattern),
        like(media.altText, searchPattern)
      )
    );
  }
  const query = drizzle2.select().from(media).where(and(...conditions)).orderBy(
    options?.order === "asc" ? asc(media.createdAt) : desc(media.createdAt)
  );
  if (options?.limit) {
    if (options?.offset) {
      return await query.limit(options.limit).offset(options.offset);
    }
    return await query.limit(options.limit);
  }
  return await query;
}
async function getMediaById(db, id) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.media.findFirst({
    where: and(eq(media.id, id), isNull(media.deletedAt))
  }) || null;
}
async function createMedia(db, data) {
  const drizzle2 = createDb(db);
  const [inserted] = await drizzle2.insert(media).values(data).returning();
  return inserted || null;
}
async function updateMedia(db, id, data) {
  const drizzle2 = createDb(db);
  const updateData = { ...data };
  updateData.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
  await drizzle2.update(media).set(updateData).where(eq(media.id, id));
  return true;
}
async function hardDeleteMedia(db, id) {
  const drizzle2 = createDb(db);
  await drizzle2.delete(media).where(eq(media.id, id));
  return true;
}
var MessagePort4, MessageChannelPolyfill3;
var init_media_service_BzvilGys = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/media.service_BzvilGys.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getMedia, "getMedia");
    __name(getMediaById, "getMediaById");
    __name(createMedia, "createMedia");
    __name(updateMedia, "updateMedia");
    __name(hardDeleteMedia, "hardDeleteMedia");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media/bulk-delete.astro.mjs
var bulk_delete_astro_exports = {};
__export(bulk_delete_astro_exports, {
  page: () => page18,
  renderers: () => renderers
});
function getAllR2Keys(variantsJson) {
  if (!variantsJson) return [];
  const keys = [];
  try {
    const data = JSON.parse(variantsJson);
    if (data.variants && typeof data.variants === "object") {
      Object.values(data.variants).forEach((variant) => {
        if (variant?.r2_key) {
          keys.push(variant.r2_key);
        }
      });
    } else {
      const simpleVariant = data.original || data.lg || data.md || data.sm || data.xs;
      if (simpleVariant?.r2_key) keys.push(simpleVariant.r2_key);
    }
  } catch {
  }
  return keys;
}
var MessagePort4, MessageChannelPolyfill3, prerender17, POST8, _page18, page18;
var init_bulk_delete_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media/bulk-delete.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender17 = false;
    __name(getAllR2Keys, "getAllR2Keys");
    POST8 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Editor role required to delete media files", 403);
        }
        let ids = [];
        try {
          const body2 = await request.json();
          if (Array.isArray(body2.ids)) {
            ids = body2.ids.map((id) => parseInt(id)).filter((id) => !isNaN(id));
          }
        } catch {
          return new Response(JSON.stringify({ error: "Invalid JSON body" }), { status: 400 });
        }
        if (ids.length === 0) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "No valid IDs provided", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const stats = {
          processed: 0,
          deleted: 0,
          failed: 0,
          errors: []
        };
        const BATCH_SIZE = 5;
        for (let i2 = 0; i2 < ids.length; i2 += BATCH_SIZE) {
          const batch = ids.slice(i2, i2 + BATCH_SIZE);
          await Promise.all(batch.map(async (id) => {
            try {
              const mediaRecord = await getMediaById(env3.DB, id);
              if (!mediaRecord) {
                stats.failed++;
                stats.errors.push(`Media ${id} not found`);
                return;
              }
              const r2Keys = getAllR2Keys(mediaRecord.variantsJson);
              await Promise.all(r2Keys.map((key) => env3.IMAGES.delete(key).catch((e2) => console.warn(`R2 delete failed for ${key}`, e2))));
              const success = await hardDeleteMedia(env3.DB, id);
              if (success) {
                stats.deleted++;
              } else {
                stats.failed++;
                stats.errors.push(`Failed to delete media ${id} from DB`);
              }
            } catch (err) {
              console.error(`Error deleting media ${id}:`, err);
              stats.failed++;
              stats.errors.push(`Error deleting ${id}: ${err.message}`);
            } finally {
              stats.processed++;
            }
          }));
        }
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          stats
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Bulk delete error:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Bulk delete failed", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST8,
      prerender: prerender17
    }, Symbol.toStringTag, { value: "Module" }));
    page18 = /* @__PURE__ */ __name(() => _page18, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media/confirm.astro.mjs
var confirm_astro_exports = {};
__export(confirm_astro_exports, {
  page: () => page19,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, POST9, _page19, page19;
var init_confirm_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media/confirm.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    POST9 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR) && !hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        if (!body.name || !body.altText || !body.variants) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, "Missing required fields: name, altText, variants", 400);
        }
        const requiredVariants = ["lg", "md", "sm", "xs"];
        for (const v of requiredVariants) {
          if (!body.variants[v]) {
            throw new AppError(ErrorCodes.VALIDATION_ERROR, `Missing required variant: ${v}`, 400);
          }
        }
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const variantsJson = {
          variants: {},
          placeholder: body.placeholder || ""
        };
        for (const [key, variant] of Object.entries(body.variants)) {
          if (variant) {
            variantsJson.variants[key] = {
              url: `${publicUrl}/${variant.r2Key}`,
              r2_key: variant.r2Key,
              width: variant.width,
              height: variant.height,
              sizeBytes: variant.sizeBytes
            };
          }
        }
        const focalPointJson = body.focalPoint ? JSON.stringify(body.focalPoint) : '{"x": 50, "y": 50}';
        const mediaData = {
          name: body.name,
          altText: body.altText,
          caption: body.caption || "",
          credit: body.credit || "",
          mimeType: body.mimeType || "image/webp",
          aspectRatio: body.aspectRatio || null,
          variantsJson: JSON.stringify(variantsJson),
          focalPointJson
        };
        const newMedia = await createMedia(env3.DB, mediaData);
        if (!newMedia) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to create media record", 500);
        }
        const { body: responseBody, status, headers } = formatSuccessResponse(newMedia);
        return new Response(responseBody, { status: 201, headers });
      } catch (error5) {
        console.error("Error confirming upload:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to confirm upload", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST9
    }, Symbol.toStringTag, { value: "Module" }));
    page19 = /* @__PURE__ */ __name(() => _page19, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media/upload-urls.astro.mjs
var upload_urls_astro_exports = {};
__export(upload_urls_astro_exports, {
  page: () => page20,
  renderers: () => renderers
});
async function hmac(key, string) {
  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    typeof key === "string" ? encoder3.encode(key) : key,
    { name: "HMAC", hash: { name: "SHA-256" } },
    false,
    ["sign"]
  );
  return crypto.subtle.sign("HMAC", cryptoKey, encoder3.encode(string));
}
async function hash(content) {
  return crypto.subtle.digest("SHA-256", typeof content === "string" ? encoder3.encode(content) : content);
}
function buf2hex(arrayBuffer) {
  const buffer = new Uint8Array(arrayBuffer);
  let out = "";
  for (let idx = 0; idx < buffer.length; idx++) {
    const n2 = buffer[idx];
    out += HEX_CHARS[n2 >>> 4 & 15];
    out += HEX_CHARS[n2 & 15];
  }
  return out;
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, (c) => "%" + c.charCodeAt(0).toString(16).toUpperCase());
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith(".on.aws")) {
    const match2 = hostname.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
    return match2 != null ? ["lambda", match2[1] || ""] : ["", ""];
  }
  if (hostname.endsWith(".r2.cloudflarestorage.com")) {
    return ["s3", "auto"];
  }
  if (hostname.endsWith(".backblazeb2.com")) {
    const match2 = hostname.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
    return match2 != null ? ["s3", match2[1] || ""] : ["", ""];
  }
  const match = hostname.replace("dualstack.", "").match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
  let service = match && match[1] || "";
  let region = match && match[2];
  if (region === "us-gov") {
    region = "us-gov-west-1";
  } else if (region === "s3" || region === "s3-accelerate") {
    region = "us-east-1";
    service = "s3";
  } else if (service === "iot") {
    if (hostname.startsWith("iot.")) {
      service = "execute-api";
    } else if (hostname.startsWith("data.jobs.iot.")) {
      service = "iot-jobs-data";
    } else {
      service = pathname === "/mqtt" ? "iotdevicegateway" : "iotdata";
    }
  } else if (service === "autoscaling") {
    const targetPrefix = (headers.get("X-Amz-Target") || "").split(".")[0];
    if (targetPrefix === "AnyScaleFrontendService") {
      service = "application-autoscaling";
    } else if (targetPrefix === "AnyScaleScalingPlannerFrontendService") {
      service = "autoscaling-plans";
    }
  } else if (region == null && service.startsWith("s3-")) {
    region = service.slice(3).replace(/^fips-|^external-1/, "");
    service = "s3";
  } else if (service.endsWith("-fips")) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
    [service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region || ""];
}
var MessagePort4, MessageChannelPolyfill3, encoder3, HOST_SERVICES, UNSIGNABLE_HEADERS, AwsClient, AwsV4Signer, HEX_CHARS, VARIANT_EXTENSIONS, GET14, _page20, page20;
var init_upload_urls_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media/upload-urls.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    encoder3 = new TextEncoder();
    HOST_SERVICES = {
      appstream2: "appstream",
      cloudhsmv2: "cloudhsm",
      email: "ses",
      marketplace: "aws-marketplace",
      mobile: "AWSMobileHubService",
      pinpoint: "mobiletargeting",
      queue: "sqs",
      "git-codecommit": "codecommit",
      "mturk-requester-sandbox": "mturk-requester",
      "personalize-runtime": "personalize"
    };
    UNSIGNABLE_HEADERS = /* @__PURE__ */ new Set([
      "authorization",
      "content-type",
      "content-length",
      "user-agent",
      "presigned-expires",
      "expect",
      "x-amzn-trace-id",
      "range",
      "connection"
    ]);
    AwsClient = class {
      static {
        __name(this, "AwsClient");
      }
      constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache: cache2, retries, initRetryMs }) {
        if (accessKeyId == null) throw new TypeError("accessKeyId is a required option");
        if (secretAccessKey == null) throw new TypeError("secretAccessKey is a required option");
        this.accessKeyId = accessKeyId;
        this.secretAccessKey = secretAccessKey;
        this.sessionToken = sessionToken;
        this.service = service;
        this.region = region;
        this.cache = cache2 || /* @__PURE__ */ new Map();
        this.retries = retries != null ? retries : 10;
        this.initRetryMs = initRetryMs || 50;
      }
      async sign(input, init) {
        if (input instanceof Request) {
          const { method, url, headers, body } = input;
          init = Object.assign({ method, url, headers }, init);
          if (init.body == null && headers.has("Content-Type")) {
            init.body = body != null && headers.has("X-Amz-Content-Sha256") ? body : await input.clone().arrayBuffer();
          }
          input = url;
        }
        const signer = new AwsV4Signer(Object.assign({ url: input.toString() }, init, this, init && init.aws));
        const signed = Object.assign({}, init, await signer.sign());
        delete signed.aws;
        try {
          return new Request(signed.url.toString(), signed);
        } catch (e2) {
          if (e2 instanceof TypeError) {
            return new Request(signed.url.toString(), Object.assign({ duplex: "half" }, signed));
          }
          throw e2;
        }
      }
      async fetch(input, init) {
        for (let i2 = 0; i2 <= this.retries; i2++) {
          const fetched = fetch(await this.sign(input, init));
          if (i2 === this.retries) {
            return fetched;
          }
          const res = await fetched;
          if (res.status < 500 && res.status !== 429) {
            return res;
          }
          await new Promise((resolve) => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i2)));
        }
        throw new Error("An unknown error occurred, ensure retries is not negative");
      }
    };
    AwsV4Signer = class {
      static {
        __name(this, "AwsV4Signer");
      }
      constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache: cache2, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
        if (url == null) throw new TypeError("url is a required option");
        if (accessKeyId == null) throw new TypeError("accessKeyId is a required option");
        if (secretAccessKey == null) throw new TypeError("secretAccessKey is a required option");
        this.method = method || (body ? "POST" : "GET");
        this.url = new URL(url);
        this.headers = new Headers(headers || {});
        this.body = body;
        this.accessKeyId = accessKeyId;
        this.secretAccessKey = secretAccessKey;
        this.sessionToken = sessionToken;
        let guessedService, guessedRegion;
        if (!service || !region) {
          [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
        }
        this.service = service || guessedService || "";
        this.region = region || guessedRegion || "us-east-1";
        this.cache = cache2 || /* @__PURE__ */ new Map();
        this.datetime = datetime || (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, "");
        this.signQuery = signQuery;
        this.appendSessionToken = appendSessionToken || this.service === "iotdevicegateway";
        this.headers.delete("Host");
        if (this.service === "s3" && !this.signQuery && !this.headers.has("X-Amz-Content-Sha256")) {
          this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
        }
        const params = this.signQuery ? this.url.searchParams : this.headers;
        params.set("X-Amz-Date", this.datetime);
        if (this.sessionToken && !this.appendSessionToken) {
          params.set("X-Amz-Security-Token", this.sessionToken);
        }
        this.signableHeaders = ["host", ...this.headers.keys()].filter((header) => allHeaders || !UNSIGNABLE_HEADERS.has(header)).sort();
        this.signedHeaders = this.signableHeaders.join(";");
        this.canonicalHeaders = this.signableHeaders.map((header) => header + ":" + (header === "host" ? this.url.host : (this.headers.get(header) || "").replace(/\s+/g, " "))).join("\n");
        this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/");
        if (this.signQuery) {
          if (this.service === "s3" && !params.has("X-Amz-Expires")) {
            params.set("X-Amz-Expires", "86400");
          }
          params.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256");
          params.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString);
          params.set("X-Amz-SignedHeaders", this.signedHeaders);
        }
        if (this.service === "s3") {
          try {
            this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "));
          } catch (e2) {
            this.encodedPath = this.url.pathname;
          }
        } else {
          this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
        }
        if (!singleEncode) {
          this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/");
        }
        this.encodedPath = encodeRfc3986(this.encodedPath);
        const seenKeys = /* @__PURE__ */ new Set();
        this.encodedSearch = [...this.url.searchParams].filter(([k]) => {
          if (!k) return false;
          if (this.service === "s3") {
            if (seenKeys.has(k)) return false;
            seenKeys.add(k);
          }
          return true;
        }).map((pair) => pair.map((p) => encodeRfc3986(encodeURIComponent(p)))).sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0).map((pair) => pair.join("=")).join("&");
      }
      async sign() {
        if (this.signQuery) {
          this.url.searchParams.set("X-Amz-Signature", await this.signature());
          if (this.sessionToken && this.appendSessionToken) {
            this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken);
          }
        } else {
          this.headers.set("Authorization", await this.authHeader());
        }
        return {
          method: this.method,
          url: this.url,
          headers: this.headers,
          body: this.body
        };
      }
      async authHeader() {
        return [
          "AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString,
          "SignedHeaders=" + this.signedHeaders,
          "Signature=" + await this.signature()
        ].join(", ");
      }
      async signature() {
        const date = this.datetime.slice(0, 8);
        const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
        let kCredentials = this.cache.get(cacheKey);
        if (!kCredentials) {
          const kDate = await hmac("AWS4" + this.secretAccessKey, date);
          const kRegion = await hmac(kDate, this.region);
          const kService = await hmac(kRegion, this.service);
          kCredentials = await hmac(kService, "aws4_request");
          this.cache.set(cacheKey, kCredentials);
        }
        return buf2hex(await hmac(kCredentials, await this.stringToSign()));
      }
      async stringToSign() {
        return [
          "AWS4-HMAC-SHA256",
          this.datetime,
          this.credentialString,
          buf2hex(await hash(await this.canonicalString()))
        ].join("\n");
      }
      async canonicalString() {
        return [
          this.method.toUpperCase(),
          this.encodedPath,
          this.encodedSearch,
          this.canonicalHeaders + "\n",
          this.signedHeaders,
          await this.hexBodyHash()
        ].join("\n");
      }
      async hexBodyHash() {
        let hashHeader = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
        if (hashHeader == null) {
          if (this.body && typeof this.body !== "string" && !("byteLength" in this.body)) {
            throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
          }
          hashHeader = buf2hex(await hash(this.body || ""));
        }
        return hashHeader;
      }
    };
    __name(hmac, "hmac");
    __name(hash, "hash");
    HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    __name(buf2hex, "buf2hex");
    __name(encodeRfc3986, "encodeRfc3986");
    __name(guessServiceRegion, "guessServiceRegion");
    VARIANT_EXTENSIONS = {
      original: "",
      // Keep original extension
      lg: "webp",
      md: "webp",
      sm: "webp",
      xs: "webp"
    };
    GET14 = /* @__PURE__ */ __name(async ({ request, locals, url }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3.R2_ACCESS_KEY_ID || !env3.R2_SECRET_ACCESS_KEY || !env3.CLOUDFLARE_ACCOUNT_ID) {
          throw new AppError(
            ErrorCodes.INTERNAL_ERROR,
            "R2 credentials not configured. Add R2_ACCESS_KEY_ID, R2_SECRET_ACCESS_KEY, and CLOUDFLARE_ACCOUNT_ID to environment.",
            500
          );
        }
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR) && !hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const baseName = url.searchParams.get("baseName");
        const variantsParam = url.searchParams.get("variants") || "lg,md,sm,xs";
        const mimeType = url.searchParams.get("mimeType") || "image/webp";
        const originalExt = url.searchParams.get("originalExt") || "jpg";
        if (!baseName) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, "baseName is required", 400);
        }
        const variants = variantsParam.split(",").filter((v) => v.trim());
        const timestamp = Date.now();
        const uploadId = `${timestamp}-${crypto.randomUUID().slice(0, 8)}`;
        const folder = "media";
        const r2 = new AwsClient({
          accessKeyId: env3.R2_ACCESS_KEY_ID,
          secretAccessKey: env3.R2_SECRET_ACCESS_KEY
        });
        const bucketName = env3.R2_BUCKET_NAME || "recipes-saas-media";
        const accountId = env3.CLOUDFLARE_ACCOUNT_ID;
        const r2Endpoint = `https://${accountId}.r2.cloudflarestorage.com`;
        const urls = {};
        for (const variant of variants) {
          const ext = variant === "original" ? originalExt : VARIANT_EXTENSIONS[variant] || "webp";
          const suffix = variant === "original" ? "" : `-${variant}`;
          const r2Key = `${folder}/${baseName}${suffix}-${uploadId}.${ext}`;
          const signedUrl = await r2.sign(
            new Request(`${r2Endpoint}/${bucketName}/${r2Key}`, {
              method: "PUT"
            }),
            {
              aws: { signQuery: true },
              expiresIn: 600
              // 10 minutes
            }
          );
          urls[variant] = {
            uploadUrl: signedUrl.url,
            r2Key
          };
        }
        const { body, status, headers } = formatSuccessResponse({
          uploadId,
          baseName,
          folder,
          urls
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error generating upload URLs:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to generate upload URLs", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET14
    }, Symbol.toStringTag, { value: "Module" }));
    page20 = /* @__PURE__ */ __name(() => _page20, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/r2.service_BByT9ix6.mjs
async function uploadImage(bucket, options, publicUrl) {
  const { file, filename, contentType, metadata, folder, contextSlug } = options;
  const timestamp = Date.now();
  let key;
  if (folder && contextSlug) {
    const cleanSlug = contextSlug.replace(/[^a-z0-9-]/gi, "-").toLowerCase();
    const ext = filename.split(".").pop() || "webp";
    key = `${folder}/${cleanSlug}-${timestamp}.${ext}`;
  } else if (folder) {
    key = `${folder}/${timestamp}-${filename}`;
  } else {
    key = `${timestamp}-${filename}`;
  }
  const arrayBuffer = await file.arrayBuffer();
  await bucket.put(key, arrayBuffer, {
    httpMetadata: {
      contentType: contentType || file.type || "image/jpeg"
    },
    customMetadata: {
      originalFilename: filename,
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString(),
      ...metadata
    }
  });
  return {
    success: true,
    key,
    url: `${publicUrl}/${key}`,
    filename,
    size: arrayBuffer.byteLength,
    contentType: contentType || file.type || "image/jpeg"
  };
}
async function getImage2(bucket, key) {
  const object = await bucket.get(key);
  return object;
}
async function deleteImage(bucket, key) {
  try {
    await bucket.delete(key);
    return true;
  } catch (error5) {
    console.error("Error deleting image:", error5);
    return false;
  }
}
var MessagePort4, MessageChannelPolyfill3;
var init_r2_service_BByT9ix6 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/r2.service_BByT9ix6.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(uploadImage, "uploadImage");
    __name(getImage2, "getImage");
    __name(deleteImage, "deleteImage");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media/upload-variant.astro.mjs
var upload_variant_astro_exports = {};
__export(upload_variant_astro_exports, {
  page: () => page21,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, POST10, _page21, page21;
var init_upload_variant_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media/upload-variant.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_pinterest_schema_eG5oHE2g();
    init_templates_schema_DMbF8Dv3();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    POST10 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.IMAGES) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500);
        }
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR) && !hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const formData = await request.formData();
        const file = formData.get("file");
        const variantName = formData.get("variantName");
        const baseName = formData.get("baseName");
        const uploadId = formData.get("uploadId");
        const width = parseInt(formData.get("width")) || 0;
        const height = parseInt(formData.get("height")) || 0;
        if (!file || !variantName || !baseName) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, "Missing required fields: file, variantName, baseName", 400);
        }
        const suffix = variantName === "original" ? "" : `-${variantName}`;
        const ext = file.name.split(".").pop() || "webp";
        const folder = "media";
        const r2Key = `${folder}/${baseName}${suffix}-${uploadId || Date.now()}.${ext}`;
        const result = await uploadImage(
          env3.IMAGES,
          {
            file,
            filename: `${baseName}${suffix}.${ext}`,
            contentType: file.type,
            folder
          },
          publicUrl
        );
        const { body, status, headers } = formatSuccessResponse({
          r2Key: result.key,
          url: result.url,
          width,
          height
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error uploading variant:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Variant upload failed", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST10
    }, Symbol.toStringTag, { value: "Module" }));
    page21 = /* @__PURE__ */ __name(() => _page21, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media/_id_.astro.mjs
var id_astro_exports2 = {};
__export(id_astro_exports2, {
  page: () => page22,
  renderers: () => renderers
});
function getAllR2Keys2(variantsJson) {
  if (!variantsJson) return [];
  const keys = [];
  try {
    const data = JSON.parse(variantsJson);
    if (data.variants && typeof data.variants === "object") {
      Object.values(data.variants).forEach((variant) => {
        if (variant?.r2_key) {
          keys.push(variant.r2_key);
        }
      });
    } else {
      const simpleVariant = data.original || data.lg || data.md || data.sm || data.xs;
      if (simpleVariant?.r2_key) keys.push(simpleVariant.r2_key);
    }
  } catch {
  }
  return keys;
}
var MessagePort4, MessageChannelPolyfill3, prerender18, PUT6, DELETE5, _page22, page22;
var init_id_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media/_id_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender18 = false;
    __name(getAllR2Keys2, "getAllR2Keys");
    PUT6 = /* @__PURE__ */ __name(async ({ request, locals, params }) => {
      const idStr = params.id;
      if (!idStr) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Media ID is required in URL path", 400)
        );
        return new Response(body, { status, headers });
      }
      const id = parseInt(idStr);
      if (isNaN(id)) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, `Invalid media ID format: '${idStr}' must be a number`, 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Editor role required to replace media files", 403);
        }
        const mediaRecord = await getMediaById(env3.DB, id);
        if (!mediaRecord) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, `Media file with ID ${id} not found`, 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        let formData;
        try {
          formData = await request.formData();
        } catch (parseError) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid form data: request body must be multipart/form-data", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const file = formData.get("file");
        if (!file) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, 'No file provided: include a "file" field in form data', 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const oldKeys = getAllR2Keys2(mediaRecord.variantsJson);
        for (const key of oldKeys) {
          try {
            await env3.IMAGES.delete(key);
          } catch (e2) {
            console.warn(`Failed to delete old variant ${key}:`, e2);
          }
        }
        const timestamp = Date.now();
        const newKey = `media/${id}/${timestamp}.webp`;
        const cacheBuster = `?v=${timestamp}`;
        const newUrl = `${env3.R2_PUBLIC_URL}/${newKey}${cacheBuster}`;
        try {
          const arrayBuffer = await file.arrayBuffer();
          await env3.IMAGES.put(newKey, arrayBuffer, {
            httpMetadata: { contentType: "image/webp" }
          });
        } catch (uploadError) {
          console.error("R2 upload failed:", uploadError);
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to upload file to storage", 500)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        try {
          const newVariants = {
            variants: {
              original: { url: newUrl.split("?")[0], r2_key: newKey, width: 0, height: 0 }
            },
            placeholder: ""
          };
          await updateMedia(env3.DB, id, {
            variantsJson: JSON.stringify(newVariants),
            name: file.name
          });
        } catch (dbError) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.DATABASE_ERROR, "Database update failed", 500)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({ success: true, id, url: newUrl });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error replacing media:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to replace media", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE5 = /* @__PURE__ */ __name(async ({ request, locals, params }) => {
      const idStr = params.id;
      if (!idStr) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Media ID is required in URL path", 400)
        );
        return new Response(body, { status, headers });
      }
      const id = parseInt(idStr);
      if (isNaN(id)) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, `Invalid media ID format: '${idStr}' must be a number`, 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Editor role required to delete media files", 403);
        }
        const mediaRecord = await getMediaById(env3.DB, id);
        if (!mediaRecord) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, `Media file with ID ${id} not found`, 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        let r2DeleteFailed = false;
        const r2Keys = getAllR2Keys2(mediaRecord.variantsJson);
        await Promise.all(r2Keys.map(async (key) => {
          try {
            await env3.IMAGES.delete(key);
          } catch (r2Error) {
            r2DeleteFailed = true;
            console.warn(`Failed to delete file from R2 (key: ${key}):`, r2Error);
          }
        }));
        try {
          const success = await hardDeleteMedia(env3.DB, id);
          if (!success) {
            const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
              new AppError(ErrorCodes.DATABASE_ERROR, `Failed to delete media record with ID ${id} from database`, 500)
            );
            return new Response(body2, { status: status2, headers: headers2 });
          }
        } catch (dbError) {
          console.error("Database delete failed:", dbError);
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.DATABASE_ERROR, `Database error while deleting media ID ${id}`, 500)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          id,
          warning: r2DeleteFailed ? "Some files could not be deleted from storage" : void 0
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting media:", error5);
        const errorMessage = error5 instanceof Error ? error5.message : "Unknown error occurred";
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, `Failed to delete media: ${errorMessage}`, 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE5,
      PUT: PUT6,
      prerender: prerender18
    }, Symbol.toStringTag, { value: "Module" }));
    page22 = /* @__PURE__ */ __name(() => _page22, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/media.astro.mjs
var media_astro_exports = {};
__export(media_astro_exports, {
  page: () => page23,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender19, GET15, _page23, page23;
var init_media_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/media.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender19 = false;
    GET15 = /* @__PURE__ */ __name(async ({ request, locals, url }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!authContext.isAuthenticated) {
          return createAuthError("Unauthorized", 401);
        }
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const type = url.searchParams.get("type") || void 0;
        const search = url.searchParams.get("search") || void 0;
        const sortBy = url.searchParams.get("sortBy") || void 0;
        const order = url.searchParams.get("order") || "desc";
        const limit = parseInt(url.searchParams.get("limit") || "100");
        const offset = parseInt(url.searchParams.get("offset") || "0");
        const mediaFiles = await getMedia(env3.DB, {
          type,
          search,
          sortBy,
          order,
          limit,
          offset
        });
        const enhancedMediaFiles = mediaFiles.map((file) => {
          let url2 = file.url || "";
          if (!url2 && file.variantsJson) {
            try {
              const parsed = typeof file.variantsJson === "string" ? JSON.parse(file.variantsJson) : file.variantsJson;
              const variants = parsed.variants || parsed;
              url2 = variants.original?.url || variants.lg?.url || variants.md?.url || variants.sm?.url || variants.public?.url || "";
            } catch (e2) {
              console.warn(`Failed to parse variantsJson for media ${file.id}`);
            }
          }
          return {
            ...file,
            url: url2
          };
        });
        const { body, status, headers } = formatSuccessResponse(enhancedMediaFiles);
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching media:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch media", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET15,
      prerender: prerender19
    }, Symbol.toStringTag, { value: "Module" }));
    page23 = /* @__PURE__ */ __name(() => _page23, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/pins.astro.mjs
var pins_astro_exports = {};
__export(pins_astro_exports, {
  page: () => page24,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender20, GET16, POST11, PUT7, DELETE6, _page24, page24;
var init_pins_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/pins.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender20 = false;
    GET16 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const url = new URL(request.url);
        const articleId = url.searchParams.get("article_id");
        if (!articleId) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "article_id is required", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const { results } = await env3.DB.prepare(`
      SELECT * FROM pinterest_pins 
      WHERE article_id = ? 
      ORDER BY is_primary DESC, sort_order ASC
    `).bind(articleId).all();
        const { body, status, headers } = formatSuccessResponse({ pins: results });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching pins:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch pins", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST11 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const body = await request.json();
        const { article_id, board_id, title: title3, description, image_url, image_alt, image_width, image_height, is_primary, sort_order } = body;
        if (!article_id || !title3 || !description || !image_url) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Missing required fields: article_id, title, description, image_url", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        if (is_primary) {
          await env3.DB.prepare(`
        UPDATE pinterest_pins SET is_primary = 0 WHERE article_id = ?
      `).bind(article_id).run();
        }
        const result = await env3.DB.prepare(`
      INSERT INTO pinterest_pins 
      (article_id, board_id, title, description, image_url, image_alt, image_width, image_height, is_primary, sort_order)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
          article_id,
          board_id || null,
          title3,
          description,
          image_url,
          image_alt || "",
          image_width || 1e3,
          image_height || 1500,
          is_primary ? 1 : 0,
          sort_order || 0
        ).run();
        const { body: respBody, status, headers } = formatSuccessResponse({
          id: result.meta.last_row_id
        });
        return new Response(respBody, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating pin:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create pin", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    PUT7 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const body = await request.json();
        const { id, board_id, title: title3, description, image_url, image_alt, image_width, image_height, is_primary, sort_order, pin_url } = body;
        if (!id) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Pin ID is required", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        const pin = await env3.DB.prepare(`SELECT article_id FROM pinterest_pins WHERE id = ?`).bind(id).first();
        if (!pin) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Pin not found", 404)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        if (is_primary) {
          await env3.DB.prepare(`
        UPDATE pinterest_pins SET is_primary = 0 WHERE article_id = ? AND id != ?
      `).bind(pin.article_id, id).run();
        }
        await env3.DB.prepare(`
      UPDATE pinterest_pins 
      SET board_id = ?, title = ?, description = ?, image_url = ?, image_alt = ?, 
          image_width = ?, image_height = ?, is_primary = ?, sort_order = ?, pin_url = ?
      WHERE id = ?
    `).bind(
          board_id || null,
          title3,
          description,
          image_url,
          image_alt,
          image_width,
          image_height,
          is_primary ? 1 : 0,
          sort_order,
          pin_url || null,
          id
        ).run();
        const { body: respBody, status, headers } = formatSuccessResponse({ updated: true });
        return new Response(respBody, { status, headers });
      } catch (error5) {
        console.error("Error updating pin:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update pin", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE6 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const url = new URL(request.url);
        const id = url.searchParams.get("id");
        if (!id) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Pin ID is required", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        await env3.DB.prepare(`DELETE FROM pinterest_pins WHERE id = ?`).bind(id).run();
        const { body, status, headers } = formatSuccessResponse({ deleted: true });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting pin:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete pin", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE6,
      GET: GET16,
      POST: POST11,
      PUT: PUT7,
      prerender: prerender20
    }, Symbol.toStringTag, { value: "Module" }));
    page24 = /* @__PURE__ */ __name(() => _page24, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/pinterest-boards.astro.mjs
var pinterest_boards_astro_exports = {};
__export(pinterest_boards_astro_exports, {
  page: () => page25,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender21, GET17, POST12, PUT8, DELETE7, _page25, page25;
var init_pinterest_boards_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/pinterest-boards.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender21 = false;
    GET17 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const url = new URL(request.url);
        const slug = url.searchParams.get("slug");
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        if (slug) {
          const board = await env3.DB.prepare(`
        SELECT * FROM pinterest_boards WHERE slug = ?
      `).bind(slug).first();
          if (!board) {
            const { body: body3, status: status3, headers: headers3 } = formatErrorResponse(
              new AppError(ErrorCodes.NOT_FOUND, "Board not found", 404)
            );
            return new Response(body3, { status: status3, headers: headers3 });
          }
          const { body: body2, status: status2, headers: headers2 } = formatSuccessResponse({ board });
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { results } = await env3.DB.prepare(`
      SELECT * FROM pinterest_boards 
      WHERE is_active = 1 
      ORDER BY name ASC
    `).all();
        const { body, status, headers } = formatSuccessResponse({ boards: results });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching boards:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch boards", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST12 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const body = await request.json();
        const { slug, name, description, board_url } = body;
        if (!slug || !name) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Missing required fields: slug, name", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        const result = await env3.DB.prepare(`
      INSERT INTO pinterest_boards (slug, name, description, board_url)
      VALUES (?, ?, ?, ?)
    `).bind(slug, name, description || "", board_url || "").run();
        const { body: respBody, status, headers } = formatSuccessResponse({
          id: result.meta.last_row_id
        });
        return new Response(respBody, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating board:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create board", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    PUT8 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const body = await request.json();
        const { id, slug, name, description, board_url, is_active } = body;
        if (!id) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Board ID is required", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        await env3.DB.prepare(`
      UPDATE pinterest_boards 
      SET slug = ?, name = ?, description = ?, board_url = ?, is_active = ?
      WHERE id = ?
    `).bind(slug, name, description, board_url, is_active ? 1 : 0, id).run();
        const { body: respBody, status, headers } = formatSuccessResponse({ updated: true });
        return new Response(respBody, { status, headers });
      } catch (error5) {
        console.error("Error updating board:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update board", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE7 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const url = new URL(request.url);
        const id = url.searchParams.get("id");
        if (!id) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Board ID is required", 400)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        await env3.DB.prepare(`DELETE FROM pinterest_boards WHERE id = ?`).bind(id).run();
        const { body, status, headers } = formatSuccessResponse({ deleted: true });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting board:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete board", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE7,
      GET: GET17,
      POST: POST12,
      PUT: PUT8,
      prerender: prerender21
    }, Symbol.toStringTag, { value: "Module" }));
    page25 = /* @__PURE__ */ __name(() => _page25, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/proxy-image.astro.mjs
var proxy_image_astro_exports = {};
__export(proxy_image_astro_exports, {
  page: () => page26,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender22, GET18, _page26, page26;
var init_proxy_image_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/proxy-image.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender22 = false;
    GET18 = /* @__PURE__ */ __name(async ({ request }) => {
      const url = new URL(request.url);
      const imageUrl = url.searchParams.get("url");
      if (!imageUrl) {
        return new Response("Missing url parameter", { status: 400 });
      }
      try {
        const response = await fetch(imageUrl, {
          headers: {
            // Mimic a browser to avoid some bot protections
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
          }
        });
        if (!response.ok) {
          return new Response(`Failed to fetch image: ${response.status} ${response.statusText}`, { status: 502 });
        }
        const body = response.body;
        const contentType = response.headers.get("content-type") || "application/octet-stream";
        return new Response(body, {
          status: 200,
          headers: {
            "Content-Type": contentType,
            "Access-Control-Allow-Origin": "*",
            // Enable CORS for local/remote usage
            "Cache-Control": "public, max-age=3600"
            // Cache for 1 hour
          }
        });
      } catch (e2) {
        return new Response(`Error proxying image: ${e2 instanceof Error ? e2.message : "Unknown error"}`, { status: 500 });
      }
    }, "GET");
    _page26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET18,
      prerender: prerender22
    }, Symbol.toStringTag, { value: "Module" }));
    page26 = /* @__PURE__ */ __name(() => _page26, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/recipes/_slug_.astro.mjs
var slug_astro_exports5 = {};
__export(slug_astro_exports5, {
  page: () => page27,
  renderers: () => renderers
});
function toSchemaOrgNutrition(nutrition) {
  return {
    "@type": "NutritionInformation",
    ...nutrition.calories !== void 0 && { calories: `${nutrition.calories} kcal` },
    ...nutrition.fatContent !== void 0 && { fatContent: `${nutrition.fatContent} g` },
    ...nutrition.saturatedFatContent !== void 0 && { saturatedFatContent: `${nutrition.saturatedFatContent} g` },
    ...nutrition.unsaturatedFatContent !== void 0 && { unsaturatedFatContent: `${nutrition.unsaturatedFatContent} g` },
    ...nutrition.transFatContent !== void 0 && { transFatContent: `${nutrition.transFatContent} g` },
    ...nutrition.carbohydrateContent !== void 0 && { carbohydrateContent: `${nutrition.carbohydrateContent} g` },
    ...nutrition.sugarContent !== void 0 && { sugarContent: `${nutrition.sugarContent} g` },
    ...nutrition.fiberContent !== void 0 && { fiberContent: `${nutrition.fiberContent} g` },
    ...nutrition.proteinContent !== void 0 && { proteinContent: `${nutrition.proteinContent} g` },
    ...nutrition.sodiumContent !== void 0 && { sodiumContent: `${nutrition.sodiumContent} mg` },
    ...nutrition.cholesterolContent !== void 0 && { cholesterolContent: `${nutrition.cholesterolContent} mg` },
    ...nutrition.servingSize && { servingSize: nutrition.servingSize }
  };
}
function minutesToIsoDuration(minutes) {
  if (minutes < 60) {
    return `PT${minutes}M`;
  }
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  if (mins === 0) {
    return `PT${hours}H`;
  }
  return `PT${hours}H${mins}M`;
}
function generateRecipeJsonLd(article, baseUrl) {
  const recipeData = typeof article.recipeJson === "string" ? JSON.parse(article.recipeJson || "{}") : article.recipeJson || {};
  const imagesData = typeof article.imagesJson === "string" ? JSON.parse(article.imagesJson || "{}") : article.imagesJson || {};
  const images = [];
  if (imagesData.cover?.variants) {
    const v = imagesData.cover.variants;
    if (v.lg?.url) images.push(v.lg.url);
    if (v.md?.url) images.push(v.md.url);
    if (v.sm?.url) images.push(v.sm.url);
  }
  const recipeIngredient = [];
  for (const group4 of recipeData.ingredients || []) {
    for (const item of group4.items || []) {
      const parts = [];
      if (item.amount) parts.push(item.amount.toString());
      if (item.unit) parts.push(item.unit);
      parts.push(item.name);
      if (item.notes) parts.push(`(${item.notes})`);
      recipeIngredient.push(parts.join(" "));
    }
  }
  const recipeInstructions = [];
  for (const section of recipeData.instructions || []) {
    if (section.section_title) {
      recipeInstructions.push({
        "@type": "HowToSection",
        name: section.section_title,
        itemListElement: (section.steps || []).map((step, idx) => ({
          "@type": "HowToStep",
          position: idx + 1,
          name: step.name || void 0,
          text: step.text,
          image: step.image || void 0
        }))
      });
    } else {
      for (const step of section.steps || []) {
        recipeInstructions.push({
          "@type": "HowToStep",
          name: step.name || void 0,
          text: step.text,
          image: step.image || void 0
        });
      }
    }
  }
  let nutrition;
  if (recipeData.nutrition && Object.keys(recipeData.nutrition).length > 0) {
    nutrition = toSchemaOrgNutrition(recipeData.nutrition);
  }
  let aggregateRating;
  if (recipeData.aggregateRating?.ratingValue) {
    aggregateRating = {
      "@type": "AggregateRating",
      ratingValue: recipeData.aggregateRating.ratingValue,
      ratingCount: recipeData.aggregateRating.ratingCount || 0
    };
  }
  let video;
  if (recipeData.video?.url) {
    video = {
      "@type": "VideoObject",
      name: recipeData.video.name,
      description: recipeData.video.description,
      thumbnailUrl: recipeData.video.thumbnailUrl,
      contentUrl: recipeData.video.url,
      duration: recipeData.video.duration
    };
  }
  return {
    "@context": "https://schema.org",
    "@type": "Recipe",
    name: article.headline,
    description: article.shortDescription,
    image: images,
    author: {
      "@type": "Person",
      name: article.authorName || article.cachedAuthorJson?.name
    },
    datePublished: article.publishedAt,
    dateModified: article.updatedAt,
    prepTime: recipeData.prepTime || (recipeData.prep ? minutesToIsoDuration(recipeData.prep) : void 0),
    cookTime: recipeData.cookTime || (recipeData.cook ? minutesToIsoDuration(recipeData.cook) : void 0),
    totalTime: recipeData.totalTime || (recipeData.total ? minutesToIsoDuration(recipeData.total) : void 0),
    recipeYield: recipeData.recipeYield || (recipeData.servings ? `${recipeData.servings} servings` : void 0),
    recipeCategory: recipeData.recipeCategory,
    recipeCuisine: recipeData.recipeCuisine,
    keywords: recipeData.keywords?.join(", "),
    recipeIngredient,
    recipeInstructions,
    nutrition,
    aggregateRating,
    video,
    suitableForDiet: recipeData.suitableForDiet?.map((d) => `https://schema.org/${d}`)
  };
}
var MessagePort4, MessageChannelPolyfill3, prerender23, GET19, _page27, page27;
var init_slug_astro5 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/recipes/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(toSchemaOrgNutrition, "toSchemaOrgNutrition");
    __name(minutesToIsoDuration, "minutesToIsoDuration");
    prerender23 = false;
    __name(generateRecipeJsonLd, "generateRecipeJsonLd");
    GET19 = /* @__PURE__ */ __name(async ({ params, locals, url }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const article = await getArticleBySlug(db, slug, "recipe");
        if (!article) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Recipe not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const baseUrl = `${url.protocol}//${url.host}`;
        const jsonLd = generateRecipeJsonLd(article, baseUrl);
        const responseData = {
          ...article,
          jsonLd
        };
        const { body, status, headers } = formatSuccessResponse(responseData, {
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching recipe:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch recipe",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET19,
      prerender: prerender23
    }, Symbol.toStringTag, { value: "Module" }));
    page27 = /* @__PURE__ */ __name(() => _page27, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/recipes.astro.mjs
var recipes_astro_exports = {};
__export(recipes_astro_exports, {
  page: () => page28,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender24, GET20, _page28, page28;
var init_recipes_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/recipes.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender24 = false;
    GET20 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      const url = new URL(request.url);
      const category = url.searchParams.get("category");
      const author = url.searchParams.get("author");
      const search = url.searchParams.get("search");
      const page62 = Math.max(1, parseInt(url.searchParams.get("page") || "1"));
      const limit = Math.min(100, Math.max(1, parseInt(url.searchParams.get("limit") || "12")));
      const offset = (page62 - 1) * limit;
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const options = {
          type: "recipe",
          isOnline: true,
          limit,
          offset
        };
        if (category) options.categorySlug = category;
        if (author) options.authorSlug = author;
        if (search?.trim()) options.search = search.trim();
        const result = await getArticles(db, options);
        const items = result.items.map((article) => {
          let recipeData = {};
          if (article.recipeJson) {
            try {
              recipeData = typeof article.recipeJson === "string" ? JSON.parse(article.recipeJson) : article.recipeJson;
            } catch {
              recipeData = {};
            }
          }
          let thumbnail = null;
          if (article.imagesJson) {
            try {
              const images = typeof article.imagesJson === "string" ? JSON.parse(article.imagesJson) : article.imagesJson;
              thumbnail = images.thumbnail || images.cover;
            } catch {
              thumbnail = null;
            }
          }
          return {
            id: article.id,
            slug: article.slug,
            headline: article.headline,
            shortDescription: article.shortDescription,
            thumbnail,
            categoryLabel: article.categoryLabel,
            categorySlug: article.categorySlug,
            categoryColor: article.categoryColor,
            authorName: article.authorName,
            authorSlug: article.authorSlug,
            publishedAt: article.publishedAt,
            // Recipe-specific fields
            totalTime: recipeData.total,
            prepTime: recipeData.prep,
            cookTime: recipeData.cook,
            difficulty: recipeData.difficulty,
            servings: recipeData.servings,
            rating: recipeData.aggregateRating
          };
        });
        const { body, status, headers } = formatSuccessResponse({
          items,
          pagination: {
            page: page62,
            limit,
            total: result.total,
            totalPages: Math.ceil(result.total / limit),
            hasMore: page62 * limit < result.total
          }
        }, {
          cacheControl: "public, max-age=300"
          // 5 min cache for listings
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching recipes:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch recipes",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page28 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET20,
      prerender: prerender24
    }, Symbol.toStringTag, { value: "Module" }));
    page28 = /* @__PURE__ */ __name(() => _page28, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/recipes.astro2.mjs
var recipes_astro2_exports = {};
__export(recipes_astro2_exports, {
  page: () => page29,
  renderers: () => renderers
});
function generateCacheControl(config3) {
  const directives = [];
  if (config3.public) directives.push("public");
  if (config3.private) directives.push("private");
  directives.push(`max-age=${config3.maxAge}`);
  if (config3.sMaxAge !== void 0) {
    directives.push(`s-maxage=${config3.sMaxAge}`);
  }
  if (config3.staleWhileRevalidate !== void 0) {
    directives.push(`stale-while-revalidate=${config3.staleWhileRevalidate}`);
  }
  if (config3.staleIfError !== void 0) {
    directives.push(`stale-if-error=${config3.staleIfError}`);
  }
  return directives.join(", ");
}
function getCacheHeaders(strategy) {
  return {
    "Cache-Control": generateCacheControl(strategy)
  };
}
var MessagePort4, MessageChannelPolyfill3, CACHE_STRATEGIES, prerender25, GET21, _page29, page29;
var init_recipes_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/recipes.astro2.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    CACHE_STRATEGIES = {
      // Static assets - cache forever
      STATIC: {
        maxAge: 31536e3,
        // 1 year
        public: true
      },
      // API responses - moderate caching
      API_DEFAULT: {
        maxAge: 3600,
        // 1 hour
        sMaxAge: 3600,
        staleWhileRevalidate: 86400,
        // 1 day
        public: true
      },
      // Frequently accessed data
      API_FREQUENT: {
        maxAge: 300,
        // 5 minutes
        sMaxAge: 300,
        staleWhileRevalidate: 3600,
        // 1 hour
        public: true
      },
      // User-specific data
      API_PRIVATE: {
        maxAge: 60,
        // 1 minute
        private: true,
        staleWhileRevalidate: 300
        // 5 minutes
      },
      // No cache
      NO_CACHE: {
        maxAge: 0,
        private: true
      }
    };
    __name(generateCacheControl, "generateCacheControl");
    __name(getCacheHeaders, "getCacheHeaders");
    prerender25 = false;
    GET21 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      const url = new URL(request.url);
      const slug = url.searchParams.get("slug");
      const category = url.searchParams.get("category");
      const author = url.searchParams.get("author");
      const limit = parseInt(url.searchParams.get("limit") || "12");
      const page62 = parseInt(url.searchParams.get("page") || "1");
      const offset = (page62 - 1) * limit;
      try {
        const env3 = locals.runtime.env;
        const db = env3.DB;
        if (slug) {
          const recipe = await getArticleBySlug(db, slug, "recipe");
          if (!recipe) {
            return new Response(JSON.stringify({
              success: false,
              error: "Recipe not found"
            }), {
              status: 404,
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
          return new Response(
            JSON.stringify({
              success: true,
              data: recipe
            }),
            {
              status: 200,
              headers: {
                "Content-Type": "application/json",
                ...getCacheHeaders(CACHE_STRATEGIES.API_DEFAULT)
              }
            }
          );
        }
        const recipes = await getArticles(db, {
          type: "recipe",
          categorySlug: category || void 0,
          authorSlug: author || void 0,
          limit,
          offset
        });
        return new Response(
          JSON.stringify({
            success: true,
            data: recipes.items,
            pagination: {
              page: page62,
              limit,
              total: recipes.total,
              totalPages: Math.ceil(recipes.total / limit)
            }
          }),
          {
            status: 200,
            headers: {
              "Content-Type": "application/json",
              ...getCacheHeaders(CACHE_STRATEGIES.API_DEFAULT)
            }
          }
        );
      } catch (error5) {
        console.error("Error fetching recipes:", error5);
        return new Response(JSON.stringify({
          success: false,
          error: "Failed to fetch recipes",
          message: error5 instanceof Error ? error5.message : "Unknown error"
        }), {
          status: 500,
          headers: {
            "Content-Type": "application/json"
          }
        });
      }
    }, "GET");
    _page29 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET21,
      prerender: prerender25
    }, Symbol.toStringTag, { value: "Module" }));
    page29 = /* @__PURE__ */ __name(() => _page29, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/roundups/_slug_.astro.mjs
var slug_astro_exports6 = {};
__export(slug_astro_exports6, {
  page: () => page30,
  renderers: () => renderers
});
function generateItemListJsonLd(article, baseUrl) {
  const roundupData = typeof article.roundupJson === "string" ? JSON.parse(article.roundupJson || '{"items":[],"listType":"ItemList"}') : article.roundupJson || { items: [] };
  const imagesData = typeof article.imagesJson === "string" ? JSON.parse(article.imagesJson || "{}") : article.imagesJson || {};
  const mainImage = imagesData.cover?.variants?.lg?.url || imagesData.cover?.variants?.md?.url;
  const itemListElement = (roundupData.items || []).map((item) => {
    const itemImage = item.cover?.variants?.lg?.url || item.cover?.variants?.md?.url;
    let itemUrl;
    if (item.article_id) {
      itemUrl = `${baseUrl}/recipes/${item.article_id}`;
    } else if (item.external_url) {
      itemUrl = item.external_url;
    }
    return {
      "@type": "ListItem",
      position: item.position,
      name: item.title,
      description: item.subtitle,
      url: itemUrl,
      image: itemImage
    };
  });
  return {
    "@context": "https://schema.org",
    "@type": "ItemList",
    name: article.headline,
    description: article.shortDescription,
    image: mainImage,
    numberOfItems: roundupData.items?.length || 0,
    itemListElement,
    author: {
      "@type": "Person",
      name: article.authorName || article.cachedAuthorJson?.name
    },
    datePublished: article.publishedAt,
    dateModified: article.updatedAt
  };
}
var MessagePort4, MessageChannelPolyfill3, prerender26, GET22, _page30, page30;
var init_slug_astro6 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/roundups/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender26 = false;
    __name(generateItemListJsonLd, "generateItemListJsonLd");
    GET22 = /* @__PURE__ */ __name(async ({ params, locals, url }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const article = await getArticleBySlug(db, slug, "roundup");
        if (!article) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Roundup not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const baseUrl = `${url.protocol}//${url.host}`;
        const jsonLd = generateItemListJsonLd(article, baseUrl);
        const responseData = {
          ...article,
          jsonLd
        };
        const { body, status, headers } = formatSuccessResponse(responseData, {
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching roundup:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch roundup",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page30 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET22,
      prerender: prerender26
    }, Symbol.toStringTag, { value: "Module" }));
    page30 = /* @__PURE__ */ __name(() => _page30, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/roundups.astro.mjs
var roundups_astro_exports = {};
__export(roundups_astro_exports, {
  page: () => page31,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender27, GET23, _page31, page31;
var init_roundups_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/roundups.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender27 = false;
    GET23 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      const url = new URL(request.url);
      const category = url.searchParams.get("category");
      const author = url.searchParams.get("author");
      const search = url.searchParams.get("search");
      const page62 = Math.max(1, parseInt(url.searchParams.get("page") || "1"));
      const limit = Math.min(100, Math.max(1, parseInt(url.searchParams.get("limit") || "12")));
      const offset = (page62 - 1) * limit;
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const options = {
          type: "roundup",
          isOnline: true,
          limit,
          offset
        };
        if (category) options.categorySlug = category;
        if (author) options.authorSlug = author;
        if (search?.trim()) options.search = search.trim();
        const result = await getArticles(db, options);
        const items = result.items.map((article) => {
          let itemCount = 0;
          if (article.roundupJson) {
            try {
              const roundupData = typeof article.roundupJson === "string" ? JSON.parse(article.roundupJson) : article.roundupJson;
              itemCount = roundupData.items?.length || 0;
            } catch {
              itemCount = 0;
            }
          }
          let thumbnail = null;
          if (article.imagesJson) {
            try {
              const images = typeof article.imagesJson === "string" ? JSON.parse(article.imagesJson) : article.imagesJson;
              thumbnail = images.thumbnail || images.cover;
            } catch {
              thumbnail = null;
            }
          }
          return {
            id: article.id,
            slug: article.slug,
            headline: article.headline,
            shortDescription: article.shortDescription,
            thumbnail,
            categoryLabel: article.categoryLabel,
            categorySlug: article.categorySlug,
            categoryColor: article.categoryColor,
            authorName: article.authorName,
            authorSlug: article.authorSlug,
            publishedAt: article.publishedAt,
            // Roundup-specific
            itemCount
          };
        });
        const { body, status, headers } = formatSuccessResponse({
          items,
          pagination: {
            page: page62,
            limit,
            total: result.total,
            totalPages: Math.ceil(result.total / limit),
            hasMore: page62 * limit < result.total
          }
        }, {
          cacheControl: "public, max-age=300"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching roundups:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch roundups",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page31 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET23,
      prerender: prerender27
    }, Symbol.toStringTag, { value: "Module" }));
    page31 = /* @__PURE__ */ __name(() => _page31, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/seed-images.astro.mjs
var seed_images_astro_exports = {};
__export(seed_images_astro_exports, {
  page: () => page32,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, SEED_IMAGES, POST13, _page32, page32;
var init_seed_images_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/seed-images.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    SEED_IMAGES = [
      { name: "Breakfast", url: "https://images.unsplash.com/photo-1533089862017-5614387e0748?w=800&q=80", folder: "categories", slug: "breakfast" },
      { name: "Desserts", url: "https://images.unsplash.com/photo-1563729784474-d77dbb933a9e?w=800&q=80", folder: "categories", slug: "desserts" },
      { name: "Dinner", url: "https://images.unsplash.com/photo-1546069901-ba9599a7e63c?w=800&q=80", folder: "categories", slug: "dinner" },
      { name: "Healthy", url: "https://images.unsplash.com/photo-1540189549336-e6e99c3679fe?w=800&q=80", folder: "categories", slug: "healthy" },
      { name: "Vegan", url: "https://images.unsplash.com/photo-1512621776951-a57141f2eefd?w=800&q=80", folder: "categories", slug: "vegan" },
      { name: "Baking", url: "https://images.unsplash.com/photo-1556910103-1c02745a30bf?w=800&q=80", folder: "categories", slug: "baking" }
    ];
    POST13 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.IMAGES) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500);
        }
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const results = [];
        for (const img of SEED_IMAGES) {
          try {
            const response = await fetch(img.url);
            if (!response.ok) {
              console.warn(`Failed to fetch ${img.url}`);
              continue;
            }
            const blob2 = await response.blob();
            const uploadResult = await uploadImage(
              env3.IMAGES,
              {
                file: blob2,
                filename: `${img.slug}.jpg`,
                contentType: blob2.type,
                folder: img.folder,
                metadata: { alt: img.name }
              },
              publicUrl
            );
            const variants = {
              original: { url: uploadResult.url, width: 800, height: 600, sizeBytes: uploadResult.size },
              // Approximate
              lg: { url: uploadResult.url, width: 800, height: 600, sizeBytes: uploadResult.size },
              md: { url: uploadResult.url, width: 800, height: 600, sizeBytes: uploadResult.size },
              sm: { url: uploadResult.url, width: 800, height: 600, sizeBytes: uploadResult.size },
              xs: { url: uploadResult.url, width: 800, height: 600, sizeBytes: uploadResult.size }
            };
            const mediaData = {
              name: img.name,
              altText: img.name,
              caption: `Default cover for ${img.slug}`,
              credit: "Unsplash",
              mimeType: uploadResult.contentType,
              variantsJson: JSON.stringify(variants),
              focalPointJson: JSON.stringify({ x: 50, y: 50 }),
              aspectRatio: "4:3"
            };
            const newMedia = await createMedia(env3.DB, mediaData);
            if (newMedia) {
              results.push({ id: newMedia.id, name: newMedia.name });
              const imageJson = JSON.stringify({
                media_id: newMedia.id,
                alt: newMedia.altText,
                placeholder: uploadResult.url,
                // simplistic placeholder
                aspectRatio: "4:3",
                variants
              });
              await env3.DB.prepare(`UPDATE categories SET cover_image_json = ? WHERE slug = ?`).bind(imageJson, img.slug).run();
            }
          } catch (innerError) {
            console.error(`Failed to seed ${img.name}:`, innerError);
          }
        }
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          message: `Seeded ${results.length} images`,
          seeded: results
        });
        return new Response(body, { status: 200, headers });
      } catch (error5) {
        console.error("Seeding completely failed:", error5);
        return new Response(JSON.stringify({ error: "Seeding failed" }), { status: 500 });
      }
    }, "POST");
    _page32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST13
    }, Symbol.toStringTag, { value: "Module" }));
    page32 = /* @__PURE__ */ __name(() => _page32, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/settings.service_C4TTblSS.mjs
async function getSetting(db, key) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.siteSettings.findFirst({
    where: eq(siteSettings.key, key)
  }) || null;
}
async function getSettingValue(db, key) {
  const setting = await getSetting(db, key);
  if (!setting) return null;
  try {
    return JSON.parse(setting.value);
  } catch {
    return setting.value;
  }
}
async function upsertSetting(db, key, value, options) {
  const drizzle2 = createDb(db);
  const valueStr = typeof value === "object" ? JSON.stringify(value) : value;
  const existing = await getSetting(db, key);
  if (existing) {
    await drizzle2.update(siteSettings).set({
      value: valueStr,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      ...options?.description && { description: options.description },
      ...options?.category && { category: options.category },
      ...options?.type && { type: options.type }
    }).where(eq(siteSettings.key, key));
  } else {
    await drizzle2.insert(siteSettings).values({
      key,
      value: valueStr,
      description: options?.description,
      category: options?.category || "general",
      type: options?.type || "json"
    });
  }
  return true;
}
async function getDashboardStats(db) {
  const result = await db.prepare(`
    SELECT
      (SELECT COUNT(*) FROM articles WHERE deleted_at IS NULL) as articles,
      (SELECT COUNT(*) FROM categories WHERE deleted_at IS NULL) as categories,
      (SELECT COUNT(*) FROM authors WHERE deleted_at IS NULL) as authors,
      (SELECT COUNT(*) FROM tags WHERE deleted_at IS NULL) as tags,
      (SELECT COALESCE(SUM(view_count), 0) FROM articles WHERE deleted_at IS NULL) as total_views
  `).first();
  return {
    articles: result?.articles || 0,
    categories: result?.categories || 0,
    authors: result?.authors || 0,
    tags: result?.tags || 0,
    totalViews: result?.total_views || 0
  };
}
async function getImageUploadSettings(db) {
  const stored = await getSettingValue(db, IMAGE_SETTINGS_KEY);
  return { ...IMAGE_UPLOAD_DEFAULTS, ...stored };
}
async function updateImageUploadSettings(db, updates) {
  const current = await getImageUploadSettings(db);
  const newSettings = { ...current, ...updates };
  await upsertSetting(db, IMAGE_SETTINGS_KEY, newSettings, {
    description: "Image upload module configuration",
    category: "media",
    type: "json"
  });
  return newSettings;
}
async function resetImageUploadSettings(db) {
  await upsertSetting(db, IMAGE_SETTINGS_KEY, IMAGE_UPLOAD_DEFAULTS, {
    description: "Image upload module configuration",
    category: "media",
    type: "json"
  });
  return IMAGE_UPLOAD_DEFAULTS;
}
var MessagePort4, MessageChannelPolyfill3, IMAGE_UPLOAD_DEFAULTS, IMAGE_SETTINGS_DB_KEY, ASPECT_RATIO_OPTIONS, parseAspectRatio, IMAGE_SETTINGS_KEY;
var init_settings_service_C4TTblSS = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/settings.service_C4TTblSS.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    IMAGE_UPLOAD_DEFAULTS = {
      webpQuality: 80,
      avifQuality: 70,
      maxFileSizeMB: 50,
      variantLg: 2048,
      variantMd: 1200,
      variantSm: 720,
      variantXs: 360,
      defaultFormat: "webp",
      defaultAspectRatio: "free",
      defaultCredit: ""
    };
    IMAGE_SETTINGS_DB_KEY = "image_upload_settings";
    ASPECT_RATIO_OPTIONS = [
      { value: "free", label: "Free (no constraint)" },
      { value: "1:1", label: "1:1 Square" },
      { value: "16:9", label: "16:9 Widescreen" },
      { value: "4:3", label: "4:3 Standard" },
      { value: "2:3", label: "2:3 Portrait" },
      { value: "3:2", label: "3:2 Landscape" },
      { value: "9:16", label: "9:16 Vertical" },
      { value: "4:5", label: "4:5 Photo" }
    ];
    ({
      lg: IMAGE_UPLOAD_DEFAULTS.variantLg,
      md: IMAGE_UPLOAD_DEFAULTS.variantMd,
      sm: IMAGE_UPLOAD_DEFAULTS.variantSm,
      xs: IMAGE_UPLOAD_DEFAULTS.variantXs
    });
    ({
      webp: IMAGE_UPLOAD_DEFAULTS.webpQuality,
      avif: IMAGE_UPLOAD_DEFAULTS.avifQuality
    });
    ({
      maxSizeBytes: IMAGE_UPLOAD_DEFAULTS.maxFileSizeMB * 1024 * 1024
    });
    parseAspectRatio = /* @__PURE__ */ __name((value) => {
      if (value === "free") return null;
      const [w, h] = value.split(":").map(Number);
      if (!Number.isFinite(w) || !Number.isFinite(h) || h === 0) return null;
      return w / h;
    }, "parseAspectRatio");
    ASPECT_RATIO_OPTIONS.reduce(
      (acc, option) => {
        acc[option.value] = parseAspectRatio(option.value);
        return acc;
      },
      {}
    );
    ASPECT_RATIO_OPTIONS.reduce(
      (acc, option) => {
        acc[option.value] = option.label;
        return acc;
      },
      {}
    );
    __name(getSetting, "getSetting");
    __name(getSettingValue, "getSettingValue");
    __name(upsertSetting, "upsertSetting");
    __name(getDashboardStats, "getDashboardStats");
    IMAGE_SETTINGS_KEY = IMAGE_SETTINGS_DB_KEY;
    __name(getImageUploadSettings, "getImageUploadSettings");
    __name(updateImageUploadSettings, "updateImageUploadSettings");
    __name(resetImageUploadSettings, "resetImageUploadSettings");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/settings/image-upload.astro.mjs
var image_upload_astro_exports = {};
__export(image_upload_astro_exports, {
  page: () => page33,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender28, GET24, PUT9, DELETE8, _page33, page33;
var init_image_upload_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/settings/image-upload.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_settings_service_C4TTblSS();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender28 = false;
    GET24 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.VIEWER)) {
          return createAuthError("Authentication required", 401);
        }
        const settings = await getImageUploadSettings(env3.DB);
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          data: settings,
          defaults: IMAGE_UPLOAD_DEFAULTS
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching image upload settings:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to fetch settings", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT9 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Editor role required to modify settings", 403);
        }
        let updates;
        try {
          updates = await request.json();
        } catch {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid JSON body", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const validKeys = Object.keys(IMAGE_UPLOAD_DEFAULTS);
        const sanitized = {};
        for (const [key, value] of Object.entries(updates)) {
          if (validKeys.includes(key)) {
            const defaultValue = IMAGE_UPLOAD_DEFAULTS[key];
            if (typeof value === typeof defaultValue) {
              sanitized[key] = value;
            }
          }
        }
        const newSettings = await updateImageUploadSettings(env3.DB, sanitized);
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          data: newSettings,
          message: "Settings updated"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error updating image upload settings:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to update settings", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE8 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Admin role required to reset settings", 403);
        }
        const settings = await resetImageUploadSettings(env3.DB);
        const { body, status, headers } = formatSuccessResponse({
          success: true,
          data: settings,
          message: "Settings reset to defaults"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error resetting image upload settings:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to reset settings", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE8,
      GET: GET24,
      PUT: PUT9,
      prerender: prerender28
    }, Symbol.toStringTag, { value: "Module" }));
    page33 = /* @__PURE__ */ __name(() => _page33, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/stats/dashboard.astro.mjs
var dashboard_astro_exports = {};
__export(dashboard_astro_exports, {
  page: () => page34,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender29, GET25, _page34, page34;
var init_dashboard_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/stats/dashboard.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_settings_service_C4TTblSS();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender29 = false;
    GET25 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.VIEWER)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const stats = await getDashboardStats(db);
        const { body, status, headers } = formatSuccessResponse(stats, {
          cacheControl: "private, max-age=60"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching dashboard stats:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch dashboard stats",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET25,
      prerender: prerender29
    }, Symbol.toStringTag, { value: "Module" }));
    page34 = /* @__PURE__ */ __name(() => _page34, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/stats/popular.astro.mjs
var popular_astro_exports = {};
__export(popular_astro_exports, {
  page: () => page35,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender30, GET26, _page35, page35;
var init_popular_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/stats/popular.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender30 = false;
    GET26 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const url = new URL(request.url);
        const limit = Math.min(parseInt(url.searchParams.get("limit") || "10"), 50);
        const result = await db.prepare(`
      SELECT 
        r.id,
        r.slug,
        r.headline as label,
        r.type,
        r.images_json,
        r.view_count,
        c.label as category_label,
        c.slug as category_slug
      FROM articles r
      LEFT JOIN categories c ON r.category_id = c.id
      WHERE r.is_online = 1
      ORDER BY r.view_count DESC, r.created_at DESC
      LIMIT ?1
    `).bind(limit).all();
        const articles2 = (result.results || []).map((a2) => {
          let imageUrl = "";
          try {
            const images = a2.images_json ? JSON.parse(a2.images_json) : {};
            imageUrl = images?.cover?.variants?.md?.url || images?.cover?.variants?.sm?.url || "";
          } catch {
          }
          return {
            id: a2.id,
            slug: a2.slug,
            title: a2.label,
            type: a2.type,
            imageUrl,
            views: a2.view_count || 0,
            category: a2.category_label,
            categorySlug: a2.category_slug
          };
        });
        const { body, status, headers } = formatSuccessResponse(articles2, {
          cacheControl: "no-cache, no-store, must-revalidate"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching popular articles:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to fetch popular articles", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    _page35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET26,
      prerender: prerender30
    }, Symbol.toStringTag, { value: "Module" }));
    page35 = /* @__PURE__ */ __name(() => _page35, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/tags.service_DE4uyghe.mjs
async function getTags(db, options) {
  const drizzle2 = createDb(db);
  const conditions = [isNull(tags.deletedAt)];
  if (options?.isOnline !== void 0) {
    conditions.push(eq(tags.isOnline, options.isOnline));
  }
  const query = drizzle2.select().from(tags).where(and(...conditions)).orderBy(asc(tags.label));
  if (options?.limit) {
    return await query.limit(options.limit);
  }
  return await query;
}
async function getTagBySlug(db, slug) {
  const drizzle2 = createDb(db);
  return await drizzle2.query.tags.findFirst({
    where: and(eq(tags.slug, slug), isNull(tags.deletedAt))
  }) || null;
}
async function createTag(db, tag2) {
  const drizzle2 = createDb(db);
  const [inserted] = await drizzle2.insert(tags).values(tag2).returning();
  return inserted || null;
}
async function updateTag(db, slug, tag2) {
  const drizzle2 = createDb(db);
  const updateData = {
    ...tag2,
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await drizzle2.update(tags).set(updateData).where(eq(tags.slug, slug));
  return getTagBySlug(db, slug);
}
async function deleteTag(db, slug) {
  const drizzle2 = createDb(db);
  await drizzle2.update(tags).set({ deletedAt: (/* @__PURE__ */ new Date()).toISOString() }).where(eq(tags.slug, slug));
  return true;
}
var MessagePort4, MessageChannelPolyfill3;
var init_tags_service_DE4uyghe = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/tags.service_DE4uyghe.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_drizzle_BakpoMbM();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(getTags, "getTags");
    __name(getTagBySlug, "getTagBySlug");
    __name(createTag, "createTag");
    __name(updateTag, "updateTag");
    __name(deleteTag, "deleteTag");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/helpers_CpZsZXUI.mjs
function parseStyleJson(value) {
  if (!value) return "{}";
  if (typeof value === "string") {
    try {
      const parsed = JSON.parse(value);
      return JSON.stringify(normalizeStyleJsonObject(parsed));
    } catch {
      return "{}";
    }
  }
  if (typeof value === "object") {
    return JSON.stringify(normalizeStyleJsonObject(value));
  }
  return "{}";
}
function transformTagRequestBody(body) {
  const transformed = { ...body };
  if (body.styleJson !== void 0) {
    transformed.styleJson = parseStyleJson(body.styleJson);
  } else if (body.color || body.svg_code || body.svgCode || body.variant || body.icon) {
    transformed.styleJson = parseStyleJson({
      color: body.color,
      svg_code: body.svg_code ?? body.svgCode ?? body.icon,
      variant: body.variant
    });
  }
  delete transformed.color;
  delete transformed.icon;
  delete transformed.svg_code;
  delete transformed.svgCode;
  delete transformed.variant;
  return transformed;
}
function transformTagResponse(tag2) {
  if (!tag2) return tag2;
  const response = { ...tag2 };
  if (tag2.styleJson) {
    try {
      const style = JSON.parse(tag2.styleJson);
      response.color = style.color;
      response.svgCode = style.svg_code;
      response.icon = style.svg_code;
      response.variant = style.variant;
    } catch {
    }
  }
  return response;
}
var MessagePort4, MessageChannelPolyfill3, normalizeStyleJsonObject;
var init_helpers_CpZsZXUI = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/helpers_CpZsZXUI.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    normalizeStyleJsonObject = /* @__PURE__ */ __name((value) => {
      if (!value || typeof value !== "object") return {};
      return {
        svg_code: value.svg_code ?? value.svgCode ?? value.icon,
        color: value.color,
        variant: value.variant
      };
    }, "normalizeStyleJsonObject");
    __name(parseStyleJson, "parseStyleJson");
    __name(transformTagRequestBody, "transformTagRequestBody");
    __name(transformTagResponse, "transformTagResponse");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/tags/_slug_.astro.mjs
var slug_astro_exports7 = {};
__export(slug_astro_exports7, {
  page: () => page36,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender31, getTagBySlug2, GET27, PUT10, DELETE9, _page36, page36;
var init_slug_astro7 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/tags/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_tags_service_DE4uyghe();
    init_helpers_CpZsZXUI();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender31 = false;
    getTagBySlug2 = /* @__PURE__ */ __name(async (db, slug) => {
      const { results } = await db.prepare("SELECT * FROM tags WHERE slug = ?").bind(slug).all();
      if (results.length === 0) return null;
      return {
        id: results[0].id,
        slug: results[0].slug,
        label: results[0].label,
        // ... map other fields if needed, but for now let's just return the raw object or map it properly
        // actually I should use the mapper from db.ts but it's not exported.
        // I'll just return the result and hope the frontend handles it or I'll duplicate the mapper logic slightly.
        // The frontend expects specific fields.
        // Let's just use the same structure as getTags.
        ...results[0],
        isOnline: Boolean(results[0].is_online),
        isFavorite: Boolean(results[0].is_favorite),
        createdAt: results[0].created_at,
        updatedAt: results[0].updated_at,
        route: `/tags/${results[0].slug}`
      };
    }, "getTagBySlug");
    GET27 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const tag2 = await getTagBySlug2(db, slug);
        const responseTag = transformTagResponse(tag2);
        if (!responseTag) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Tag not found", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse(responseTag, {
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching tag:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch tag",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT10 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        const transformedBody = transformTagRequestBody(body);
        const tag2 = await updateTag(env3.DB, slug, transformedBody);
        const responseTag = transformTagResponse(tag2);
        if (!responseTag) {
          const { body: errBody, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Tag not found", 404)
          );
          return new Response(errBody, { status: status2, headers: headers2 });
        }
        const { body: respBody, status, headers } = formatSuccessResponse(responseTag);
        return new Response(respBody, { status, headers });
      } catch (error5) {
        console.error("Error updating tag:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to update tag", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE9 = /* @__PURE__ */ __name(async ({ request, params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const success = await deleteTag(env3.DB, slug);
        if (!success) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Tag not found or failed to delete", 404)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const { body, status, headers } = formatSuccessResponse({ deleted: true });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting tag:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to delete tag", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE9,
      GET: GET27,
      PUT: PUT10,
      prerender: prerender31
    }, Symbol.toStringTag, { value: "Module" }));
    page36 = /* @__PURE__ */ __name(() => _page36, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/tags.astro.mjs
var tags_astro_exports = {};
__export(tags_astro_exports, {
  page: () => page37,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender32, GET28, POST14, _page37, page37;
var init_tags_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/tags.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_tags_service_DE4uyghe();
    init_helpers_CpZsZXUI();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender32 = false;
    GET28 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const db = env3.DB;
        const tags2 = await getTags(db);
        const responseTags = tags2.map(transformTagResponse);
        const { body, status, headers } = formatSuccessResponse(responseTags, {
          cacheControl: "public, max-age=3600"
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching tags:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(
            ErrorCodes.DATABASE_ERROR,
            "Failed to fetch tags",
            500,
            { originalError: error5 instanceof Error ? error5.message : "Unknown error" }
          )
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST14 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const reqBody = await request.json();
        const transformedBody = transformTagRequestBody(reqBody);
        const tag2 = await createTag(env3.DB, transformedBody);
        const responseTag = transformTagResponse(tag2);
        const { body, status, headers } = formatSuccessResponse(responseTag);
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error creating tag:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to create tag", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET28,
      POST: POST14,
      prerender: prerender32
    }, Symbol.toStringTag, { value: "Module" }));
    page37 = /* @__PURE__ */ __name(() => _page37, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/handlers_CrpakuiS.mjs
function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify({ success: true, data }), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": "no-cache, no-store, must-revalidate"
    }
  });
}
function errorResponse(message2, status = 400) {
  return new Response(JSON.stringify({ success: false, error: message2 }), {
    status,
    headers: { "Content-Type": "application/json" }
  });
}
async function handleListTemplates(db, activeOnly = true) {
  try {
    let query = `
      SELECT 
        id, slug, name, description, thumbnail_url,
        width, height, category,
        elements_json, is_active,
        created_at, updated_at
      FROM pin_templates
      WHERE 1=1
    `;
    if (activeOnly) {
      query += " AND is_active = 1";
    }
    query += " ORDER BY created_at DESC";
    const result = await db.prepare(query).all();
    const templates = (result.results || []).map((t2) => ({
      ...t2,
      elements: t2.elements_json ? JSON.parse(t2.elements_json) : []
    }));
    return jsonResponse(templates);
  } catch (error5) {
    console.error("Error fetching templates:", error5);
    return errorResponse("Failed to fetch templates", 500);
  }
}
async function handleGetTemplate(db, slug) {
  try {
    if (!slug) {
      return errorResponse("Slug is required", 400);
    }
    const result = await db.prepare(`
      SELECT 
        id, slug, name, description, thumbnail_url,
        width, height, category,
        elements_json, is_active,
        created_at, updated_at
      FROM pin_templates
      WHERE slug = ?1
    `).bind(slug).first();
    if (!result) {
      return errorResponse("Template not found", 404);
    }
    const template2 = {
      ...result,
      elements: result.elements_json ? JSON.parse(result.elements_json) : []
    };
    return jsonResponse(template2);
  } catch (error5) {
    console.error("Error fetching template:", error5);
    return errorResponse("Failed to fetch template", 500);
  }
}
async function handleCreateTemplate(db, body) {
  try {
    const {
      slug,
      name,
      description = "",
      thumbnail_url = null,
      width = 1e3,
      height = 1500,
      category = "general",
      elements_json = "[]",
      is_active = true
    } = body;
    if (!slug || !name) {
      return errorResponse("Slug and name are required", 400);
    }
    const elementsStr = typeof elements_json === "string" ? elements_json : JSON.stringify(elements_json);
    const result = await db.prepare(`
      INSERT INTO pin_templates (
        slug, name, description, thumbnail_url,
        width, height, category,
        elements_json, is_active
      ) VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)
    `).bind(
      slug,
      name,
      description,
      thumbnail_url,
      width,
      height,
      category,
      elementsStr,
      is_active ? 1 : 0
    ).run();
    if (!result.success) {
      return errorResponse("Failed to create template", 500);
    }
    return jsonResponse({
      id: result.meta?.last_row_id,
      slug,
      message: "Template created successfully"
    }, 201);
  } catch (error5) {
    console.error("Error creating template:", error5);
    if (error5.message?.includes("UNIQUE constraint")) {
      return errorResponse("Template with this slug already exists", 409);
    }
    return errorResponse("Failed to create template", 500);
  }
}
async function handleUpdateTemplate(db, slug, body) {
  try {
    if (!slug) {
      return errorResponse("Slug is required", 400);
    }
    const {
      name,
      description,
      thumbnail_url,
      width,
      height,
      category,
      elements_json,
      is_active,
      slug: newSlug
    } = body;
    const elementsStr = elements_json !== void 0 ? typeof elements_json === "string" ? elements_json : JSON.stringify(elements_json) : void 0;
    const updates = [];
    const updateParams = [];
    let paramIndex = 1;
    if (name !== void 0) {
      updates.push(`name = ?${paramIndex++}`);
      updateParams.push(name);
    }
    if (description !== void 0) {
      updates.push(`description = ?${paramIndex++}`);
      updateParams.push(description);
    }
    if (thumbnail_url !== void 0) {
      updates.push(`thumbnail_url = ?${paramIndex++}`);
      updateParams.push(thumbnail_url);
    }
    if (width !== void 0) {
      updates.push(`width = ?${paramIndex++}`);
      updateParams.push(width);
    }
    if (height !== void 0) {
      updates.push(`height = ?${paramIndex++}`);
      updateParams.push(height);
    }
    if (category !== void 0) {
      updates.push(`category = ?${paramIndex++}`);
      updateParams.push(category);
    }
    if (elementsStr !== void 0) {
      updates.push(`elements_json = ?${paramIndex++}`);
      updateParams.push(elementsStr);
    }
    if (is_active !== void 0) {
      updates.push(`is_active = ?${paramIndex++}`);
      updateParams.push(is_active ? 1 : 0);
    }
    if (newSlug !== void 0 && newSlug !== slug) {
      updates.push(`slug = ?${paramIndex++}`);
      updateParams.push(newSlug);
    }
    if (updates.length === 0) {
      return errorResponse("No updates provided", 400);
    }
    updateParams.push(slug);
    const query = `
      UPDATE pin_templates 
      SET ${updates.join(", ")}, updated_at = CURRENT_TIMESTAMP
      WHERE slug = ?${paramIndex}
    `;
    const result = await db.prepare(query).bind(...updateParams).run();
    if (result.meta?.changes === 0) {
      return errorResponse("Template not found", 404);
    }
    return jsonResponse({
      slug: newSlug || slug,
      message: "Template updated successfully"
    });
  } catch (error5) {
    console.error("Error updating template:", error5);
    if (error5.message?.includes("UNIQUE constraint")) {
      return errorResponse("Template with this slug already exists", 409);
    }
    return errorResponse("Failed to update template", 500);
  }
}
async function handleDeleteTemplate(db, slug) {
  try {
    if (!slug) {
      return errorResponse("Slug is required", 400);
    }
    const result = await db.prepare(`
      DELETE FROM pin_templates WHERE slug = ?1
    `).bind(slug).run();
    if (result.meta?.changes === 0) {
      return errorResponse("Template not found", 404);
    }
    return jsonResponse({ message: "Template deleted successfully" });
  } catch (error5) {
    console.error("Error deleting template:", error5);
    return errorResponse("Failed to delete template", 500);
  }
}
var MessagePort4, MessageChannelPolyfill3;
var init_handlers_CrpakuiS = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/handlers_CrpakuiS.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __name(jsonResponse, "jsonResponse");
    __name(errorResponse, "errorResponse");
    __name(handleListTemplates, "handleListTemplates");
    __name(handleGetTemplate, "handleGetTemplate");
    __name(handleCreateTemplate, "handleCreateTemplate");
    __name(handleUpdateTemplate, "handleUpdateTemplate");
    __name(handleDeleteTemplate, "handleDeleteTemplate");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/templates/_slug_.astro.mjs
var slug_astro_exports8 = {};
__export(slug_astro_exports8, {
  page: () => page38,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender33, GET29, PUT11, DELETE10, _page38, page38;
var init_slug_astro8 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/templates/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_templates_schema_DMbF8Dv3();
    init_handlers_CrpakuiS();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender33 = false;
    GET29 = /* @__PURE__ */ __name(async ({ params, locals }) => {
      try {
        const env3 = locals.runtime.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const { slug } = params;
        return handleGetTemplate(env3.DB, slug || "");
      } catch (error5) {
        console.error("Error fetching template:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to fetch template", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    PUT11 = /* @__PURE__ */ __name(async ({ params, request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const { slug } = params;
        const body = await request.json();
        return handleUpdateTemplate(env3.DB, slug || "", body);
      } catch (error5) {
        console.error("Error updating template:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to update template", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "PUT");
    DELETE10 = /* @__PURE__ */ __name(async ({ params, request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const { slug } = params;
        return handleDeleteTemplate(env3.DB, slug || "");
      } catch (error5) {
        console.error("Error deleting template:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to delete template", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE10,
      GET: GET29,
      PUT: PUT11,
      prerender: prerender33
    }, Symbol.toStringTag, { value: "Module" }));
    page38 = /* @__PURE__ */ __name(() => _page38, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/templates.astro.mjs
var templates_astro_exports = {};
__export(templates_astro_exports, {
  page: () => page39,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender34, GET30, POST15, _page39, page39;
var init_templates_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/templates.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_templates_schema_DMbF8Dv3();
    init_handlers_CrpakuiS();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender34 = false;
    GET30 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const url = new URL(request.url);
        const isActive = url.searchParams.get("is_active") !== "false";
        return handleListTemplates(env3.DB, isActive);
      } catch (error5) {
        console.error("Error fetching templates:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to fetch templates", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST15 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime.env;
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions", 403);
        }
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const body = await request.json();
        return handleCreateTemplate(env3.DB, body);
      } catch (error5) {
        console.error("Error creating template:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, error5.message || "Failed to create template", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page39 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET30,
      POST: POST15,
      prerender: prerender34
    }, Symbol.toStringTag, { value: "Module" }));
    page39 = /* @__PURE__ */ __name(() => _page39, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/upload-font.astro.mjs
var upload_font_astro_exports = {};
__export(upload_font_astro_exports, {
  page: () => page40,
  renderers: () => renderers
});
import path2 from "node:path";
var MessagePort4, MessageChannelPolyfill3, prerender35, ALLOWED_EXTENSIONS, POST16, GET31, DELETE11, _page40, page40;
var init_upload_font_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/upload-font.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_promises2();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender35 = false;
    ALLOWED_EXTENSIONS = [".ttf", ".otf", ".woff", ".woff2"];
    POST16 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions to upload fonts", 403);
        }
        const formData = await request.formData();
        const file = formData.get("file");
        if (!file) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "No file provided", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const ext = path2.extname(file.name).toLowerCase();
        if (!ALLOWED_EXTENSIONS.includes(ext)) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, `Invalid font type. Allowed: ${ALLOWED_EXTENSIONS.join(", ")}`, 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        if (file.size > 5 * 1024 * 1024) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Font file too large (max 5MB)", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const baseName = file.name.replace(ext, "").replace(/[^a-zA-Z0-9_-]/g, "_");
        const safeFilename = `${baseName}${ext}`;
        const fontsDir = path2.join(process.cwd(), "public", "fonts");
        await promises_default.mkdir(fontsDir, { recursive: true });
        const filePath = path2.join(fontsDir, safeFilename);
        const buffer = Buffer.from(await file.arrayBuffer());
        await promises_default.writeFile(filePath, buffer);
        const url = `/fonts/${safeFilename}`;
        const { body, status, headers } = formatSuccessResponse({
          url,
          filename: safeFilename,
          size: file.size
        });
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error uploading font:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to upload font", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    GET31 = /* @__PURE__ */ __name(async ({ locals }) => {
      try {
        const fontsDir = path2.join(process.cwd(), "public", "fonts");
        try {
          const files = await promises_default.readdir(fontsDir);
          const fonts = files.filter((f) => ALLOWED_EXTENSIONS.includes(path2.extname(f).toLowerCase())).map((f) => ({
            name: f.replace(path2.extname(f), ""),
            filename: f,
            url: `/fonts/${f}`
          }));
          const { body, status, headers } = formatSuccessResponse(fonts);
          return new Response(body, { status, headers });
        } catch {
          const { body, status, headers } = formatSuccessResponse([]);
          return new Response(body, { status, headers });
        }
      } catch (error5) {
        console.error("Error listing fonts:", error5);
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to list fonts", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    DELETE11 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        const jwtSecret = env3?.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions to delete fonts", 403);
        }
        const url = new URL(request.url);
        const filename = url.searchParams.get("filename");
        if (!filename) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Filename is required", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const ext = path2.extname(filename).toLowerCase();
        if (!ALLOWED_EXTENSIONS.includes(ext)) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid file type", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const fontsDir = path2.join(process.cwd(), "public", "fonts");
        const filePath = path2.join(fontsDir, filename);
        await promises_default.unlink(filePath);
        const { body, status, headers } = formatSuccessResponse({ deleted: filename });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error deleting font:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to delete font", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "DELETE");
    _page40 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      DELETE: DELETE11,
      GET: GET31,
      POST: POST16,
      prerender: prerender35
    }, Symbol.toStringTag, { value: "Module" }));
    page40 = /* @__PURE__ */ __name(() => _page40, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/upload-from-url.astro.mjs
var upload_from_url_astro_exports = {};
__export(upload_from_url_astro_exports, {
  page: () => page41,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, POST17, _page41, page41;
var init_upload_from_url_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/upload-from-url.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    POST17 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.IMAGES) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500);
        }
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR) && !hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const body = await request.json();
        const imageUrl = body.imageUrl || body.url;
        const { alt, attribution, caption } = body;
        if (!imageUrl) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, "No URL provided", 400);
        }
        const response = await fetch(imageUrl);
        if (!response.ok) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, `Failed to fetch image from URL: ${response.statusText}`, 400);
        }
        const blob2 = await response.blob();
        const rawFilename = imageUrl.split("/").pop()?.split("?")[0] || `import-${Date.now()}`;
        const filename = rawFilename.replace(/[^a-zA-Z0-9._-]/g, "_");
        const result = await uploadImage(
          env3.IMAGES,
          {
            file: blob2,
            filename,
            contentType: blob2.type || "image/jpeg",
            folder: "media",
            metadata: {
              alt: alt || "",
              credit: attribution || ""
            }
          },
          publicUrl
        );
        const variants = {
          original: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          lg: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          md: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          sm: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          xs: { url: result.url, width: 0, height: 0, sizeBytes: result.size }
        };
        const mediaData = {
          name: filename,
          altText: alt || "",
          caption: caption || "",
          credit: attribution || "",
          mimeType: result.contentType,
          variantsJson: JSON.stringify(variants),
          focalPointJson: JSON.stringify({ x: 50, y: 50 }),
          aspectRatio: "1:1"
        };
        const newMedia = await createMedia(env3.DB, mediaData);
        if (!newMedia) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to save media record", 500);
        }
        const { body: responseBody, status, headers } = formatSuccessResponse(newMedia);
        return new Response(responseBody, { status: 201, headers });
      } catch (error5) {
        console.error("Error uploading from URL:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Import from URL failed", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST17
    }, Symbol.toStringTag, { value: "Module" }));
    page41 = /* @__PURE__ */ __name(() => _page41, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/upload-image.astro.mjs
var upload_image_astro_exports = {};
__export(upload_image_astro_exports, {
  page: () => page42,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, POST18, _page42, page42;
var init_upload_image_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/upload-image.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_media_service_BzvilGys();
    init_pinterest_schema_eG5oHE2g();
    init_error_handler_D5quUcAZ();
    init_auth_service_GsDnjv();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    POST18 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.IMAGES) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500);
        }
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR) && !hasRole(authContext, AuthRoles.ADMIN)) {
          return createAuthError("Insufficient permissions", 403);
        }
        const formData = await request.formData();
        const file = formData.get("file");
        const alt = formData.get("alt");
        const attribution = formData.get("attribution");
        const caption = formData.get("caption");
        if (!file) {
          throw new AppError(ErrorCodes.VALIDATION_ERROR, "No file uploaded", 400);
        }
        const result = await uploadImage(
          env3.IMAGES,
          {
            file,
            filename: file.name,
            contentType: file.type,
            folder: "media",
            metadata: {
              alt: alt || "",
              credit: attribution || ""
            }
          },
          publicUrl
        );
        const variants = {
          original: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          lg: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          md: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          sm: { url: result.url, width: 0, height: 0, sizeBytes: result.size },
          xs: { url: result.url, width: 0, height: 0, sizeBytes: result.size }
        };
        const mediaData = {
          name: file.name,
          altText: alt || "",
          caption: caption || "",
          credit: attribution || "",
          mimeType: result.contentType,
          variantsJson: JSON.stringify(variants),
          focalPointJson: JSON.stringify({ x: 50, y: 50 }),
          aspectRatio: "1:1"
          // Placeholder
        };
        const newMedia = await createMedia(env3.DB, mediaData);
        if (!newMedia) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Failed to save media record", 500);
        }
        const { body, status, headers } = formatSuccessResponse(newMedia);
        return new Response(body, { status: 201, headers });
      } catch (error5) {
        console.error("Error uploading image:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, "Upload failed", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page42 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST18
    }, Symbol.toStringTag, { value: "Module" }));
    page42 = /* @__PURE__ */ __name(() => _page42, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/upload-thumbnail.astro.mjs
var upload_thumbnail_astro_exports = {};
__export(upload_thumbnail_astro_exports, {
  page: () => page43,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender36, POST19, _page43, page43;
var init_upload_thumbnail_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/upload-thumbnail.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_pinterest_schema_eG5oHE2g();
    init_templates_schema_DMbF8Dv3();
    init_auth_service_GsDnjv();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender36 = false;
    POST19 = /* @__PURE__ */ __name(async ({ request, locals }) => {
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.IMAGES) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Storage not configured", 500);
        }
        const bucket = env3.IMAGES;
        const publicUrl = env3.R2_PUBLIC_URL ? env3.R2_PUBLIC_URL.replace(/\/$/, "") : "/images";
        const jwtSecret = env3.JWT_SECRET || "Bildev2025";
        const authContext = await extractAuthContext(request, jwtSecret);
        if (!hasRole(authContext, AuthRoles.EDITOR)) {
          return createAuthError("Insufficient permissions to upload thumbnails", 403);
        }
        const formData = await request.formData();
        const file = formData.get("file");
        const templateSlug = formData.get("templateSlug") || "untitled";
        const oldThumbnailUrl = formData.get("oldThumbnailUrl") || "";
        if (!file) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "No file provided", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/webp"];
        if (!allowedTypes.includes(file.type)) {
          const { body: body2, status: status2, headers: headers2 } = formatErrorResponse(
            new AppError(ErrorCodes.VALIDATION_ERROR, "Invalid file type. Only JPEG, PNG, and WebP are allowed.", 400)
          );
          return new Response(body2, { status: status2, headers: headers2 });
        }
        if (oldThumbnailUrl && oldThumbnailUrl.includes("/thumbnails/")) {
          try {
            const urlParts = oldThumbnailUrl.split("/images/");
            if (urlParts.length > 1) {
              const oldKey = urlParts[1];
              await deleteImage(bucket, oldKey);
              console.log(`Deleted old thumbnail: ${oldKey}`);
            }
          } catch (deleteError) {
            console.warn("Failed to delete old thumbnail:", deleteError);
          }
        }
        const result = await uploadImage(
          bucket,
          {
            file,
            filename: file.name,
            contentType: file.type,
            metadata: {
              type: "template-thumbnail",
              templateSlug
            },
            folder: "thumbnails",
            contextSlug: templateSlug
          },
          publicUrl
        );
        const { body, status, headers } = formatSuccessResponse({
          url: result.url,
          key: result.key,
          size: result.size
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error uploading thumbnail:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.INTERNAL_ERROR, error5.message || "Failed to upload thumbnail", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page43 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      POST: POST19,
      prerender: prerender36
    }, Symbol.toStringTag, { value: "Module" }));
    page43 = /* @__PURE__ */ __name(() => _page43, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/api/views/_slug_.astro.mjs
var slug_astro_exports9 = {};
__export(slug_astro_exports9, {
  page: () => page44,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender37, GET32, POST20, _page44, page44;
var init_slug_astro9 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/api/views/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_error_handler_D5quUcAZ();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender37 = false;
    GET32 = /* @__PURE__ */ __name(async ({ params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const article = await getArticleBySlug(env3.DB, slug);
        const { body, status, headers } = formatSuccessResponse({
          viewCount: article?.viewCount || 0
        });
        return new Response(body, { status, headers });
      } catch (error5) {
        console.error("Error fetching view count:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to fetch view count", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "GET");
    POST20 = /* @__PURE__ */ __name(async ({ params, locals }) => {
      const { slug } = params;
      if (!slug) {
        const { body, status, headers } = formatErrorResponse(
          new AppError(ErrorCodes.VALIDATION_ERROR, "Slug is required", 400)
        );
        return new Response(body, { status, headers });
      }
      try {
        const env3 = locals.runtime?.env;
        if (!env3?.DB) {
          throw new AppError(ErrorCodes.INTERNAL_ERROR, "Database not configured", 500);
        }
        const success = await incrementViewCount(env3.DB, slug);
        if (success) {
          const { body, status, headers } = formatSuccessResponse({ incremented: true });
          return new Response(body, { status, headers });
        } else {
          const { body, status, headers } = formatErrorResponse(
            new AppError(ErrorCodes.NOT_FOUND, "Article not found", 404)
          );
          return new Response(body, { status, headers });
        }
      } catch (error5) {
        console.error("Error incrementing view count:", error5);
        const { body, status, headers } = formatErrorResponse(
          error5 instanceof AppError ? error5 : new AppError(ErrorCodes.DATABASE_ERROR, "Failed to increment view count", 500)
        );
        return new Response(body, { status, headers });
      }
    }, "POST");
    _page44 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET32,
      POST: POST20,
      prerender: prerender37
    }, Symbol.toStringTag, { value: "Module" }));
    page44 = /* @__PURE__ */ __name(() => _page44, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/RecipeCard_3G-w8UC6.mjs
var MessagePort4, MessageChannelPolyfill3, $$Astro3, $$RecipeCard;
var init_RecipeCard_3G_w8UC6 = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/RecipeCard_3G-w8UC6.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_hydration_PCOoIFzn();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro3 = createAstro("https://localhost:4321");
    $$RecipeCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro3, $$props, $$slots);
      Astro2.self = $$RecipeCard;
      const { recipe } = Astro2.props;
      const recipeDetails = recipe.recipeJson;
      const thumbnail = extractImage(recipe.imagesJson, "thumbnail", 720);
      const cover = extractImage(recipe.imagesJson, "cover", 720);
      const slotName2 = thumbnail.imageUrl ? "thumbnail" : "cover";
      const selectedImage = thumbnail.imageUrl ? thumbnail : cover;
      const srcSet = getImageSrcSet(recipe.imagesJson, slotName2);
      const sizes = "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 360px";
      return renderTemplate`${maybeRenderHead()}<article class="group bg-white dark:bg-gray-800 rounded-xl overflow-hidden
shadow-md hover:shadow-xl transition-all duration-300 transform
hover:-translate-y-1"> <a${addAttribute(recipe.route, "href")} class="block"> <!-- Recipe Image
--> <div class="relative h-48 overflow-hidden"> <img${addAttribute(selectedImage.imageUrl || recipe.imageUrl, "src")}${addAttribute(selectedImage.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selectedImage.imageWidth || recipe.imageWidth || 720, "width")}${addAttribute(selectedImage.imageHeight || recipe.imageHeight || 480, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} class="w-full h-full object-cover
group-hover:scale-110 transition-transform duration-300" loading="lazy"> <!--
Favorite Badge --> ${recipe.isFavorite && renderTemplate`<div class="absolute top-3 right-3
bg-red-600 text-white px-3 py-1 rounded-full text-xs font-semibold flex
items-center gap-1"> ${" "} <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20
20"> ${" "} <path d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656
5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"></path>${" "} </svg>${" "} <span>Featured</span> </div>`} </div> <!-- Recipe Info --> <div class="p-5"> <!-- Category & Tags
--> <div class="flex items-center gap-2 mb-3"> <span class="text-xs
font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wide"> ${recipe.categorySlug.replace(/-/g, " ")} </span> </div> <!-- Title --> <h3 class="text-xl font-bold text-gray-900 dark:text-white mb-2 line-clamp-2
group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors"> ${recipe.headline} </h3> <!-- Description --> <p class="text-gray-600
dark:text-gray-300 text-sm mb-4 line-clamp-2"> ${recipe.shortDescription} </p> <!-- Meta Info --> <div class="flex items-center justify-between text-sm
text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700
pt-4"> ${recipeDetails?.prepTime && renderTemplate`<div class="flex items-center gap-1"> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12
8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>${" "} </svg> <span>${recipeDetails.prepTime}</span>${" "} </div>`} ${recipeDetails?.servings && renderTemplate`<div class="flex items-center gap-1"> ${" "} <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"> ${" "} <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15
21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M13 7a4 4 0 11-8 0 4 4 0 018
0z"></path>${" "} </svg>${" "} <span>${recipeDetails.servings} servings</span>${" "} </div>`} </div> </div> </a> </article>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/RecipeCard.astro", void 0);
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/authors/_slug_.astro.mjs
var slug_astro_exports10 = {};
__export(slug_astro_exports10, {
  page: () => page45,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro4, $$slug, $$file3, $$url3, _page45, page45;
var init_slug_astro10 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/authors/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_RecipeCard_3G_w8UC6();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    init_articles_service_DgNeye45();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro4 = createAstro("https://localhost:4321");
    $$slug = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro4, $$props, $$slots);
      Astro2.self = $$slug;
      const { slug } = Astro2.params;
      const { env: env3 } = Astro2.locals.runtime;
      if (!slug) {
        return Astro2.redirect("/404");
      }
      const author = await getAuthorBySlug(env3.DB, slug);
      if (!author) {
        return Astro2.redirect("/404");
      }
      const { items: articles2, total } = await getArticles(env3.DB, {
        authorSlug: slug
      });
      const avatar = extractImage(author.imagesJson, "avatar", 200);
      const avatarSrcSet = getImageSrcSet(author.imagesJson, "avatar");
      const avatarSizes = "150px";
      const pageTitle = author.metaTitle || `${author.name} - Freecipies`;
      const pageDescription = author.metaDescription || author.shortDescription || `Recipes and tips by ${author.name}.`;
      let bioParagraphs = [];
      let socialNetworks = [];
      if (author.bioJson) {
        try {
          const bio = typeof author.bioJson === "string" ? JSON.parse(author.bioJson) : author.bioJson;
          bioParagraphs = bio.paragraphs || [];
          socialNetworks = bio.networks || [];
        } catch (e2) {
        }
      }
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": pageTitle, "description": pageDescription, "data-astro-cid-7aexiinu": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="author-profile" data-astro-cid-7aexiinu> <!-- Author Hero --> <section class="hero-section" data-astro-cid-7aexiinu> <div class="hero-container" data-astro-cid-7aexiinu> <div class="author-header" data-astro-cid-7aexiinu> <!-- Avatar --> <div class="avatar-container" data-astro-cid-7aexiinu> ${avatar.imageUrl || author.imageUrl ? renderTemplate`<img${addAttribute(avatar.imageUrl || author.imageUrl, "src")}${addAttribute(avatar.imageAlt || author.imageAlt || author.name, "alt")}${addAttribute(avatar.imageWidth || author.imageWidth || 150, "width")}${addAttribute(avatar.imageHeight || author.imageHeight || 150, "height")}${addAttribute(avatarSrcSet || void 0, "srcset")}${addAttribute(avatarSrcSet ? avatarSizes : void 0, "sizes")} class="author-avatar" data-astro-cid-7aexiinu>` : renderTemplate`<div class="avatar-placeholder" data-astro-cid-7aexiinu> <span data-astro-cid-7aexiinu>${author.name.charAt(0).toUpperCase()}</span> </div>`} </div> <!-- Info --> <div class="author-info" data-astro-cid-7aexiinu> <h1 class="author-name" data-astro-cid-7aexiinu>${author.name}</h1> ${author.job && renderTemplate`<p class="author-job" data-astro-cid-7aexiinu>${author.job}</p>`} <p class="author-description" data-astro-cid-7aexiinu> ${author.shortDescription} </p> <!-- Stats --> <div class="author-stats" data-astro-cid-7aexiinu> <div class="stat" data-astro-cid-7aexiinu> <span class="stat-value" data-astro-cid-7aexiinu>${total}</span> <span class="stat-label" data-astro-cid-7aexiinu>${total === 1 ? "Recipe" : "Recipes"}</span> </div> </div> <!-- Social Links --> ${socialNetworks.length > 0 && renderTemplate`<div class="social-links" data-astro-cid-7aexiinu> ${socialNetworks.map((network) => renderTemplate`<a${addAttribute(network.url, "href")} target="_blank" rel="noopener noreferrer" class="social-link"${addAttribute(network.name, "title")} data-astro-cid-7aexiinu> ${network.name} </a>`)} </div>`} </div> </div> </div> </section> <!-- Bio Section --> ${bioParagraphs.length > 0 && renderTemplate`<section class="bio-section" data-astro-cid-7aexiinu> <div class="section-container" data-astro-cid-7aexiinu> <h2 class="section-title" data-astro-cid-7aexiinu>About ${author.name}</h2> <div class="bio-content" data-astro-cid-7aexiinu> ${bioParagraphs.map((paragraph) => renderTemplate`<p data-astro-cid-7aexiinu>${paragraph}</p>`)} </div> </div> </section>`} <!-- Recipes Section --> <section class="recipes-section" data-astro-cid-7aexiinu> <div class="section-container" data-astro-cid-7aexiinu> <div class="section-header" data-astro-cid-7aexiinu> <h2 class="section-title" data-astro-cid-7aexiinu>Recipes by ${author.name}</h2> <span class="recipe-count" data-astro-cid-7aexiinu>${total} ${total === 1 ? "recipe" : "recipes"}</span> </div> ${articles2.length > 0 ? renderTemplate`<div class="recipes-grid" data-astro-cid-7aexiinu> ${articles2.map((article) => renderTemplate`${renderComponent($$result2, "RecipeCard", $$RecipeCard, { "recipe": article, "data-astro-cid-7aexiinu": true })}`)} </div>` : renderTemplate`<div class="empty-state" data-astro-cid-7aexiinu> <p data-astro-cid-7aexiinu>No recipes published yet.</p> </div>`} </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/[slug].astro", void 0);
    $$file3 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/[slug].astro";
    $$url3 = "/authors/[slug]";
    _page45 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$slug,
      file: $$file3,
      url: $$url3
    }, Symbol.toStringTag, { value: "Module" }));
    page45 = /* @__PURE__ */ __name(() => _page45, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/authors.astro.mjs
var authors_astro_exports2 = {};
__export(authors_astro_exports2, {
  page: () => page46,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro$13, $$AuthorCard, $$Astro5, $$Index, $$file4, $$url4, _page46, page46;
var init_authors_astro3 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/authors.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_hydration_PCOoIFzn();
    init_pinterest_schema_eG5oHE2g();
    init_authors_service_DDYOeshw();
    init_articles_service_DgNeye45();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$13 = createAstro("https://localhost:4321");
    $$AuthorCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$13, $$props, $$slots);
      Astro2.self = $$AuthorCard;
      const { author, showArticleCount = false, articleCount = 0 } = Astro2.props;
      const authorUrl = `/authors/${author.slug}`;
      const avatar = extractImage(author.imagesJson, "avatar", 200);
      const avatarSrcSet = getImageSrcSet(author.imagesJson, "avatar");
      const avatarSizes = "120px";
      return renderTemplate`${maybeRenderHead()}<article class="author-card" data-astro-cid-32rj7774> <a${addAttribute(authorUrl, "href")} class="author-link" data-astro-cid-32rj7774> <!-- Author Avatar --> <div class="author-avatar" data-astro-cid-32rj7774> ${avatar.imageUrl || author.imageUrl ? renderTemplate`<img${addAttribute(avatar.imageUrl || author.imageUrl, "src")}${addAttribute(avatar.imageAlt || author.imageAlt || author.name, "alt")}${addAttribute(avatar.imageWidth || author.imageWidth || 120, "width")}${addAttribute(avatar.imageHeight || author.imageHeight || 120, "height")}${addAttribute(avatarSrcSet || void 0, "srcset")}${addAttribute(avatarSrcSet ? avatarSizes : void 0, "sizes")} loading="lazy" data-astro-cid-32rj7774>` : renderTemplate`<div class="avatar-placeholder" data-astro-cid-32rj7774> <span data-astro-cid-32rj7774>${author.name.charAt(0).toUpperCase()}</span> </div>`} </div> <!-- Author Info --> <div class="author-info" data-astro-cid-32rj7774> <h3 class="author-name" data-astro-cid-32rj7774>${author.name}</h3> ${author.job && renderTemplate`<p class="author-job" data-astro-cid-32rj7774>${author.job}</p>`} ${author.shortDescription && renderTemplate`<p class="author-description" data-astro-cid-32rj7774>${author.shortDescription}</p>`} ${showArticleCount && renderTemplate`<div class="author-meta" data-astro-cid-32rj7774> <span class="article-count" data-astro-cid-32rj7774> <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-32rj7774> ${" "} <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" data-astro-cid-32rj7774></path> <polyline points="14,2 14,8 20,8" data-astro-cid-32rj7774></polyline>${" "} <line x1="16" y1="13" x2="8" y2="13" data-astro-cid-32rj7774></line> <line x1="16" y1="17" x2="8" y2="17" data-astro-cid-32rj7774></line>${" "} <line x1="10" y1="9" x2="8" y2="9" data-astro-cid-32rj7774></line> </svg>${" "} ${articleCount} ${articleCount === 1 ? "Recipe" : "Recipes"}${" "} </span> </div>`} </div> </a> </article> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/AuthorCard.astro", void 0);
    $$Astro5 = createAstro("https://localhost:4321");
    $$Index = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro5, $$props, $$slots);
      Astro2.self = $$Index;
      const { env: env3 } = Astro2.locals.runtime;
      const rawAuthors = await getAuthors(env3.DB, { isOnline: true });
      const authors2 = rawAuthors.map(hydrateAuthor);
      const authorArticleCounts = /* @__PURE__ */ new Map();
      for (const author of authors2) {
        const { total } = await getArticles(env3.DB, { authorSlug: author.slug });
        authorArticleCounts.set(author.slug, total);
      }
      const pageTitle = "Our Recipe Creators - Freecipies";
      const pageDescription = "Meet the talented chefs and food enthusiasts behind our delicious recipes. Discover their culinary journeys and cooking expertise.";
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": pageTitle, "description": pageDescription, "data-astro-cid-5ijxez7g": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="authors-page" data-astro-cid-5ijxez7g> <!-- Hero Section --> <section class="hero-section" data-astro-cid-5ijxez7g> <div class="hero-container" data-astro-cid-5ijxez7g> <h1 class="hero-title" data-astro-cid-5ijxez7g>Meet Our Creators</h1> <p class="hero-subtitle" data-astro-cid-5ijxez7g>
Talented chefs and food enthusiasts sharing their passion through
          delicious recipes
</p> </div> </section> <!-- Authors Grid --> <section class="authors-section" data-astro-cid-5ijxez7g> <div class="section-container" data-astro-cid-5ijxez7g> <h2 class="sr-only" data-astro-cid-5ijxez7g>Author list</h2> ${authors2.length > 0 ? renderTemplate`<div class="authors-grid" data-astro-cid-5ijxez7g> ${authors2.map((author) => renderTemplate`${renderComponent($$result2, "AuthorCard", $$AuthorCard, { "author": author, "showArticleCount": true, "articleCount": authorArticleCounts.get(author.slug) || 0, "data-astro-cid-5ijxez7g": true })}`)} </div>` : renderTemplate`<div class="empty-state" data-astro-cid-5ijxez7g> <p data-astro-cid-5ijxez7g>No authors found.</p> </div>`} </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/index.astro", void 0);
    $$file4 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/index.astro";
    $$url4 = "/authors";
    _page46 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Index,
      file: $$file4,
      url: $$url4
    }, Symbol.toStringTag, { value: "Module" }));
    page46 = /* @__PURE__ */ __name(() => _page46, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/chunks/NewsletterWidget_CY-qZb0v.mjs
var MessagePort4, MessageChannelPolyfill3, $$Astro$14, $$PopularRecipes, $$Astro6, $$NewsletterWidget;
var init_NewsletterWidget_CY_qZb0v = __esm({
  ".wrangler/tmp/pages-AQW1MV/chunks/NewsletterWidget_CY-qZb0v.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_hydration_PCOoIFzn();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$14 = createAstro("https://localhost:4321");
    $$PopularRecipes = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$14, $$props, $$slots);
      Astro2.self = $$PopularRecipes;
      const { currentSlug = "", limit = 5 } = Astro2.props;
      let recipes = [];
      try {
        const { runtime } = Astro2.locals;
        if (runtime?.env?.DB) {
          const result = await getArticles(runtime.env.DB, {
            type: "recipe",
            limit: limit + 1
            // Get one extra in case we need to filter out current
          });
          recipes = (result.items || []).filter((r2) => r2.slug !== currentSlug).slice(0, limit);
        }
      } catch (e2) {
        console.error("Error loading popular recipes:", e2);
      }
      return renderTemplate`${maybeRenderHead()}<div class="popular-recipes-widget" data-astro-cid-gjgjpeik> <div class="widget-header" data-astro-cid-gjgjpeik> <span class="header-dot" data-astro-cid-gjgjpeik></span> <h3 data-astro-cid-gjgjpeik>Popular Recipes</h3> </div> ${recipes.length > 0 ? renderTemplate`<div class="recipe-list" data-astro-cid-gjgjpeik> ${recipes.map((recipe) => {
        const thumbnail = extractImage(recipe.imagesJson, "thumbnail", 120);
        const cover = extractImage(recipe.imagesJson, "cover", 120);
        const slotName2 = thumbnail.imageUrl ? "thumbnail" : "cover";
        const selected = thumbnail.imageUrl ? thumbnail : cover;
        const srcSet = getImageSrcSet(recipe.imagesJson, slotName2);
        const sizes = "80px";
        return renderTemplate`<a${addAttribute(`/recipes/${recipe.slug}`, "href")} class="recipe-item" data-astro-cid-gjgjpeik> <div class="recipe-content" data-astro-cid-gjgjpeik> <h4 class="recipe-title" data-astro-cid-gjgjpeik>${recipe.label}</h4> <div class="recipe-meta" data-astro-cid-gjgjpeik> ${recipe.categoryLabel && renderTemplate`<span class="category"${addAttribute(`color: ${recipe.category?.color || "#666"}`, "style")} data-astro-cid-gjgjpeik> ${recipe.categoryLabel} </span>`} ${recipe.recipeJson?.cookTime && renderTemplate`${renderComponent($$result, "Fragment", Fragment, { "data-astro-cid-gjgjpeik": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` <span class="separator" data-astro-cid-gjgjpeik></span> <span class="cook-time" data-astro-cid-gjgjpeik>${recipe.recipeJson.cookTime}</span> `, "default") })}`} </div> </div> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.label, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 80, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 80, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} class="recipe-thumb" loading="lazy" data-astro-cid-gjgjpeik>`} </a>`;
      })} </div>` : renderTemplate`<p class="no-recipes" data-astro-cid-gjgjpeik>More recipes coming soon!</p>`} </div> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/PopularRecipes.astro", void 0);
    $$Astro6 = createAstro("https://localhost:4321");
    $$NewsletterWidget = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro6, $$props, $$slots);
      Astro2.self = $$NewsletterWidget;
      const {
        title: title3 = "Keep Current at All Times",
        subtitle = "Subscribe to our newsletter to get our newest articles instantly!"
      } = Astro2.props;
      return renderTemplate`${maybeRenderHead()}<div class="newsletter-widget" data-astro-cid-e4daz5ew> <div class="widget-icon" data-astro-cid-e4daz5ew> <svg width="40" height="40" viewBox="0 0 24 24" fill="none" data-astro-cid-e4daz5ew> <circle cx="12" cy="12" r="10" fill="#ff6b35" data-astro-cid-e4daz5ew></circle> <path d="M8 12l2 2 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-e4daz5ew></path> </svg> </div> <h3 class="widget-title" data-astro-cid-e4daz5ew>${title3}</h3> <p class="widget-subtitle" data-astro-cid-e4daz5ew>${subtitle}</p> <form class="subscribe-form" action="/api/subscribe" method="POST" data-astro-cid-e4daz5ew> <input type="email" name="email" placeholder="Your email address" required class="email-input" data-astro-cid-e4daz5ew> <button type="submit" class="subscribe-btn" data-astro-cid-e4daz5ew> Subscribe </button> </form> </div>  ${renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/NewsletterWidget.astro?astro&type=script&index=0&lang.ts")}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/NewsletterWidget.astro", void 0);
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/categories/_slug_.astro.mjs
var slug_astro_exports11 = {};
__export(slug_astro_exports11, {
  page: () => page47,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro$6, $$CategoryHeader, $$Astro$5, $$FormattedDate, $$Astro$4, $$ArticleCard, $$Astro$3, $$ArticleGrid, $$Astro$23, $$Pagination, $$Astro$15, $$Breadcrumb, $$Astro7, $$slug2, $$file5, $$url5, _page47, page47;
var init_slug_astro11 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/categories/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_hydration_PCOoIFzn();
    init_NewsletterWidget_CY_qZb0v();
    init_pinterest_schema_eG5oHE2g();
    init_categories_service_BzGDlPlq();
    init_articles_service_DgNeye45();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$6 = createAstro("https://localhost:4321");
    $$CategoryHeader = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$6, $$props, $$slots);
      Astro2.self = $$CategoryHeader;
      const {
        category,
        featuredArticle = null,
        headerStyle = "hero"
      } = Astro2.props;
      const showHeader = headerStyle !== "none";
      const isHeroHeader = headerStyle === "hero";
      const isMinimalHeader = headerStyle === "minimal";
      const hasFeatured = Boolean(featuredArticle && isHeroHeader);
      const getFeaturedImage = /* @__PURE__ */ __name((article) => {
        const cover = extractImage(article.imagesJson, "cover", 1200);
        const thumbnail = extractImage(article.imagesJson, "thumbnail", 1200);
        const slotName2 = cover.imageUrl ? "cover" : "thumbnail";
        const selected = cover.imageUrl ? cover : thumbnail;
        const srcSet = getImageSrcSet(article.imagesJson, slotName2);
        return { selected, srcSet };
      }, "getFeaturedImage");
      const featuredRecipe = featuredArticle?.recipeJson ?? null;
      const featuredImage = featuredArticle ? getFeaturedImage(featuredArticle) : null;
      const featuredSizes = "(max-width: 1024px) 100vw, 50vw";
      return renderTemplate`${showHeader && renderTemplate`${maybeRenderHead()}<section${addAttribute(["category-hero", { "is-minimal": isMinimalHeader }], "class:list")} data-astro-cid-hp6dm2g2><div${addAttribute(["hero-container", { "has-featured": hasFeatured, "is-minimal": isMinimalHeader }], "class:list")} data-astro-cid-hp6dm2g2>${isHeroHeader && featuredArticle && featuredImage && renderTemplate`<a${addAttribute(`/recipes/${featuredArticle.slug}`, "href")} class="featured-card" data-astro-cid-hp6dm2g2><div class="featured-image" data-astro-cid-hp6dm2g2>${(featuredImage.selected.imageUrl || featuredArticle.imageUrl) && renderTemplate`<img${addAttribute(featuredImage.selected.imageUrl || featuredArticle.imageUrl, "src")}${addAttribute(featuredImage.selected.imageAlt || featuredArticle.imageAlt || featuredArticle.label, "alt")}${addAttribute(featuredImage.selected.imageWidth || featuredArticle.imageWidth || 1200, "width")}${addAttribute(featuredImage.selected.imageHeight || featuredArticle.imageHeight || 900, "height")}${addAttribute(featuredImage.srcSet || void 0, "srcset")}${addAttribute(featuredImage.srcSet ? featuredSizes : void 0, "sizes")} loading="eager" data-astro-cid-hp6dm2g2>`}<div class="featured-overlay" data-astro-cid-hp6dm2g2><span class="featured-badge" data-astro-cid-hp6dm2g2>${category.label}</span><h2 class="featured-title" data-astro-cid-hp6dm2g2>${featuredArticle.label}</h2><div class="featured-meta" data-astro-cid-hp6dm2g2>${featuredRecipe?.cookTime && renderTemplate`<span data-astro-cid-hp6dm2g2>${featuredRecipe.cookTime}</span>`}</div></div></div></a>`}<div${addAttribute(["hero-content", { "is-minimal": isMinimalHeader }], "class:list")} data-astro-cid-hp6dm2g2><h1 class="category-title" data-astro-cid-hp6dm2g2>${category.headline || category.label}</h1><p class="category-description" data-astro-cid-hp6dm2g2>${category.shortDescription || category.headline}</p>${category.tldr && renderTemplate`<p class="category-tldr" data-astro-cid-hp6dm2g2>${category.tldr}</p>`}${isHeroHeader && renderTemplate`<a href="#newsletter" class="cta-button" data-astro-cid-hp6dm2g2> Join My Mailing List </a>`}</div></div></section>`}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/CategoryHeader.astro", void 0);
    $$Astro$5 = createAstro("https://localhost:4321");
    $$FormattedDate = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$5, $$props, $$slots);
      Astro2.self = $$FormattedDate;
      const { date } = Astro2.props;
      if (!date) {
        return null;
      }
      const dateObj = typeof date === "string" ? new Date(date) : date;
      if (isNaN(dateObj.getTime())) {
        return null;
      }
      return renderTemplate`${maybeRenderHead()}<time${addAttribute(dateObj.toISOString(), "datetime")}> ${dateObj.toLocaleDateString("en-us", {
        year: "numeric",
        month: "short",
        day: "numeric"
      })} </time>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/FormattedDate.astro", void 0);
    $$Astro$4 = createAstro("https://localhost:4321");
    $$ArticleCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$4, $$props, $$slots);
      Astro2.self = $$ArticleCard;
      const { article, loading = "lazy", cardStyle = "full", layoutMode = "grid" } = Astro2.props;
      const isCompact = cardStyle === "compact";
      const isMinimal = cardStyle === "minimal";
      const isList = layoutMode === "list";
      const thumbnail = extractImage(article.imagesJson, "thumbnail", 720);
      const cover = extractImage(article.imagesJson, "cover", 720);
      const slotName2 = thumbnail.imageUrl ? "thumbnail" : "cover";
      const selected = thumbnail.imageUrl ? thumbnail : cover;
      const srcSet = getImageSrcSet(article.imagesJson, slotName2);
      const sizes = "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 360px";
      const listSizes = "(max-width: 768px) 100vw, 320px";
      const image = {
        url: selected.imageUrl || article.imageUrl || "https://images.unsplash.com/photo-1495521821757-a1efb6729352?w=800&q=80",
        alt: selected.imageAlt || article.imageAlt || article.headline,
        width: selected.imageWidth || article.imageWidth || 800,
        height: selected.imageHeight || article.imageHeight || 600
      };
      const recipe = article.recipeJson ? typeof article.recipeJson === "string" ? JSON.parse(article.recipeJson) : article.recipeJson : null;
      const ratingValue = recipe?.aggregateRating?.ratingValue ?? null;
      const ratingCount = recipe?.aggregateRating?.ratingCount ?? 0;
      const normalizedRating = ratingValue ? Math.max(0, Math.min(5, ratingValue)) : 0;
      const hasRating = ratingValue !== null && ratingCount > 0;
      const authorLabel = article.authorName || article.authorSlug || "Unknown";
      const ratingStars = Array.from({ length: 5 });
      return renderTemplate`${isList ? renderTemplate`${maybeRenderHead()}<article class="recipe-list-card" data-astro-cid-di2nlc57><a${addAttribute(article.route, "href")} class="list-image" data-astro-cid-di2nlc57><img${addAttribute(image.url, "src")}${addAttribute(image.alt || article.headline, "alt")}${addAttribute(image.width, "width")}${addAttribute(image.height, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? listSizes : void 0, "sizes")}${addAttribute(loading, "loading")} class="list-image-img" data-astro-cid-di2nlc57></a><div class="list-content" data-astro-cid-di2nlc57><h3 class="list-title" data-astro-cid-di2nlc57>${article.headline}</h3><div class="list-divider" data-astro-cid-di2nlc57></div><p class="list-excerpt" data-astro-cid-di2nlc57>${article.shortDescription}</p><div class="list-meta" data-astro-cid-di2nlc57><div class="list-meta-left" data-astro-cid-di2nlc57><span class="meta-item" data-astro-cid-di2nlc57><svg viewBox="0 0 24 24" aria-hidden="true" data-astro-cid-di2nlc57><path d="M12 12a4 4 0 1 0-4-4 4 4 0 0 0 4 4zm0 2c-4.4 0-8 2.2-8 5v1h16v-1c0-2.8-3.6-5-8-5z" data-astro-cid-di2nlc57></path></svg><span data-astro-cid-di2nlc57>${authorLabel}</span></span><span class="meta-item" data-astro-cid-di2nlc57><svg viewBox="0 0 24 24" aria-hidden="true" data-astro-cid-di2nlc57><path d="M7 2a1 1 0 0 1 1 1v1h8V3a1 1 0 1 1 2 0v1h1a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1V3a1 1 0 0 1 1-1zm12 8H5v8h14z" data-astro-cid-di2nlc57></path></svg>${renderComponent($$result, "FormattedDate", $$FormattedDate, { "date": article.publishedAt || article.createdAt, "data-astro-cid-di2nlc57": true })}</span></div>${hasRating && renderTemplate`<div class="list-rating" data-astro-cid-di2nlc57><div class="list-stars" data-astro-cid-di2nlc57>${ratingStars.map((_, index2) => renderTemplate`<svg${addAttribute(["rating-star", { "is-active": normalizedRating >= index2 + 1 }], "class:list")} viewBox="0 0 24 24" aria-hidden="true" data-astro-cid-di2nlc57><path d="M12 2l3.09 6.26 6.91 1-5 4.87 1.18 6.87L12 17.77 5.82 21l1.18-6.87-5-4.87 6.91-1L12 2z" data-astro-cid-di2nlc57></path></svg>`)}</div><span class="rating-text" data-astro-cid-di2nlc57>${normalizedRating.toFixed(1)}/5</span></div>`}</div></div></article>` : renderTemplate`<article class="group bg-white dark:bg-gray-800 rounded-xl overflow-hidden shadow-md
hover:shadow-xl transition-all duration-300 transform hover:-translate-y-1 flex
flex-col h-full" data-astro-cid-di2nlc57><a${addAttribute(article.route, "href")} class="block relative aspect-video
overflow-hidden" data-astro-cid-di2nlc57><!-- Image --><img${addAttribute(image.url, "src")}${addAttribute(image.alt || article.headline, "alt")}${addAttribute(image.width, "width")}${addAttribute(image.height, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")}${addAttribute(loading, "loading")} class="w-full h-full object-cover group-hover:scale-110
transition-transform duration-500" data-astro-cid-di2nlc57><!-- Favorite Badge -->${article.isFavorite && renderTemplate`<div class="absolute top-3 right-3 bg-red-600 text-white
px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-1 z-10" data-astro-cid-di2nlc57>${" "}<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" data-astro-cid-di2nlc57>${" "}<path d="M3.172
5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10
17.657l-6.828-6.829a4 4 0 010-5.656z" data-astro-cid-di2nlc57></path>${" "}</svg>${" "}<span data-astro-cid-di2nlc57>Featured</span>${" "}</div>`}<!-- Overlay --><div class="absolute inset-0 bg-gradient-to-t from-black/60
to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300
flex items-end p-4" data-astro-cid-di2nlc57><span class="text-white font-medium" data-astro-cid-di2nlc57>Read More</span></div></a><!-- Info --><div${addAttribute([
        "flex-grow flex flex-col",
        isMinimal || isCompact ? "p-4" : "p-5"
      ], "class:list")} data-astro-cid-di2nlc57><!--
Category --><div${addAttribute([
        "flex items-center gap-2",
        isMinimal || isCompact ? "mb-2" : "mb-3"
      ], "class:list")} data-astro-cid-di2nlc57><span class="text-xs
font-semibold uppercase tracking-wide"${addAttribute(`color: ${article.categoryColor || "#2563eb"}`, "style")} data-astro-cid-di2nlc57>${article.categoryLabel || article.categorySlug?.replace(/-/g, " ") || "Uncategorized"}</span></div><!-- Title --><h3${addAttribute([
        "font-bold text-gray-900 dark:text-white line-clamp-2 group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors",
        isMinimal || isCompact ? "text-lg mb-1" : "text-xl mb-2"
      ], "class:list")} data-astro-cid-di2nlc57>${article.headline}</h3><!-- Description -->${!isMinimal && renderTemplate`<p${addAttribute([
        "text-gray-600 dark:text-gray-300 line-clamp-2 flex-grow",
        isCompact ? "text-xs mb-3" : "text-sm mb-4"
      ], "class:list")} data-astro-cid-di2nlc57>${article.shortDescription}</p>`}<!-- Meta Info -->${!isMinimal && renderTemplate`<div${addAttribute([
        "flex items-center justify-between text-gray-500 dark:text-gray-400 border-t border-gray-200 dark:border-gray-700 pt-4 mt-auto",
        isCompact ? "text-xs" : "text-sm"
      ], "class:list")} data-astro-cid-di2nlc57><div class="flex items-center gap-1" data-astro-cid-di2nlc57><span data-astro-cid-di2nlc57>${new Date(
        article.publishedAt || article.createdAt || (/* @__PURE__ */ new Date()).toISOString()
      ).toLocaleDateString()}</span></div>${recipe && renderTemplate`<div class="flex items-center gap-1" data-astro-cid-di2nlc57>${" "}<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-di2nlc57>${" "}<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0
0118 0z" data-astro-cid-di2nlc57></path>${" "}</svg>${" "}<span data-astro-cid-di2nlc57>${recipe?.prepTime || "N/A"}</span>${" "}</div>`}</div>`}</div></article>`}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/ArticleCard.astro", void 0);
    $$Astro$3 = createAstro("https://localhost:4321");
    $$ArticleGrid = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$3, $$props, $$slots);
      Astro2.self = $$ArticleGrid;
      const { articles: articles2, layoutMode = "grid", cardStyle = "full" } = Astro2.props;
      const layoutClass = layoutMode === "list" ? "recipe-list" : layoutMode === "masonry" ? "recipe-masonry" : "recipe-grid";
      return renderTemplate`${maybeRenderHead()}<div${addAttribute([layoutClass, `card-style-${cardStyle}`], "class:list")} data-astro-cid-synqgp74> ${articles2.map((article) => renderTemplate`${renderComponent($$result, "ArticleCard", $$ArticleCard, { "article": article, "cardStyle": cardStyle, "layoutMode": layoutMode, "data-astro-cid-synqgp74": true })}`)} </div> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/ArticleGrid.astro", void 0);
    $$Astro$23 = createAstro("https://localhost:4321");
    $$Pagination = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$23, $$props, $$slots);
      Astro2.self = $$Pagination;
      const { currentPage, totalPages, baseUrl, preserveParams = {} } = Astro2.props;
      const buildPageUrl = /* @__PURE__ */ __name((page62) => {
        const params = new URLSearchParams(preserveParams);
        if (page62 > 1) params.set("page", String(page62));
        const queryString = params.toString();
        return queryString ? `${baseUrl}?${queryString}` : baseUrl;
      }, "buildPageUrl");
      const getPageNumbers = /* @__PURE__ */ __name(() => {
        const pages2 = [];
        const showPages = 5;
        if (totalPages <= showPages + 2) {
          for (let i2 = 1; i2 <= totalPages; i2++) pages2.push(i2);
        } else {
          pages2.push(1);
          if (currentPage > 3) pages2.push("ellipsis");
          const start = Math.max(2, currentPage - 1);
          const end = Math.min(totalPages - 1, currentPage + 1);
          for (let i2 = start; i2 <= end; i2++) pages2.push(i2);
          if (currentPage < totalPages - 2) pages2.push("ellipsis");
          pages2.push(totalPages);
        }
        return pages2;
      }, "getPageNumbers");
      const pages = getPageNumbers();
      const hasPrev = currentPage > 1;
      const hasNext = currentPage < totalPages;
      return renderTemplate`${totalPages > 1 && renderTemplate`${maybeRenderHead()}<nav class="pagination" aria-label="Pagination" data-astro-cid-d776pwuy><a${addAttribute(hasPrev ? buildPageUrl(currentPage - 1) : void 0, "href")}${addAttribute(["pagination-btn", "prev", { disabled: !hasPrev }], "class:list")}${addAttribute(!hasPrev, "aria-disabled")} data-astro-cid-d776pwuy><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-d776pwuy><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" data-astro-cid-d776pwuy></path></svg><span class="sr-only" data-astro-cid-d776pwuy>Previous</span></a><div class="pagination-pages" data-astro-cid-d776pwuy>${pages.map((page62) => page62 === "ellipsis" ? renderTemplate`<span class="pagination-ellipsis" data-astro-cid-d776pwuy></span>` : renderTemplate`<a${addAttribute(buildPageUrl(page62), "href")}${addAttribute(["pagination-page", { active: page62 === currentPage }], "class:list")}${addAttribute(page62 === currentPage ? "page" : void 0, "aria-current")} data-astro-cid-d776pwuy>${page62}</a>`)}</div><a${addAttribute(hasNext ? buildPageUrl(currentPage + 1) : void 0, "href")}${addAttribute(["pagination-btn", "next", { disabled: !hasNext }], "class:list")}${addAttribute(!hasNext, "aria-disabled")} data-astro-cid-d776pwuy><span class="sr-only" data-astro-cid-d776pwuy>Next</span><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-d776pwuy><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" data-astro-cid-d776pwuy></path></svg></a></nav>`}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Pagination.astro", void 0);
    $$Astro$15 = createAstro("https://localhost:4321");
    $$Breadcrumb = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$15, $$props, $$slots);
      Astro2.self = $$Breadcrumb;
      const { items } = Astro2.props;
      return renderTemplate`${maybeRenderHead()}<nav class="breadcrumb" aria-label="Fil d'ariane" data-astro-cid-qaanghzh> <ol class="breadcrumb-list" data-astro-cid-qaanghzh> <li class="breadcrumb-item" data-astro-cid-qaanghzh> <a href="/" class="breadcrumb-link" data-astro-cid-qaanghzh> <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-qaanghzh> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" data-astro-cid-qaanghzh></path> </svg> <span class="sr-only" data-astro-cid-qaanghzh>Accueil</span> </a> </li> ${items.map((item, index2) => renderTemplate`<li class="breadcrumb-item" data-astro-cid-qaanghzh> <svg class="breadcrumb-separator" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-astro-cid-qaanghzh> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" data-astro-cid-qaanghzh></path> </svg> ${item.href && index2 < items.length - 1 ? renderTemplate`<a${addAttribute(item.href, "href")} class="breadcrumb-link" data-astro-cid-qaanghzh>${item.label}</a>` : renderTemplate`<span class="breadcrumb-current" aria-current="page" data-astro-cid-qaanghzh>${item.label}</span>`} </li>`)} </ol> </nav> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Breadcrumb.astro", void 0);
    $$Astro7 = createAstro("https://localhost:4321");
    $$slug2 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro7, $$props, $$slots);
      Astro2.self = $$slug2;
      const { slug } = Astro2.params;
      const { env: env3 } = Astro2.locals.runtime;
      if (!slug) {
        return Astro2.redirect("/404");
      }
      const url = new URL(Astro2.request.url);
      const currentPage = Math.max(1, parseInt(url.searchParams.get("page") || "1", 10));
      const allRawCategories = await getCategories(env3.DB, { isOnline: true });
      const allCategories = hydrateCategories(allRawCategories);
      const category = allCategories.find((c) => c.slug === slug);
      if (!category) {
        return Astro2.redirect("/404");
      }
      const perPage = category.numEntriesPerPage || 12;
      const sortBy = category.sortBy || "publishedAt";
      const sortOrder = category.sortOrder || "desc";
      const layoutMode = category.layoutMode || "grid";
      const showPagination = category.showPagination !== false;
      const showBreadcrumb = category.showBreadcrumb !== false;
      const showSidebar = category.showSidebar !== false;
      const headerStyle = category.headerStyle || "hero";
      const cardStyle = category.cardStyle || "full";
      const showHeader = headerStyle !== "none";
      const offset = (currentPage - 1) * perPage;
      const { items: articles2, total } = await getArticles(env3.DB, {
        categorySlug: slug,
        isOnline: true,
        limit: perPage,
        offset,
        sortBy,
        sortOrder
      });
      const totalPages = Math.ceil(total / perPage);
      const featuredArticle = currentPage === 1 && headerStyle === "hero" ? articles2[0] : null;
      const gridArticles = featuredArticle ? articles2.slice(1) : articles2;
      const baseUrl = `/categories/${slug}`;
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": category.metaTitle || category.headline || category.label, "description": category.metaDescription || category.shortDescription, "data-astro-cid-dqg6fwsj": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate`  ${renderComponent($$result2, "CategoryHeader", $$CategoryHeader, { "category": category, "featuredArticle": featuredArticle, "headerStyle": headerStyle, "data-astro-cid-dqg6fwsj": true })}  ${maybeRenderHead()}<section${addAttribute(["recipes-section", { "no-hero": !showHeader }], "class:list")} data-astro-cid-dqg6fwsj> <div class="container" data-astro-cid-dqg6fwsj> ${showBreadcrumb && renderTemplate`${renderComponent($$result2, "Breadcrumb", $$Breadcrumb, { "items": [
        { label: "Cat\xE9gories", href: "/categories" },
        { label: category.label }
      ], "data-astro-cid-dqg6fwsj": true })}`} <div class="section-header" data-astro-cid-dqg6fwsj> <h2 class="section-title" data-astro-cid-dqg6fwsj>${category.collectionTitle || `${category.label} Recipes`}</h2> <span class="recipe-count" data-astro-cid-dqg6fwsj>${total} recette${total > 1 ? "s" : ""}</span> </div> <div${addAttribute(["recipes-layout", { "with-sidebar": showSidebar }], "class:list")} data-astro-cid-dqg6fwsj> <div class="recipes-main" data-astro-cid-dqg6fwsj> ${gridArticles.length > 0 ? renderTemplate`${renderComponent($$result2, "ArticleGrid", $$ArticleGrid, { "articles": gridArticles, "layoutMode": layoutMode, "cardStyle": cardStyle, "data-astro-cid-dqg6fwsj": true })}` : articles2.length === 0 ? renderTemplate`<div class="empty-state" data-astro-cid-dqg6fwsj> <p data-astro-cid-dqg6fwsj>No recipes found in this category yet.</p> </div>` : null} ${showPagination && totalPages > 1 && renderTemplate`${renderComponent($$result2, "Pagination", $$Pagination, { "currentPage": currentPage, "totalPages": totalPages, "baseUrl": baseUrl, "data-astro-cid-dqg6fwsj": true })}`} </div> ${showSidebar && renderTemplate`<aside class="recipes-sidebar" data-astro-cid-dqg6fwsj> ${renderComponent($$result2, "PopularRecipes", $$PopularRecipes, { "limit": 5, "data-astro-cid-dqg6fwsj": true })} ${renderComponent($$result2, "NewsletterWidget", $$NewsletterWidget, { "data-astro-cid-dqg6fwsj": true })} </aside>`} </div> </div> </section>  <section class="category-nav-section" data-astro-cid-dqg6fwsj> <div class="container" data-astro-cid-dqg6fwsj> <h2 class="nav-title" data-astro-cid-dqg6fwsj>Explore More Categories</h2> <div class="category-chips" data-astro-cid-dqg6fwsj> ${allCategories.filter((cat) => cat.slug !== slug).slice(0, 6).map((cat) => renderTemplate`<a${addAttribute(`/categories/${cat.slug}`, "href")} class="category-chip" data-astro-cid-dqg6fwsj> <div class="chip-svg" data-astro-cid-dqg6fwsj> ${cat.iconSvg ? renderTemplate`${renderComponent($$result2, "Fragment", Fragment, {}, { "default": /* @__PURE__ */ __name(async ($$result3) => renderTemplate`${unescapeHTML(cat.iconSvg)}`, "default") })}` : renderTemplate`<div class="chip-placeholder"${addAttribute(`background-color: ${cat.color || "#ff3366"}`, "style")} data-astro-cid-dqg6fwsj> <span data-astro-cid-dqg6fwsj>${cat.label.charAt(0)}</span> </div>`} </div> <span class="chip-label" data-astro-cid-dqg6fwsj>${cat.label}</span> </a>`)} </div> </div> </section>  <section class="newsletter-section" id="newsletter" data-astro-cid-dqg6fwsj> <div class="newsletter-bar" data-astro-cid-dqg6fwsj> <div class="newsletter-content" data-astro-cid-dqg6fwsj> <div class="newsletter-icon" data-astro-cid-dqg6fwsj> <svg width="48" height="48" viewBox="0 0 24 24" fill="none" data-astro-cid-dqg6fwsj> <circle cx="12" cy="12" r="10" fill="#ff6b35" data-astro-cid-dqg6fwsj></circle> <path d="M8 12l2 2 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-dqg6fwsj></path> </svg> </div> <div class="newsletter-text" data-astro-cid-dqg6fwsj> <h3 data-astro-cid-dqg6fwsj>Keep Current at All Times</h3> <p data-astro-cid-dqg6fwsj>Subscribe Now for Immediate Updates on My Latest Recipes!</p> </div> </div> <form class="newsletter-form" data-astro-cid-dqg6fwsj> <input type="email" placeholder="Your email address" required data-astro-cid-dqg6fwsj> <label class="terms-checkbox" data-astro-cid-dqg6fwsj> <input type="checkbox" required data-astro-cid-dqg6fwsj> <span data-astro-cid-dqg6fwsj>I have read and agree to the terms & conditions</span> </label> <button type="submit" data-astro-cid-dqg6fwsj>Sign Up Now</button> </form> </div> </section> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/[slug].astro", void 0);
    $$file5 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/[slug].astro";
    $$url5 = "/categories/[slug]";
    _page47 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$slug2,
      file: $$file5,
      url: $$url5
    }, Symbol.toStringTag, { value: "Module" }));
    page47 = /* @__PURE__ */ __name(() => _page47, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/categories.astro.mjs
var categories_astro_exports2 = {};
__export(categories_astro_exports2, {
  page: () => page48,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro$16, $$CategoryCard, $$Astro8, $$Index2, $$file6, $$url6, _page48, page48;
var init_categories_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/categories.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_hydration_PCOoIFzn();
    init_pinterest_schema_eG5oHE2g();
    init_categories_service_BzGDlPlq();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$16 = createAstro("https://localhost:4321");
    $$CategoryCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$16, $$props, $$slots);
      Astro2.self = $$CategoryCard;
      const { category } = Astro2.props;
      const cover = extractImage(category.imagesJson, "cover", 1200);
      const thumbnail = extractImage(category.imagesJson, "thumbnail", 720);
      const slotName2 = cover.imageUrl ? "cover" : "thumbnail";
      const selected = cover.imageUrl ? cover : thumbnail;
      const srcSet = getImageSrcSet(category.imagesJson, slotName2);
      const sizes = "(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 480px";
      const image = {
        url: selected.imageUrl || category.imageUrl || "https://images.unsplash.com/photo-1556910103-1c02745a30bf?w=800&q=80",
        // Remote placeholder
        alt: selected.imageAlt || category.imageAlt || category.label,
        width: selected.imageWidth || category.imageWidth || 800,
        height: selected.imageHeight || category.imageHeight || 600
      };
      return renderTemplate`${maybeRenderHead()}<article class="group relative bg-white dark:bg-gray-800 rounded-xl overflow-hidden transform hover:-translate-y-1"> <a${addAttribute(`/categories/${category.slug}`, "href")} class="group relative block aspect-video rounded-2xl overflow-hidden shadow-md hover:shadow-xl transition-all duration-300"> <!-- Category Image with Overlay --> <div class="relative h-full overflow-hidden"> <img${addAttribute(image.url, "src")}${addAttribute(image.alt || category.label, "alt")}${addAttribute(image.width, "width")}${addAttribute(image.height, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" class="absolute inset-0 w-full h-full object-cover transition-transform duration-700 group-hover:scale-110"> <!-- Gradient Overlay --> <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div> <!-- Content Overlay --> <div class="absolute inset-0 flex flex-col justify-end p-6"> <h3 class="text-2xl font-bold mb-2 group-hover:text-blue-300 transition-colors"${addAttribute(`color: ${category.color || "#ffffff"};`, "style")}> ${category.label} </h3> <p class="text-gray-200 text-sm line-clamp-2 mb-3"> ${category.shortDescription} </p> <!-- View Collection Button --> <div class="inline-flex items-center gap-2 text-white font-semibold bg-black/55 px-3 py-1.5 rounded-full"> <span>View Collection</span> <svg class="w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path> </svg> </div> </div> <!-- Favorite Badge --> ${category.isFeatured && renderTemplate`<div class="absolute top-4 right-4 bg-blue-700 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-1"> <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"> <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path> </svg> <span>Popular</span> </div>`} </div> </a> </article>`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/CategoryCard.astro", void 0);
    $$Astro8 = createAstro("https://localhost:4321");
    $$Index2 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro8, $$props, $$slots);
      Astro2.self = $$Index2;
      const { env: env3 } = Astro2.locals.runtime;
      const rawCategories = await getCategories(env3.DB, { isOnline: true });
      const categories2 = rawCategories.map(hydrateCategory);
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": "All Categories", "description": "Browse all recipe categories" }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<div class="container mx-auto px-4 py-12"> <h1 class="text-4xl font-bold text-center mb-12">Browse Categories</h1> <h2 class="sr-only">Category list</h2> <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8"> ${categories2.map((category) => renderTemplate`${renderComponent($$result2, "CategoryCard", $$CategoryCard, { "category": category })}`)} </div> </div> `, "default") })}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/index.astro", void 0);
    $$file6 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/index.astro";
    $$url6 = "/categories";
    _page48 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Index2,
      file: $$file6,
      url: $$url6
    }, Symbol.toStringTag, { value: "Module" }));
    page48 = /* @__PURE__ */ __name(() => _page48, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/contact.astro.mjs
var contact_astro_exports = {};
__export(contact_astro_exports, {
  page: () => page49,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Contact, $$file7, $$url7, _page49, page49;
var init_contact_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/contact.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Contact = createComponent(async ($$result, $$props, $$slots) => {
      const siteTitle = "Contact Us - Freecipies";
      const siteDescription = "Get in touch with the Freecipies team. We'd love to hear from you!";
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": siteTitle, "description": siteDescription, "data-astro-cid-uw5kdbxl": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="contact-page" data-astro-cid-uw5kdbxl> <!-- Hero Section --> <section class="contact-hero" data-astro-cid-uw5kdbxl> <div class="container" data-astro-cid-uw5kdbxl> <h1 class="page-title" data-astro-cid-uw5kdbxl> <span class="title-dot" data-astro-cid-uw5kdbxl></span>
Get In Touch
</h1> <p class="page-subtitle" data-astro-cid-uw5kdbxl>
Have a question, suggestion, or just want to say hello? We'd
                    love to hear from you!
</p> </div> </section> <!-- Contact Content --> <section class="contact-content" data-astro-cid-uw5kdbxl> <div class="container" data-astro-cid-uw5kdbxl> <div class="contact-grid" data-astro-cid-uw5kdbxl> <!-- Contact Form --> <div class="contact-form-wrapper" data-astro-cid-uw5kdbxl> <h2 data-astro-cid-uw5kdbxl>Send Us a Message</h2> <form id="contactForm" class="contact-form" data-astro-cid-uw5kdbxl> <div class="form-group" data-astro-cid-uw5kdbxl> <label for="name" data-astro-cid-uw5kdbxl>Your Name</label> <input type="text" id="name" name="name" placeholder="John Doe" required data-astro-cid-uw5kdbxl> </div> <div class="form-group" data-astro-cid-uw5kdbxl> <label for="email" data-astro-cid-uw5kdbxl>Email Address</label> <input type="email" id="email" name="email" placeholder="john@example.com" required data-astro-cid-uw5kdbxl> </div> <div class="form-group" data-astro-cid-uw5kdbxl> <label for="subject" data-astro-cid-uw5kdbxl>Subject</label> <select id="subject" name="subject" required data-astro-cid-uw5kdbxl> <option value="" data-astro-cid-uw5kdbxl>Select a topic...</option> <option value="general" data-astro-cid-uw5kdbxl>General Inquiry</option> <option value="recipe" data-astro-cid-uw5kdbxl>Recipe Question</option> <option value="collaboration" data-astro-cid-uw5kdbxl>Collaboration / Partnership</option> <option value="feedback" data-astro-cid-uw5kdbxl>Feedback / Suggestions</option> <option value="bug" data-astro-cid-uw5kdbxl>Report an Issue</option> </select> </div> <div class="form-group" data-astro-cid-uw5kdbxl> <label for="message" data-astro-cid-uw5kdbxl>Your Message</label> <textarea id="message" name="message" rows="6" placeholder="Tell us what's on your mind..." required data-astro-cid-uw5kdbxl></textarea> </div> <button type="submit" class="submit-btn" data-astro-cid-uw5kdbxl> <span class="btn-text" data-astro-cid-uw5kdbxl>Send Message</span> <span class="btn-icon" data-astro-cid-uw5kdbxl></span> </button> </form> <div id="formStatus" class="form-status" data-astro-cid-uw5kdbxl></div> </div> <!-- Contact Info --> <div class="contact-info" data-astro-cid-uw5kdbxl> <div class="info-card" data-astro-cid-uw5kdbxl> <div class="info-icon" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-uw5kdbxl> <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-astro-cid-uw5kdbxl></path> <polyline points="22,6 12,13 2,6" data-astro-cid-uw5kdbxl></polyline> </svg> </div> <h3 data-astro-cid-uw5kdbxl>Email Us</h3> <p data-astro-cid-uw5kdbxl>For general inquiries and support</p> <a href="mailto:hello@recipes-saas.com" data-astro-cid-uw5kdbxl>hello@recipes-saas.com</a> </div> <div class="info-card" data-astro-cid-uw5kdbxl> <div class="info-icon" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-uw5kdbxl> <circle cx="12" cy="12" r="10" data-astro-cid-uw5kdbxl></circle> <polyline points="12,6 12,12 16,14" data-astro-cid-uw5kdbxl></polyline> </svg> </div> <h3 data-astro-cid-uw5kdbxl>Response Time</h3> <p data-astro-cid-uw5kdbxl>We typically respond within</p> <span class="highlight" data-astro-cid-uw5kdbxl>24-48 hours</span> </div> <div class="info-card" data-astro-cid-uw5kdbxl> <div class="info-icon" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-uw5kdbxl> <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z" data-astro-cid-uw5kdbxl></path> </svg> </div> <h3 data-astro-cid-uw5kdbxl>Follow Us</h3> <p data-astro-cid-uw5kdbxl>Stay connected on social media</p> <div class="social-links" data-astro-cid-uw5kdbxl> <a href="#" aria-label="Pinterest" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="currentColor" data-astro-cid-uw5kdbxl> <path d="M12 0a12 12 0 0 0-4.37 23.17c-.1-.94-.2-2.4.04-3.44l1.4-5.96s-.35-.71-.35-1.76c0-1.64.95-2.87 2.14-2.87 1 0 1.49.76 1.49 1.67 0 1.02-.65 2.54-.99 3.95-.28 1.18.59 2.15 1.76 2.15 2.11 0 3.74-2.23 3.74-5.44 0-2.85-2.05-4.84-4.97-4.84-3.39 0-5.38 2.54-5.38 5.17 0 1.02.39 2.12.88 2.72a.35.35 0 0 1 .08.34l-.33 1.34c-.05.22-.17.27-.4.16-1.49-.69-2.42-2.87-2.42-4.62 0-3.76 2.73-7.21 7.88-7.21 4.14 0 7.35 2.95 7.35 6.88 0 4.11-2.59 7.42-6.19 7.42-1.21 0-2.35-.63-2.74-1.37l-.74 2.83c-.27 1.04-1 2.35-1.49 3.14A12 12 0 1 0 12 0z" data-astro-cid-uw5kdbxl></path> </svg> </a> <a href="#" aria-label="Instagram" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-uw5kdbxl> <rect x="2" y="2" width="20" height="20" rx="5" ry="5" data-astro-cid-uw5kdbxl></rect> <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z" data-astro-cid-uw5kdbxl></path> <line x1="17.5" y1="6.5" x2="17.51" y2="6.5" data-astro-cid-uw5kdbxl></line> </svg> </a> <a href="#" aria-label="Facebook" data-astro-cid-uw5kdbxl> <svg viewBox="0 0 24 24" fill="currentColor" data-astro-cid-uw5kdbxl> <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z" data-astro-cid-uw5kdbxl></path> </svg> </a> </div> </div> <div class="info-card highlight-card" data-astro-cid-uw5kdbxl> <h3 data-astro-cid-uw5kdbxl> Recipe Submissions</h3> <p data-astro-cid-uw5kdbxl>
Want to share your recipe with our community?
                                We're always looking for talented home cooks!
</p> <a href="mailto:recipes@recipes-saas.com" class="link-btn" data-astro-cid-uw5kdbxl>Submit a Recipe</a> </div> </div> </div> </div> </section> <!-- FAQ Section --> <section class="faq-section" data-astro-cid-uw5kdbxl> <div class="container" data-astro-cid-uw5kdbxl> <h2 data-astro-cid-uw5kdbxl>Frequently Asked Questions</h2> <div class="faq-grid" data-astro-cid-uw5kdbxl> <div class="faq-item" data-astro-cid-uw5kdbxl> <h3 data-astro-cid-uw5kdbxl>Can I submit my own recipes?</h3> <p data-astro-cid-uw5kdbxl>
Absolutely! We love featuring recipes from our
                            community. Send us your recipe at
                            recipes@recipes-saas.com and we'll review it for
                            publication.
</p> </div> <div class="faq-item" data-astro-cid-uw5kdbxl> <h3 data-astro-cid-uw5kdbxl>How do I print a recipe?</h3> <p data-astro-cid-uw5kdbxl>
On any recipe page, you'll find a print button in
                            the sharing section. This will give you a clean,
                            printer-friendly version.
</p> </div> <div class="faq-item" data-astro-cid-uw5kdbxl> <h3 data-astro-cid-uw5kdbxl>Can I save recipes to my collection?</h3> <p data-astro-cid-uw5kdbxl>
We're working on this feature! In the meantime, you
                            can bookmark pages or subscribe to our newsletter
                            for weekly recipe roundups.
</p> </div> <div class="faq-item" data-astro-cid-uw5kdbxl> <h3 data-astro-cid-uw5kdbxl>Do you offer nutritional information?</h3> <p data-astro-cid-uw5kdbxl>
Yes! Most of our recipes include estimated
                            nutritional information. You'll find it at the
                            bottom of each recipe card.
</p> </div> </div> </div> </section> </main> `, "default") })}  ${renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro?astro&type=script&index=0&lang.ts")}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro", void 0);
    $$file7 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro";
    $$url7 = "/contact";
    _page49 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Contact,
      file: $$file7,
      url: $$url7
    }, Symbol.toStringTag, { value: "Module" }));
    page49 = /* @__PURE__ */ __name(() => _page49, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/faqs.astro.mjs
var faqs_astro_exports = {};
__export(faqs_astro_exports, {
  page: () => page50,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Faqs, $$file8, $$url8, _page50, page50;
var init_faqs_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/faqs.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Faqs = createComponent(($$result, $$props, $$slots) => {
      const siteTitle = "Frequently Asked Questions - Freecipies";
      const siteDescription = "Find answers to common questions about Freecipies, our recipes, and how to use our platform.";
      const faqCategories = [
        {
          title: "General Questions",
          icon: "\u{1F4A1}",
          faqs: [
            {
              question: "What is Freecipies?",
              answer: "Freecipies is a free recipe platform where you can discover delicious, easy-to-follow recipes for every skill level. From quick weeknight dinners to impressive desserts, we make cooking fun and accessible for everyone."
            },
            {
              question: "Is Freecipies really free?",
              answer: "Yes! All our recipes are completely free to access. No subscriptions, no hidden fees. We believe great recipes should be available to everyone."
            },
            {
              question: "How often do you add new recipes?",
              answer: "We add new recipes weekly! Subscribe to our newsletter to get notified when new recipes are published."
            },
            {
              question: "Do I need to create an account?",
              answer: "No account is required to browse and use our recipes. We're working on optional accounts for saving favorites - stay tuned!"
            }
          ]
        },
        {
          title: "Using Recipes",
          icon: "\u{1F373}",
          faqs: [
            {
              question: "How do I print a recipe?",
              answer: "On any recipe page, you'll find a print button in the sharing section near the top. This creates a clean, printer-friendly version without ads or extra content."
            },
            {
              question: "Can I adjust the serving size?",
              answer: "Currently, our recipes show fixed serving sizes. We recommend using a recipe calculator to adjust quantities. This feature is on our roadmap for future updates!"
            },
            {
              question: "Are nutritional values accurate?",
              answer: "Nutritional information is estimated and may vary based on specific ingredients and brands used. For precise dietary needs, we recommend calculating with your exact ingredients."
            },
            {
              question: "What if I'm missing an ingredient?",
              answer: "Many recipes include substitution tips in the notes section. If not, feel free to contact us - we're happy to suggest alternatives!"
            }
          ]
        },
        {
          title: "Dietary & Allergies",
          icon: "\u{1F957}",
          faqs: [
            {
              question: "How do I find vegan or vegetarian recipes?",
              answer: "Use our filter system on the recipes page. Click on tags like 'Vegan' or 'Vegetarian' to see only those recipes. You can also browse our dedicated category pages."
            },
            {
              question: "Do you have gluten-free recipes?",
              answer: "Yes! We have a growing collection of gluten-free recipes. Look for the 'Gluten-Free' tag on recipe cards or filter by this tag on the recipes page."
            },
            {
              question: "Are allergens listed in recipes?",
              answer: "We try to highlight common allergens in our ingredient lists, but always check ingredient labels if you have severe allergies. When in doubt, consult with a healthcare professional."
            }
          ]
        },
        {
          title: "Submissions & Collaboration",
          icon: "\u2728",
          faqs: [
            {
              question: "Can I submit my own recipe?",
              answer: "Absolutely! We love featuring community recipes. Send your recipe to recipes@recipes-saas.com with photos, ingredients, and instructions. Our team will review and may feature it on the site."
            },
            {
              question: "Do you work with brands or sponsors?",
              answer: "We're open to collaborations that align with our values. Contact us at hello@recipes-saas.com with partnership inquiries."
            },
            {
              question: "Can I share your recipes on social media?",
              answer: "Yes! We encourage sharing. Please link back to the original recipe and credit Freecipies. You can use our built-in share buttons for easy sharing."
            },
            {
              question: "How do I report an error in a recipe?",
              answer: "If you spot an error, please let us know via our contact page or email. We appreciate your help in keeping our recipes accurate!"
            }
          ]
        },
        {
          title: "Technical Support",
          icon: "\u{1F527}",
          faqs: [
            {
              question: "The website isn't loading properly. What should I do?",
              answer: "Try refreshing the page or clearing your browser cache. If the problem persists, try a different browser. Still having issues? Contact us with details about your browser and device."
            },
            {
              question: "How do I subscribe to the newsletter?",
              answer: "You can subscribe using the newsletter signup form at the bottom of most pages. Just enter your email and click subscribe!"
            },
            {
              question: "How can I unsubscribe from emails?",
              answer: "Every email we send includes an unsubscribe link at the bottom. Click it to immediately unsubscribe."
            }
          ]
        }
      ];
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": siteTitle, "description": siteDescription, "data-astro-cid-tkjepyjs": true }, { "default": /* @__PURE__ */ __name(($$result2) => renderTemplate` ${maybeRenderHead()}<main class="faq-page" data-astro-cid-tkjepyjs> <!-- Hero Section --> <section class="faq-hero" data-astro-cid-tkjepyjs> <div class="container" data-astro-cid-tkjepyjs> <h1 class="page-title" data-astro-cid-tkjepyjs> <span class="title-dot" data-astro-cid-tkjepyjs></span>
Frequently Asked Questions
</h1> <p class="page-subtitle" data-astro-cid-tkjepyjs>
Everything you need to know about Freecipies. Can't find
                    your answer? <a href="/contact" data-astro-cid-tkjepyjs>Contact us</a> </p> </div> </section> <!-- Quick Jump Navigation --> <section class="quick-nav" data-astro-cid-tkjepyjs> <div class="container" data-astro-cid-tkjepyjs> <div class="nav-pills" data-astro-cid-tkjepyjs> ${faqCategories.map((category, index2) => renderTemplate`<a${addAttribute(`#category-${index2}`, "href")} class="nav-pill" data-astro-cid-tkjepyjs> <span class="pill-icon" data-astro-cid-tkjepyjs>${category.icon}</span> <span data-astro-cid-tkjepyjs>${category.title}</span> </a>`)} </div> </div> </section> <!-- FAQ Content --> <section class="faq-content" data-astro-cid-tkjepyjs> <div class="container" data-astro-cid-tkjepyjs> ${faqCategories.map((category, catIndex) => renderTemplate`<div class="faq-category"${addAttribute(`category-${catIndex}`, "id")} data-astro-cid-tkjepyjs> <h2 class="category-title" data-astro-cid-tkjepyjs> <span class="category-icon" data-astro-cid-tkjepyjs> ${category.icon} </span> ${category.title} </h2> <div class="faq-list" data-astro-cid-tkjepyjs> ${category.faqs.map((faq, faqIndex) => renderTemplate`<details class="faq-item" data-astro-cid-tkjepyjs> <summary class="faq-question" data-astro-cid-tkjepyjs> <span class="question-text" data-astro-cid-tkjepyjs> ${faq.question} </span> <span class="toggle-icon" data-astro-cid-tkjepyjs> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-tkjepyjs> <path d="M6 9l6 6 6-6" data-astro-cid-tkjepyjs></path> </svg> </span> </summary> <div class="faq-answer" data-astro-cid-tkjepyjs> <p data-astro-cid-tkjepyjs>${faq.answer}</p> </div> </details>`)} </div> </div>`)} </div> </section> <!-- Still Have Questions --> <section class="contact-cta" data-astro-cid-tkjepyjs> <div class="container" data-astro-cid-tkjepyjs> <div class="cta-card" data-astro-cid-tkjepyjs> <h2 data-astro-cid-tkjepyjs>Still Have Questions?</h2> <p data-astro-cid-tkjepyjs>
We're here to help! Reach out to our team and we'll get
                        back to you within 24-48 hours.
</p> <a href="/contact" class="cta-btn" data-astro-cid-tkjepyjs>Contact Us</a> </div> </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/faqs.astro", void 0);
    $$file8 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/faqs.astro";
    $$url8 = "/faqs";
    _page50 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Faqs,
      file: $$file8,
      url: $$url8
    }, Symbol.toStringTag, { value: "Module" }));
    page50 = /* @__PURE__ */ __name(() => _page50, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/feed/_slug_.astro.mjs
var slug_astro_exports12 = {};
__export(slug_astro_exports12, {
  page: () => page51,
  renderers: () => renderers
});
function escapeXml(str) {
  if (!str) return "";
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var MessagePort4, MessageChannelPolyfill3, prerender38, GET33, _page51, page51;
var init_slug_astro12 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/feed/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_categories_service_BzGDlPlq();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender38 = false;
    GET33 = /* @__PURE__ */ __name(async ({ params, locals, site }) => {
      const env3 = locals.runtime.env;
      const categorySlug = params.slug;
      const baseUrl = site?.toString().replace(/\/$/, "") || "https://recipes-saas.com";
      if (!categorySlug) {
        return new Response("Category not specified", { status: 400 });
      }
      let category = null;
      let recipes = [];
      try {
        category = await getCategoryBySlug(env3.DB, categorySlug);
        if (!category) {
          return new Response("Category not found", { status: 404 });
        }
        const result = await getArticles(env3.DB, {
          type: "recipe",
          categorySlug,
          limit: 1e3
        });
        recipes = result.items;
      } catch (error5) {
        console.error("Error fetching category feed:", error5);
        return new Response("Error generating feed", { status: 500 });
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const getAbsoluteImageUrl = /* @__PURE__ */ __name((url) => {
        if (!url) return "";
        if (url.startsWith("http://") || url.startsWith("https://")) return url;
        return `${baseUrl}${url.startsWith("/") ? "" : "/"}${url}`;
      }, "getAbsoluteImageUrl");
      const getRecipeImageUrl = /* @__PURE__ */ __name((recipe) => {
        const cover = extractImage(recipe.imagesJson, "cover", 1200);
        const thumbnail = extractImage(recipe.imagesJson, "thumbnail", 1200);
        return cover.imageUrl || thumbnail.imageUrl || recipe.imageUrl || "";
      }, "getRecipeImageUrl");
      const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1">
    <url>
        <loc>${baseUrl}/categories/${categorySlug}</loc>
        <lastmod>${today}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>
    </url>
    ${recipes.map((recipe) => {
        const imageUrl = getRecipeImageUrl(recipe);
        return `
    <url>
        <loc>${baseUrl}/recipes/${recipe.slug}</loc>
        <lastmod>${recipe.updatedAt ? new Date(recipe.updatedAt).toISOString().split("T")[0] : today}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.7</priority>${imageUrl ? `
        <image:image>
            <image:loc>${escapeXml(getAbsoluteImageUrl(imageUrl))}</image:loc>
            <image:title>${escapeXml(recipe.headline)}</image:title>
        </image:image>` : ""}
    </url>`;
      }).join("")}
</urlset>`;
      return new Response(sitemap.trim(), {
        status: 200,
        headers: {
          "Content-Type": "application/xml",
          "Cache-Control": "public, max-age=3600"
        }
      });
    }, "GET");
    __name(escapeXml, "escapeXml");
    _page51 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET33,
      prerender: prerender38
    }, Symbol.toStringTag, { value: "Module" }));
    page51 = /* @__PURE__ */ __name(() => _page51, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/images/_---key_.astro.mjs
var key_astro_exports = {};
__export(key_astro_exports, {
  page: () => page52,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, prerender39, GET34, _page52, page52;
var init_key_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/images/_---key_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_r2_service_BByT9ix6();
    init_pinterest_schema_eG5oHE2g();
    init_templates_schema_DMbF8Dv3();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender39 = false;
    GET34 = /* @__PURE__ */ __name(async ({ params, locals, request }) => {
      try {
        const key = params.key;
        if (!key) {
          return new Response("Image key required", { status: 400 });
        }
        const env3 = locals.runtime.env;
        const bucket = env3.IMAGES;
        const ifNoneMatch = request.headers.get("If-None-Match");
        const r2Key = key;
        const object = await getImage2(bucket, r2Key);
        if (!object) {
          return new Response("Image not found", { status: 404 });
        }
        const etag = object.httpEtag;
        if (ifNoneMatch && ifNoneMatch === etag) {
          return new Response(null, { status: 304 });
        }
        const headers = new Headers();
        if (object.httpMetadata) {
          if (object.httpMetadata.contentType) {
            headers.set("Content-Type", object.httpMetadata.contentType);
          }
          if (object.httpMetadata.contentDisposition) {
            headers.set("Content-Disposition", object.httpMetadata.contentDisposition);
          }
          if (object.httpMetadata.cacheControl) {
            headers.set("Cache-Control", object.httpMetadata.cacheControl);
          } else {
            headers.set("Cache-Control", "public, max-age=31536000, immutable");
          }
          if (object.httpMetadata.contentEncoding) {
            headers.set("Content-Encoding", object.httpMetadata.contentEncoding);
          }
          if (object.httpMetadata.contentLanguage) {
            headers.set("Content-Language", object.httpMetadata.contentLanguage);
          }
        }
        headers.set("etag", etag);
        headers.set("Accept-Ranges", "bytes");
        return new Response(object.body, {
          headers
        });
      } catch (error5) {
        console.error("Error serving image:", error5);
        return new Response(`Internal Server Error: ${error5 instanceof Error ? error5.message : String(error5)}`, { status: 500 });
      }
    }, "GET");
    _page52 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET34,
      prerender: prerender39
    }, Symbol.toStringTag, { value: "Module" }));
    page52 = /* @__PURE__ */ __name(() => _page52, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/recipes/_slug_.astro.mjs
var slug_astro_exports13 = {};
__export(slug_astro_exports13, {
  page: () => page53,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro$42, $$SocialShareBar, $$Astro$32, $$RecipeAuthorCard, __freeze$1, __defProp$1, __template$1, _a$1, $$Astro$24, $$RecipeLayout, __freeze, __defProp2, __template, _a, _b, _c, $$Astro$17, $$SEO, $$Astro9, $$slug3, $$file9, $$url9, _page53, page53;
var init_slug_astro13 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/recipes/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_NewsletterWidget_CY_qZb0v();
    init_hydration_PCOoIFzn();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_authors_service_DDYOeshw();
    init_categories_service_BzGDlPlq();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$42 = createAstro("https://localhost:4321");
    $$SocialShareBar = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$42, $$props, $$slots);
      Astro2.self = $$SocialShareBar;
      const {
        url = Astro2.url.href,
        title: title3 = "",
        readingTime = "5 Min Read"
      } = Astro2.props;
      const encodedUrl = encodeURIComponent(url);
      const encodedTitle = encodeURIComponent(title3);
      return renderTemplate`${maybeRenderHead()}<div class="social-share-bar" data-astro-cid-iee254wo> <div class="share-buttons" data-astro-cid-iee254wo> <a${addAttribute(`https://www.facebook.com/sharer/sharer.php?u=${encodedUrl}`, "href")} target="_blank" rel="noopener noreferrer" class="share-btn facebook" aria-label="Share on Facebook" data-astro-cid-iee254wo> <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-iee254wo> <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z" data-astro-cid-iee254wo></path> </svg> </a> <a${addAttribute(`https://twitter.com/intent/tweet?url=${encodedUrl}&text=${encodedTitle}`, "href")} target="_blank" rel="noopener noreferrer" class="share-btn twitter" aria-label="Share on X/Twitter" data-astro-cid-iee254wo> <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-iee254wo> <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" data-astro-cid-iee254wo></path> </svg> </a> <button class="share-btn copy-link"${addAttribute(url, "data-url")} aria-label="Copy link" data-astro-cid-iee254wo> <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-iee254wo> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" data-astro-cid-iee254wo></path> <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" data-astro-cid-iee254wo></path> </svg> </button> <button class="share-btn print" onclick="window.print()" aria-label="Print recipe" data-astro-cid-iee254wo> <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-iee254wo> <polyline points="6 9 6 2 18 2 18 9" data-astro-cid-iee254wo></polyline> <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" data-astro-cid-iee254wo></path> <rect x="6" y="14" width="12" height="8" data-astro-cid-iee254wo></rect> </svg> </button> <span class="share-btn more" data-astro-cid-iee254wo> <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-iee254wo> <circle cx="12" cy="12" r="2" data-astro-cid-iee254wo></circle> <circle cx="5" cy="12" r="2" data-astro-cid-iee254wo></circle> <circle cx="19" cy="12" r="2" data-astro-cid-iee254wo></circle> </svg> </span> </div> <div class="reading-time" data-astro-cid-iee254wo> <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-iee254wo> <circle cx="12" cy="12" r="10" data-astro-cid-iee254wo></circle> <polyline points="12 6 12 12 16 14" data-astro-cid-iee254wo></polyline> </svg> <span data-astro-cid-iee254wo>${readingTime}</span> </div> </div>  ${renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/SocialShareBar.astro?astro&type=script&index=0&lang.ts")}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/SocialShareBar.astro", void 0);
    $$Astro$32 = createAstro("https://localhost:4321");
    $$RecipeAuthorCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$32, $$props, $$slots);
      Astro2.self = $$RecipeAuthorCard;
      const {
        authorName = "Freecipies Team",
        authorImage,
        authorRole = "Blogger",
        lastUpdated,
        viewCount
      } = Astro2.props;
      const hasValidImage = authorImage && authorImage.trim() !== "";
      let formattedDate = "";
      if (lastUpdated) {
        const date = typeof lastUpdated === "string" ? new Date(lastUpdated) : lastUpdated;
        if (!isNaN(date.getTime())) {
          formattedDate = date.toLocaleDateString("en-US", {
            month: "long",
            day: "numeric",
            year: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true
          });
        }
      }
      const initials = authorName.split(" ").map((word) => word.charAt(0)).join("").substring(0, 2).toUpperCase();
      return renderTemplate`${maybeRenderHead()}<div class="recipe-author-card" data-astro-cid-sgl2jmkl> <a${addAttribute(`/authors/${authorName.toLowerCase().replace(/\s+/g, "-")}`, "href")} class="author-avatar" data-astro-cid-sgl2jmkl> ${hasValidImage ? renderTemplate`<img${addAttribute(authorImage, "src")}${addAttribute(authorName, "alt")} width="48" height="48" loading="lazy" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" data-astro-cid-sgl2jmkl>
            <div class="avatar-fallback" style="display: none;" data-astro-cid-sgl2jmkl> ${initials} </div>` : renderTemplate`<div class="avatar-fallback" data-astro-cid-sgl2jmkl> ${initials} </div>`} </a> <div class="author-info" data-astro-cid-sgl2jmkl> <div class="author-meta" data-astro-cid-sgl2jmkl> <span class="by-text" data-astro-cid-sgl2jmkl>By</span> <a${addAttribute(`/authors/${authorName.toLowerCase().replace(/\s+/g, "-")}`, "href")} class="author-name" data-astro-cid-sgl2jmkl> ${authorName} </a> <span class="separator" data-astro-cid-sgl2jmkl>-</span> <span class="author-role" data-astro-cid-sgl2jmkl>${authorRole}</span> </div> ${formattedDate && renderTemplate`<div class="last-updated" data-astro-cid-sgl2jmkl>
Last updated: ${formattedDate} ${viewCount !== void 0 && viewCount !== null && renderTemplate`${renderComponent($$result, "Fragment", Fragment, { "data-astro-cid-sgl2jmkl": true }, { "default": /* @__PURE__ */ __name(($$result2) => renderTemplate` <span class="separator" data-astro-cid-sgl2jmkl></span> <span class="view-count" data-astro-cid-sgl2jmkl>${new Intl.NumberFormat("en-US", { notation: "compact", compactDisplay: "short" }).format(viewCount)} views</span> `, "default") })}`} </div>`} </div> </div> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/RecipeAuthorCard.astro", void 0);
    __freeze$1 = Object.freeze;
    __defProp$1 = Object.defineProperty;
    __template$1 = /* @__PURE__ */ __name((cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", { value: __freeze$1(raw || cooked.slice()) })), "__template$1");
    $$Astro$24 = createAstro("https://localhost:4321");
    $$RecipeLayout = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$24, $$props, $$slots);
      Astro2.self = $$RecipeLayout;
      const { recipe, author, category } = Astro2.props;
      const categoryColor = category?.color || "#ff6600";
      const recipeJson = recipe.recipeJson ? typeof recipe.recipeJson === "string" ? JSON.parse(recipe.recipeJson) : recipe.recipeJson : null;
      const wordCount = [
        recipe.shortDescription,
        recipe.tldr,
        recipe.introduction,
        JSON.stringify(recipeJson?.ingredients || []),
        JSON.stringify(recipeJson?.instructions || [])
      ].filter(Boolean).join(" ").split(/\s+/).length;
      const readingTime = Math.max(5, Math.ceil(wordCount / 200));
      const heroCover = extractImage(recipe.imagesJson, "cover", 1200);
      const heroThumb = extractImage(recipe.imagesJson, "thumbnail", 1200);
      const coverSrcSet = getImageSrcSet(recipe.imagesJson, "cover");
      const thumbSrcSet = getImageSrcSet(recipe.imagesJson, "thumbnail");
      const useCover = heroCover.imageUrl && (coverSrcSet || !heroThumb.imageUrl);
      const heroImage = useCover ? heroCover : heroThumb;
      const heroSrcSet = useCover ? coverSrcSet : thumbSrcSet;
      const heroSizes = "(max-width: 768px) 100vw, 800px";
      const authorAvatar = author?.imagesJson ? extractImage(author.imagesJson, "avatar", 96) : {};
      const authorImage = authorAvatar.imageUrl || author?.imageUrl;
      return renderTemplate(_a$1 || (_a$1 = __template$1(["", " <script>(function(){", '\n  // Simple view tracking\n  const trackView = async () => {\n    try {\n      await fetch(`/api/views/${slug}`, { method: "POST" });\n    } catch (e) {\n      // Ignore errors silently (e.g. ad blockers)\n    }\n  };\n\n  // Run when the page is ready\n  if (document.readyState === "complete") {\n    trackView();\n  } else {\n    window.addEventListener("load", trackView);\n  }\n})();<\/script>  ', ""], ["", " <script>(function(){", '\n  // Simple view tracking\n  const trackView = async () => {\n    try {\n      await fetch(\\`/api/views/\\${slug}\\`, { method: "POST" });\n    } catch (e) {\n      // Ignore errors silently (e.g. ad blockers)\n    }\n  };\n\n  // Run when the page is ready\n  if (document.readyState === "complete") {\n    trackView();\n  } else {\n    window.addEventListener("load", trackView);\n  }\n})();<\/script>  ', ""])), renderComponent($$result, "Layout", $$Layout, { "title": recipe.metaTitle || recipe.label, "description": recipe.metaDescription || recipe.shortDescription, "image": heroImage.imageUrl || recipe.imageUrl || void 0, "data-astro-cid-763jalmv": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate`  ${maybeRenderHead()}<article class="recipe-page" data-astro-cid-763jalmv> <div class="recipe-container" data-astro-cid-763jalmv> <!-- Main Content Column --> <div class="main-content" data-astro-cid-763jalmv> <!-- Category Badge --> ${recipe.categoryLabel && renderTemplate`<a${addAttribute(`/categories/${recipe.categorySlug}`, "href")} class="category-badge"${addAttribute(`--badge-color: ${categoryColor};`, "style")} data-astro-cid-763jalmv> ${recipe.categoryLabel} </a>`} <!-- Recipe Title --> <h1 class="recipe-title" data-astro-cid-763jalmv>${recipe.label}</h1> <!-- Short Description --> ${recipe.shortDescription && renderTemplate`<p class="recipe-description" data-astro-cid-763jalmv>${recipe.shortDescription}</p>`} <!-- Social Share Bar --> ${renderComponent($$result2, "SocialShareBar", $$SocialShareBar, { "title": recipe.label, "readingTime": `${readingTime} Min Read`, "data-astro-cid-763jalmv": true })} <!-- Author Card --> ${renderComponent($$result2, "RecipeAuthorCard", $$RecipeAuthorCard, { "authorName": author?.name || recipe.authorName, "authorImage": authorImage || void 0, "authorRole": author?.job || "Blogger", "lastUpdated": recipe.publishedAt || void 0, "viewCount": recipe.viewCount, "data-astro-cid-763jalmv": true })} <!-- Disclosure Notice --> <div class="disclosure-notice" data-astro-cid-763jalmv> <strong data-astro-cid-763jalmv>Disclosure:</strong> This website may contain affiliate links, which
          means I may earn a commission if you click on the link and make a purchase.
          I only recommend products or services that I personally use and believe
          will add value to my readers. Your support is appreciated!
</div> <!-- Hero Image --> ${(heroImage.imageUrl || recipe.imageUrl) && renderTemplate`<div class="hero-image" data-astro-cid-763jalmv> <img${addAttribute(heroImage.imageUrl || recipe.imageUrl, "src")}${addAttribute(heroImage.imageAlt || recipe.imageAlt || recipe.label, "alt")}${addAttribute(heroImage.imageWidth || recipe.imageWidth, "width")}${addAttribute(heroImage.imageHeight || recipe.imageHeight, "height")}${addAttribute(heroSrcSet || void 0, "srcset")}${addAttribute(heroSrcSet ? heroSizes : void 0, "sizes")} loading="eager" fetchpriority="high" data-astro-cid-763jalmv> </div>`} <!-- Recipe Meta Info Pills --> ${recipeJson && renderTemplate`<div class="recipe-meta-pills" data-astro-cid-763jalmv> ${recipeJson.prepTime && renderTemplate`<div class="meta-pill" data-astro-cid-763jalmv> <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-763jalmv> <circle cx="12" cy="12" r="10" data-astro-cid-763jalmv></circle> <polyline points="12 6 12 12 16 14" data-astro-cid-763jalmv></polyline> </svg> <span class="label" data-astro-cid-763jalmv>Prep</span> <span class="value" data-astro-cid-763jalmv>${recipeJson.prepTime}</span> </div>`} ${recipeJson.cookTime && renderTemplate`<div class="meta-pill" data-astro-cid-763jalmv> <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-763jalmv> <path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83" data-astro-cid-763jalmv></path> </svg> <span class="label" data-astro-cid-763jalmv>Cook</span> <span class="value" data-astro-cid-763jalmv>${recipeJson.cookTime}</span> </div>`} ${recipeJson.servings && renderTemplate`<div class="meta-pill" data-astro-cid-763jalmv> <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-763jalmv> <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" data-astro-cid-763jalmv></path> <circle cx="9" cy="7" r="4" data-astro-cid-763jalmv></circle> <path d="M23 21v-2a4 4 0 0 0-3-3.87" data-astro-cid-763jalmv></path> <path d="M16 3.13a4 4 0 0 1 0 7.75" data-astro-cid-763jalmv></path> </svg> <span class="label" data-astro-cid-763jalmv>Servings</span> <span class="value" data-astro-cid-763jalmv>${recipeJson.servings}</span> </div>`} ${recipeJson.difficulty && renderTemplate`<div class="meta-pill" data-astro-cid-763jalmv> <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-763jalmv> <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" data-astro-cid-763jalmv></polygon> </svg> <span class="label" data-astro-cid-763jalmv>Level</span> <span class="value" data-astro-cid-763jalmv>${recipeJson.difficulty}</span> </div>`} </div>`} <!-- TLDR / Quick Overview --> ${recipe.tldr && renderTemplate`<section class="content-section tldr-section" data-astro-cid-763jalmv> <h2 data-astro-cid-763jalmv>Quick Overview</h2> <div class="prose" data-astro-cid-763jalmv>${unescapeHTML(recipe.tldr)}</div> </section>`} <!-- Ingredients --> ${recipeJson?.ingredients && Array.isArray(recipeJson.ingredients) && recipeJson.ingredients.length > 0 && renderTemplate`<section class="content-section ingredients-section" data-astro-cid-763jalmv> <h2 data-astro-cid-763jalmv>Ingredients</h2> ${recipeJson.ingredients.map(
        (group4) => renderTemplate`<div class="ingredient-group" data-astro-cid-763jalmv> ${group4.group && renderTemplate`<h3 data-astro-cid-763jalmv>${group4.group}</h3>`} <ul class="ingredient-list" data-astro-cid-763jalmv> ${group4.items && Array.isArray(group4.items) && group4.items.map((item) => renderTemplate`<li data-astro-cid-763jalmv> <span class="checkbox" data-astro-cid-763jalmv></span> <span data-astro-cid-763jalmv>${item}</span> </li>`)} </ul> </div>`
      )} </section>`} <!-- Instructions --> ${recipeJson?.instructions && Array.isArray(recipeJson.instructions) && recipeJson.instructions.length > 0 && renderTemplate`<section class="content-section instructions-section" data-astro-cid-763jalmv> <h2 data-astro-cid-763jalmv>Instructions</h2> ${recipeJson.instructions.map(
        (group4) => renderTemplate`<div class="instruction-group" data-astro-cid-763jalmv> ${group4.group && renderTemplate`<h3 data-astro-cid-763jalmv>${group4.group}</h3>`} <ol class="instruction-list" data-astro-cid-763jalmv> ${group4.steps && Array.isArray(group4.steps) && group4.steps.map((step, index2) => renderTemplate`<li data-astro-cid-763jalmv> <span class="step-number" data-astro-cid-763jalmv>${index2 + 1}</span> <p data-astro-cid-763jalmv>${step}</p> </li>`)} </ol> </div>`
      )} </section>`} <!-- Nutrition Facts (inline for mobile) --> ${recipeJson?.nutrition && Object.keys(recipeJson.nutrition).length > 0 && renderTemplate`<section class="content-section nutrition-section mobile-only" data-astro-cid-763jalmv> <h2 data-astro-cid-763jalmv>Nutrition Facts</h2> <div class="nutrition-grid" data-astro-cid-763jalmv> ${Object.entries(recipeJson.nutrition).map(([key, value]) => renderTemplate`<div class="nutrition-item" data-astro-cid-763jalmv> <span class="nutrition-value" data-astro-cid-763jalmv>${value}</span> <span class="nutrition-label" data-astro-cid-763jalmv>${key}</span> </div>`)} </div> </section>`} <!-- FAQs --> ${recipe.faqsJson && Array.isArray(recipe.faqsJson) && recipe.faqsJson.length > 0 && renderTemplate`<section class="content-section faqs-section" data-astro-cid-763jalmv> <h2 data-astro-cid-763jalmv>Frequently Asked Questions</h2> <div class="faq-list" data-astro-cid-763jalmv> ${recipe.faqsJson.map((faq) => renderTemplate`<details class="faq-item" data-astro-cid-763jalmv> <summary data-astro-cid-763jalmv>${faq.question}</summary> <div class="faq-answer" data-astro-cid-763jalmv>${unescapeHTML(faq.answer)}</div> </details>`)} </div> </section>`} </div> <!-- Sidebar --> <aside class="sidebar" data-astro-cid-763jalmv> <div class="sidebar-sticky" data-astro-cid-763jalmv> <!-- Nutrition Facts (desktop) --> ${recipeJson?.nutrition && Object.keys(recipeJson.nutrition).length > 0 && renderTemplate`<div class="sidebar-widget nutrition-widget desktop-only" data-astro-cid-763jalmv> <h3 data-astro-cid-763jalmv>Nutrition Facts</h3> <div class="nutrition-list" data-astro-cid-763jalmv> ${Object.entries(recipeJson.nutrition).map(
        ([key, value]) => renderTemplate`<div class="nutrition-row" data-astro-cid-763jalmv> <span class="nutrition-key" data-astro-cid-763jalmv>${key}</span> <span class="nutrition-val" data-astro-cid-763jalmv>${value}</span> </div>`
      )} </div> </div>`} <!-- Popular Recipes --> ${renderComponent($$result2, "PopularRecipes", $$PopularRecipes, { "currentSlug": recipe.slug, "limit": 5, "data-astro-cid-763jalmv": true })} <!-- Newsletter Widget --> ${renderComponent($$result2, "NewsletterWidget", $$NewsletterWidget, { "data-astro-cid-763jalmv": true })} </div> </aside> </div> </article> `, "default"), "head": /* @__PURE__ */ __name(async ($$result2) => renderTemplate`${renderSlot($$result2, $$slots["head"])}${(heroImage.imageUrl || recipe.imageUrl) && renderTemplate`<link rel="preload" as="image"${addAttribute(heroImage.imageUrl || recipe.imageUrl, "href")}>`}`, "head") }), defineScriptVars({ slug: recipe.slug }), renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/layouts/RecipeLayout.astro?astro&type=script&index=0&lang.ts"));
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/layouts/RecipeLayout.astro", void 0);
    __freeze = Object.freeze;
    __defProp2 = Object.defineProperty;
    __template = /* @__PURE__ */ __name((cooked, raw) => __freeze(__defProp2(cooked, "raw", { value: __freeze(cooked.slice()) })), "__template");
    $$Astro$17 = createAstro("https://localhost:4321");
    $$SEO = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$17, $$props, $$slots);
      Astro2.self = $$SEO;
      const {
        title: title3,
        description,
        canonical,
        image,
        imageAlt,
        type = "website",
        publishedTime,
        modifiedTime,
        author,
        recipe
      } = Astro2.props;
      const siteUrl = Astro2.site?.toString() || Astro2.url.origin;
      const canonicalURL = canonical || new URL(Astro2.url.pathname, siteUrl).toString();
      const imageUrl = image ? new URL(image, siteUrl).toString() : `${siteUrl}/og-image.jpg`;
      const recipeImageUrl = recipe?.image ? new URL(recipe.image, siteUrl).toString() : imageUrl;
      return renderTemplate`<!-- Structured data only; BaseHead handles standard meta tags. --><!-- Schema.org JSON-LD -->${type === "website" && renderTemplate(_a || (_a = __template(['<script type="application/ld+json">', "<\/script>"])), unescapeHTML(JSON.stringify({
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Freecipies",
        "description": description,
        "url": siteUrl,
        "potentialAction": {
          "@type": "SearchAction",
          "target": `${siteUrl}/search?q={search_term_string}`,
          "query-input": "required name=search_term_string"
        }
      })))}${type === "article" && author && renderTemplate(_b || (_b = __template(['<script type="application/ld+json">', "<\/script>"])), unescapeHTML(JSON.stringify({
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": title3,
        "description": description,
        "image": imageUrl,
        "datePublished": publishedTime,
        "dateModified": modifiedTime || publishedTime,
        "author": {
          "@type": "Person",
          "name": author.name,
          "url": author.url
        },
        "publisher": {
          "@type": "Organization",
          "name": "Freecipies",
          "logo": {
            "@type": "ImageObject",
            "url": `${siteUrl}/logo.png`
          }
        },
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": canonicalURL
        }
      })))}${type === "recipe" && recipe && renderTemplate(_c || (_c = __template(['<script type="application/ld+json">', "<\/script>"])), unescapeHTML(JSON.stringify({
        "@context": "https://schema.org",
        "@type": "Recipe",
        "name": recipe.name,
        "description": recipe.description,
        "image": recipeImageUrl,
        "author": author ? {
          "@type": "Person",
          "name": author.name
        } : void 0,
        "datePublished": publishedTime,
        "dateModified": modifiedTime || publishedTime,
        "prepTime": recipe.prepTime,
        "cookTime": recipe.cookTime,
        "totalTime": recipe.totalTime,
        "recipeYield": recipe.recipeYield,
        "recipeCategory": recipe.recipeCategory,
        "recipeCuisine": recipe.recipeCuisine,
        "keywords": recipe.keywords?.join(", "),
        "recipeIngredient": recipe.recipeIngredient,
        "recipeInstructions": recipe.recipeInstructions?.map((step, index2) => ({
          "@type": "HowToStep",
          "position": index2 + 1,
          "text": typeof step === "string" ? step : step.text
        })),
        "nutrition": recipe.nutrition ? {
          "@type": "NutritionInformation",
          "calories": recipe.nutrition.calories ? `${recipe.nutrition.calories} kcal` : void 0,
          "proteinContent": recipe.nutrition.proteinContent ? `${recipe.nutrition.proteinContent} g` : void 0,
          "fatContent": recipe.nutrition.fatContent ? `${recipe.nutrition.fatContent} g` : void 0,
          "carbohydrateContent": recipe.nutrition.carbohydrateContent ? `${recipe.nutrition.carbohydrateContent} g` : void 0,
          "sugarContent": recipe.nutrition.sugarContent ? `${recipe.nutrition.sugarContent} g` : void 0,
          "fiberContent": recipe.nutrition.fiberContent ? `${recipe.nutrition.fiberContent} g` : void 0,
          "sodiumContent": recipe.nutrition.sodiumContent ? `${recipe.nutrition.sodiumContent} mg` : void 0
        } : void 0,
        "aggregateRating": recipe.aggregateRating ? {
          "@type": "AggregateRating",
          "ratingValue": recipe.aggregateRating.ratingValue,
          "ratingCount": recipe.aggregateRating.reviewCount ?? recipe.aggregateRating.ratingCount
        } : void 0
      })))}<!-- Breadcrumb Schema -->${renderSlot($$result, $$slots["breadcrumb-schema"])}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/SEO.astro", void 0);
    $$Astro9 = createAstro("https://localhost:4321");
    $$slug3 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro9, $$props, $$slots);
      Astro2.self = $$slug3;
      const { slug } = Astro2.params;
      const { runtime } = Astro2.locals;
      if (!slug) {
        return new Response("Slug is missing", { status: 400 });
      }
      let author = null;
      let category = null;
      const recipe = await getArticleBySlug(runtime.env.DB, slug, "recipe");
      if (!recipe) {
        return new Response("Recipe not found", { status: 404 });
      }
      const recipeDetails = recipe.recipeJson || void 0;
      const heroCover = extractImage(recipe.imagesJson, "cover", 1200);
      const heroThumb = extractImage(recipe.imagesJson, "thumbnail", 1200);
      const coverSrcSet = getImageSrcSet(recipe.imagesJson, "cover");
      getImageSrcSet(recipe.imagesJson, "thumbnail");
      const useCover = heroCover.imageUrl && (coverSrcSet || !heroThumb.imageUrl);
      const heroImage = useCover ? heroCover : heroThumb;
      if (recipe.authorId) {
        author = await getAuthorById(runtime.env.DB, recipe.authorId);
      }
      if (recipe.categoryId) {
        category = await getCategoryById(runtime.env.DB, recipe.categoryId);
      }
      const pageTitle = recipe.metaTitle || recipe.headline;
      const pageDescription = recipe.metaDescription || recipe.shortDescription;
      return renderTemplate`${renderComponent($$result, "RecipeLayout", $$RecipeLayout, { "recipe": recipe, "author": author, "category": category }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate`   ${maybeRenderHead()}<article> <h1 class="text-4xl font-bold mb-4">${recipe.headline}</h1> <p class="text-lg text-gray-600 mb-8">${recipe.shortDescription}</p> ${recipeDetails ? renderTemplate`<div class="prose prose-lg max-w-none"> <div class="mb-8"> <h2 class="text-2xl font-semibold border-b pb-2 mb-4">
Ingredients
</h2> <ul> ${recipeDetails.ingredients?.map((group4) => renderTemplate`${renderComponent($$result2, "Fragment", Fragment, {}, { "default": /* @__PURE__ */ __name(async ($$result3) => renderTemplate`${group4.group_title && renderTemplate`<h3 class="font-bold mt-2">${group4.group_title}</h3>`}${group4.items && group4.items.map((item) => renderTemplate`<li> ${item.name} ${item.amount ? ` - ${item.amount}${item.unit || ""}` : ""} </li>`)}`, "default") })}`)} </ul> </div> <div> <h2 class="text-2xl font-semibold border-b pb-2 mb-4">
Instructions
</h2> <ol> ${recipeDetails.instructions?.map((group4) => renderTemplate`${renderComponent($$result2, "Fragment", Fragment, {}, { "default": /* @__PURE__ */ __name(async ($$result3) => renderTemplate`${group4.section_title && renderTemplate`<h3 class="font-bold mt-2">${group4.section_title}</h3>`}${group4.steps && group4.steps.map((step) => renderTemplate`<li>${step.text}</li>`)}`, "default") })}`)} </ol> </div> </div>` : renderTemplate`<p class="text-center text-gray-500 italic mt-12">
This article does not contain detailed recipe information.
</p>`} </article> `, "default"), "head": /* @__PURE__ */ __name(async ($$result2) => renderTemplate`${renderComponent($$result2, "SEO", $$SEO, { "slot": "head", "title": pageTitle, "description": pageDescription, "type": "recipe", "publishedTime": recipe.publishedAt || void 0, "author": { name: author?.name || "Freecipies Team" }, "image": heroImage.imageUrl || recipe.imageUrl || "", "imageAlt": heroImage.imageAlt || recipe.imageAlt || void 0, "recipe": recipeDetails ? {
        name: recipe.headline,
        description: recipe.shortDescription,
        image: heroImage.imageUrl || recipe.imageUrl || "",
        prepTime: recipeDetails.prepTime ? String(recipeDetails.prepTime) : void 0,
        cookTime: recipeDetails.cookTime ? String(recipeDetails.cookTime) : void 0,
        totalTime: void 0,
        recipeYield: recipeDetails.servings ? String(recipeDetails.servings) : void 0,
        recipeCategory: category?.label,
        recipeIngredient: recipeDetails.ingredients?.flatMap(
          (i2) => i2.items.map((item) => item.name)
        ) || [],
        recipeInstructions: recipeDetails.instructions?.flatMap(
          (i2) => i2.steps.map((step) => step.text)
        ) || []
      } : void 0 })}`, "head") })}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/[slug].astro", void 0);
    $$file9 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/[slug].astro";
    $$url9 = "/recipes/[slug]";
    _page53 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$slug3,
      file: $$file9,
      url: $$url9
    }, Symbol.toStringTag, { value: "Module" }));
    page53 = /* @__PURE__ */ __name(() => _page53, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/recipes.astro.mjs
var recipes_astro_exports2 = {};
__export(recipes_astro_exports2, {
  page: () => page54,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro10, prerender40, $$Index3, $$file10, $$url10, _page54, page54;
var init_recipes_astro3 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/recipes.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_categories_service_BzGDlPlq();
    init_tags_service_DE4uyghe();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro10 = createAstro("https://localhost:4321");
    prerender40 = false;
    $$Index3 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro10, $$props, $$slots);
      Astro2.self = $$Index3;
      const { env: env3 } = Astro2.locals.runtime;
      const url = Astro2.url;
      const categoryFilter = url.searchParams.get("category") || "";
      const tagFilter = url.searchParams.get("tag") || "";
      const page62 = parseInt(url.searchParams.get("page") || "1");
      const limit = 12;
      const offset = (page62 - 1) * limit;
      let recipes = [];
      let totalRecipes = 0;
      let categories2 = [];
      let tags2 = [];
      try {
        const result = await getArticles(env3.DB, {
          type: "recipe",
          categorySlug: categoryFilter || void 0,
          tagSlug: tagFilter || void 0,
          limit,
          offset
        });
        recipes = hydrateArticles(result.items);
        totalRecipes = result.total;
        const rawCategories = await getCategories(env3.DB, { isOnline: true });
        const rawTags = await getTags(env3.DB);
        categories2 = hydrateCategories(rawCategories);
        tags2 = hydrateTags(rawTags);
      } catch (error5) {
        console.error("Error fetching recipes:", error5);
      }
      const totalPages = Math.ceil(totalRecipes / limit);
      const buildFilterUrl = /* @__PURE__ */ __name((newCategory, newTag, newPage) => {
        const params = new URLSearchParams();
        const cat = newCategory !== void 0 ? newCategory : categoryFilter;
        const tag2 = newTag !== void 0 ? newTag : tagFilter;
        const p = newPage !== void 0 ? newPage : page62;
        if (cat) params.set("category", cat);
        if (tag2) params.set("tag", tag2);
        if (p > 1) params.set("page", p.toString());
        const queryString = params.toString();
        return queryString ? `/recipes?${queryString}` : "/recipes";
      }, "buildFilterUrl");
      const getRecipeImage = /* @__PURE__ */ __name((recipe, targetWidth, prefer = "cover") => {
        const cover = extractImage(recipe.imagesJson, "cover", targetWidth);
        const thumbnail = extractImage(recipe.imagesJson, "thumbnail", targetWidth);
        const slotName2 = prefer === "cover" ? cover.imageUrl ? "cover" : "thumbnail" : thumbnail.imageUrl ? "thumbnail" : "cover";
        const selected = slotName2 === "cover" ? cover : thumbnail;
        const srcSet = getImageSrcSet(recipe.imagesJson, slotName2);
        return { selected, srcSet };
      }, "getRecipeImage");
      const parseHexColor = /* @__PURE__ */ __name((value) => {
        if (!value) return null;
        const trimmed = value.trim();
        const match = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
        if (!/^[0-9a-fA-F]+$/.test(match)) return null;
        if (match.length === 3 || match.length === 4) {
          const [r2, g, b] = match.slice(0, 3).split("");
          return `${r2}${r2}${g}${g}${b}${b}`;
        }
        if (match.length === 6 || match.length === 8) {
          return match.slice(0, 6);
        }
        return null;
      }, "parseHexColor");
      const getBadgeTextColor = /* @__PURE__ */ __name((background) => {
        const hex = parseHexColor(background);
        if (!hex) return "#ffffff";
        const r2 = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        const yiq = (r2 * 299 + g * 587 + b * 114) / 1e3;
        return yiq >= 170 ? "#111111" : "#ffffff";
      }, "getBadgeTextColor");
      const getBadgeColors = /* @__PURE__ */ __name((color) => {
        const badgeColor = color && color.trim() ? color.trim() : "#ff3366";
        const badgeText = getBadgeTextColor(badgeColor);
        return { badgeColor, badgeText };
      }, "getBadgeColors");
      const siteTitle = categoryFilter ? `${categories2.find((c) => c.slug === categoryFilter)?.label || "Category"} Recipes - Freecipies` : "All Recipes - Freecipies";
      const siteDescription = "Browse all our delicious and easy-to-follow recipes. Filter by category or tag.";
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": siteTitle, "description": siteDescription, "data-astro-cid-ufwbdbbi": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="recipes-page" data-astro-cid-ufwbdbbi> <!-- Page Header --> <section class="page-header" data-astro-cid-ufwbdbbi> <div class="container" data-astro-cid-ufwbdbbi> <h1 class="page-title" data-astro-cid-ufwbdbbi> <span class="title-dot" data-astro-cid-ufwbdbbi></span> ${categoryFilter ? `${categories2.find((c) => c.slug === categoryFilter)?.label} Recipes` : "All Recipes"} </h1> <p class="recipe-count" data-astro-cid-ufwbdbbi>${totalRecipes} recipes found</p> </div> </section> <!-- Category Filter Pills --> <section class="filters-section" data-astro-cid-ufwbdbbi> <div class="container" data-astro-cid-ufwbdbbi> <div class="filter-pills" data-astro-cid-ufwbdbbi> <a href="/recipes"${addAttribute([
        "filter-pill",
        { active: !categoryFilter && !tagFilter }
      ], "class:list")} data-astro-cid-ufwbdbbi>
All
</a> ${categories2.map((cat) => renderTemplate`<a${addAttribute(buildFilterUrl(
        cat.slug === categoryFilter ? "" : cat.slug,
        void 0,
        1
      ), "href")}${addAttribute([
        "filter-pill",
        { active: categoryFilter === cat.slug }
      ], "class:list")} data-astro-cid-ufwbdbbi> ${cat.label} </a>`)} </div> </div> </section> <!-- Tag Chips --> ${tags2.length > 0 && renderTemplate`<section class="tags-section" data-astro-cid-ufwbdbbi> <div class="container" data-astro-cid-ufwbdbbi> <div class="tag-chips" data-astro-cid-ufwbdbbi> ${tags2.slice(0, 8).map((tag2) => renderTemplate`<a${addAttribute(buildFilterUrl(
        void 0,
        tag2.slug === tagFilter ? "" : tag2.slug,
        1
      ), "href")}${addAttribute(["tag-chip", { active: tagFilter === tag2.slug }], "class:list")}${addAttribute(`--tag-color: ${tag2.color || "#ff6600"};`, "style")} data-astro-cid-ufwbdbbi> <div class="chip-image" data-astro-cid-ufwbdbbi> ${tag2.imageUrl ? renderTemplate`<img${addAttribute(tag2.imageUrl, "src")}${addAttribute(tag2.label, "alt")} data-astro-cid-ufwbdbbi>` : renderTemplate`<div class="chip-placeholder" data-astro-cid-ufwbdbbi>${tag2.label.charAt(0)}</div>`} </div> <span class="chip-label" data-astro-cid-ufwbdbbi>${tag2.label}</span> </a>`)} </div> </div> </section>`} <!-- Active Filters --> ${(categoryFilter || tagFilter) && renderTemplate`<section class="active-filters" data-astro-cid-ufwbdbbi> <div class="container" data-astro-cid-ufwbdbbi> <div class="filter-tags" data-astro-cid-ufwbdbbi> ${categoryFilter && renderTemplate`<span class="filter-tag" data-astro-cid-ufwbdbbi>
Category:${" "} ${categories2.find((c) => c.slug === categoryFilter)?.label} <a${addAttribute(buildFilterUrl("", tagFilter, 1), "href")} class="remove-filter" data-astro-cid-ufwbdbbi>

</a> </span>`} ${tagFilter && renderTemplate`<span class="filter-tag" data-astro-cid-ufwbdbbi>
Tag: ${tags2.find((t2) => t2.slug === tagFilter)?.label} <a${addAttribute(buildFilterUrl(categoryFilter, "", 1), "href")} class="remove-filter" data-astro-cid-ufwbdbbi>

</a> </span>`} <a href="/recipes" class="clear-all" data-astro-cid-ufwbdbbi>
Clear All
</a> </div> </div> </section>`} <!-- Recipe Grid --> <section class="recipes-grid-section" data-astro-cid-ufwbdbbi> <div class="container" data-astro-cid-ufwbdbbi> <h2 class="sr-only" data-astro-cid-ufwbdbbi>Recipe results</h2> ${recipes.length > 0 ? renderTemplate`<div class="recipes-grid" data-astro-cid-ufwbdbbi> ${recipes.map((recipe) => {
        const { selected, srcSet } = getRecipeImage(recipe, 400, "cover");
        const sizes = "(max-width: 768px) 50vw, 25vw";
        const { badgeColor, badgeText } = getBadgeColors(recipe.categoryColor);
        return renderTemplate`<article class="recipe-card" data-astro-cid-ufwbdbbi> <a${addAttribute(`/recipes/${recipe.slug}`, "href")} class="card-image-link" data-astro-cid-ufwbdbbi> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 400, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 300, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" data-astro-cid-ufwbdbbi>`} <span class="card-badge"${addAttribute(`background: ${badgeColor}; color: ${badgeText};`, "style")} data-astro-cid-ufwbdbbi> ${recipe.categoryLabel} </span> </a> <div class="card-body" data-astro-cid-ufwbdbbi> <h3 class="card-title" data-astro-cid-ufwbdbbi> <a${addAttribute(`/recipes/${recipe.slug}`, "href")} data-astro-cid-ufwbdbbi>${recipe.headline}</a> </h3> <div class="card-meta" data-astro-cid-ufwbdbbi> ${recipe.recipeJson?.prepTime && renderTemplate`<span class="meta-item" data-astro-cid-ufwbdbbi> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-ufwbdbbi> <circle cx="12" cy="12" r="10" data-astro-cid-ufwbdbbi></circle> <path d="M12 6v6l4 2" data-astro-cid-ufwbdbbi></path> </svg> ${recipe.recipeJson.prepTime} </span>`} ${recipe.recipeJson?.servings && renderTemplate`<span class="meta-item" data-astro-cid-ufwbdbbi> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-ufwbdbbi> <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" data-astro-cid-ufwbdbbi></path> <circle cx="9" cy="7" r="4" data-astro-cid-ufwbdbbi></circle> </svg> ${recipe.recipeJson.servings} </span>`} </div> </div> </article>`;
      })} </div>` : renderTemplate`<div class="no-recipes" data-astro-cid-ufwbdbbi> <p data-astro-cid-ufwbdbbi>No recipes found matching your filters.</p> <a href="/recipes" class="reset-btn" data-astro-cid-ufwbdbbi>
View All Recipes
</a> </div>`} <!-- Pagination --> ${totalPages > 1 && renderTemplate`<nav class="pagination" data-astro-cid-ufwbdbbi> ${page62 > 1 && renderTemplate`<a${addAttribute(buildFilterUrl(void 0, void 0, page62 - 1), "href")} class="page-btn prev" data-astro-cid-ufwbdbbi>
 Previous
</a>`} <div class="page-numbers" data-astro-cid-ufwbdbbi> ${Array.from({ length: totalPages }, (_, i2) => i2 + 1).map(
        (p) => renderTemplate`<a${addAttribute(buildFilterUrl(void 0, void 0, p), "href")}${addAttribute(["page-num", { active: p === page62 }], "class:list")} data-astro-cid-ufwbdbbi> ${p} </a>`
      )} </div> ${page62 < totalPages && renderTemplate`<a${addAttribute(buildFilterUrl(void 0, void 0, page62 + 1), "href")} class="page-btn next" data-astro-cid-ufwbdbbi>
Next 
</a>`} </nav>`} </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/index.astro", void 0);
    $$file10 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/index.astro";
    $$url10 = "/recipes";
    _page54 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Index3,
      file: $$file10,
      prerender: prerender40,
      url: $$url10
    }, Symbol.toStringTag, { value: "Module" }));
    page54 = /* @__PURE__ */ __name(() => _page54, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/rss/pinterest/_board_.xml.astro.mjs
var board_xml_astro_exports = {};
__export(board_xml_astro_exports, {
  page: () => page55,
  renderers: () => renderers
});
function escapeXml2(unsafe) {
  if (!unsafe) return "";
  return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
async function getStaticPaths() {
  return [];
}
var MessagePort4, MessageChannelPolyfill3, GET35, _page55, page55;
var init_board_xml_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/rss/pinterest/_board_.xml.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    GET35 = /* @__PURE__ */ __name(async ({ params, locals, site }) => {
      try {
        const boardSlug = params.board;
        const siteUrl = site?.toString() || "https://recipes-saas.com";
        const db = locals.runtime?.env?.DB;
        if (!db) {
          throw new Error("Database not available");
        }
        const board = await db.prepare(`
      SELECT * FROM pinterest_boards 
      WHERE slug = ? AND is_active = 1
    `).bind(boardSlug).first();
        if (!board) {
          return new Response("Board not found", { status: 404 });
        }
        const { results } = await db.prepare(`
      SELECT 
        p.*,
        a.slug as article_slug,
        a.label as article_label,
        a.headline as article_headline
      FROM pinterest_pins p
      LEFT JOIN articles a ON p.article_id = a.id
      WHERE p.board_id = ?
        AND p.created_at >= datetime('now', '-24 hours')
      ORDER BY p.created_at DESC
    `).bind(board.id).all();
        const pins = results;
        const rss = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:media="http://search.yahoo.com/mrss/"
     xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>${escapeXml2(board.name)} - Freecipies Pinterest</title>
    <description>${escapeXml2(board.description || `Latest pins for ${board.name}`)}</description>
    <link>${siteUrl}/rss/pinterest/${boardSlug}.xml</link>
    <atom:link href="${siteUrl}/rss/pinterest/${boardSlug}.xml" rel="self" type="application/rss+xml"/>
    <language>en-us</language>
    <lastBuildDate>${(/* @__PURE__ */ new Date()).toUTCString()}</lastBuildDate>
    <ttl>60</ttl>
    <image>
      <url>${siteUrl}/logo.png</url>
      <title>${escapeXml2(board.name)}</title>
      <link>${siteUrl}</link>
    </image>
    ${pins.map((pin) => {
          const pinUrl = pin.article_slug ? `${siteUrl}/recipes/${pin.article_slug}#pin-${pin.id}` : `${siteUrl}/pins/${pin.id}`;
          const pubDate = pin.created_at ? new Date(pin.created_at).toUTCString() : (/* @__PURE__ */ new Date()).toUTCString();
          return `
    <item>
      <title>${escapeXml2(pin.title)}</title>
      <link>${pinUrl}</link>
      <guid isPermaLink="true">${pinUrl}</guid>
      <description>${escapeXml2(pin.description)}</description>
      <pubDate>${pubDate}</pubDate>
      <media:content url="${escapeXml2(pin.image_url)}" type="image/jpeg" width="${pin.image_width}" height="${pin.image_height}">
        <media:title>${escapeXml2(pin.title)}</media:title>
        <media:description>${escapeXml2(pin.description)}</media:description>
        ${pin.image_alt ? `<media:text type="plain">${escapeXml2(pin.image_alt)}</media:text>` : ""}
      </media:content>
      <enclosure url="${escapeXml2(pin.image_url)}" type="image/jpeg" length="0"/>
      ${pin.article_label ? `<dc:creator>${escapeXml2(pin.article_label)}</dc:creator>` : ""}
      <category>${escapeXml2(board.name)}</category>
    </item>`;
        }).join("\n")}
  </channel>
</rss>`;
        return new Response(rss, {
          headers: {
            "Content-Type": "application/xml; charset=utf-8",
            "Cache-Control": "public, max-age=300"
            // 5 minutes cache
          }
        });
      } catch (error5) {
        console.error("Pinterest RSS generation error:", error5);
        return new Response(`<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Error</title>
    <description>Failed to generate RSS feed</description>
    <link>${site?.toString() || "https://recipes-saas.com"}</link>
  </channel>
</rss>`, {
          status: 500,
          headers: {
            "Content-Type": "application/xml; charset=utf-8"
          }
        });
      }
    }, "GET");
    __name(escapeXml2, "escapeXml");
    __name(getStaticPaths, "getStaticPaths");
    _page55 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET35,
      getStaticPaths
    }, Symbol.toStringTag, { value: "Module" }));
    page55 = /* @__PURE__ */ __name(() => _page55, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/rss/pinterest.xml.astro.mjs
var pinterest_xml_astro_exports = {};
__export(pinterest_xml_astro_exports, {
  page: () => page56,
  renderers: () => renderers
});
function escapeXml3(unsafe) {
  if (!unsafe) return "";
  return String(unsafe).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var MessagePort4, MessageChannelPolyfill3, GET36, _page56, page56;
var init_pinterest_xml_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/rss/pinterest.xml.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    GET36 = /* @__PURE__ */ __name(async ({ locals, site }) => {
      try {
        const siteUrl = site?.toString() || "https://recipes-saas.com";
        const db = locals.runtime?.env?.DB;
        if (!db) {
          throw new Error("Database not available");
        }
        const { results } = await db.prepare(`
      SELECT 
        p.*,
        a.slug as article_slug,
        a.label as article_label,
        a.headline as article_headline,
        b.name as board_name,
        b.slug as board_slug
      FROM pinterest_pins p
      LEFT JOIN articles a ON p.article_id = a.id
      LEFT JOIN pinterest_boards b ON p.board_id = b.id
      WHERE p.created_at >= datetime('now', '-24 hours')
        AND (b.is_active = 1 OR b.is_active IS NULL)
      ORDER BY p.created_at DESC
      LIMIT 100
    `).all();
        const pins = results || [];
        const rss = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:media="http://search.yahoo.com/mrss/"
     xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Freecipies Pinterest - Latest Pins (24h)</title>
    <description>All new Pinterest pins from Freecipies created in the last 24 hours</description>
    <link>${siteUrl}/rss/pinterest.xml</link>
    <atom:link href="${siteUrl}/rss/pinterest.xml" rel="self" type="application/rss+xml"/>
    <language>en-us</language>
    <lastBuildDate>${(/* @__PURE__ */ new Date()).toUTCString()}</lastBuildDate>
    <ttl>60</ttl>
    <image>
      <url>${siteUrl}/logo.png</url>
      <title>Freecipies Pinterest</title>
      <link>${siteUrl}</link>
    </image>
    ${pins.map((pin) => {
          const pinUrl = pin.article_slug ? `${siteUrl}/recipes/${pin.article_slug}#pin-${pin.id}` : `${siteUrl}/pins/${pin.id}`;
          const pubDate = pin.created_at ? new Date(pin.created_at).toUTCString() : (/* @__PURE__ */ new Date()).toUTCString();
          return `
    <item>
      <title>${escapeXml3(pin.title)}</title>
      <link>${pinUrl}</link>
      <guid isPermaLink="true">${pinUrl}</guid>
      <description>${escapeXml3(pin.description)}</description>
      <pubDate>${pubDate}</pubDate>
      <media:content url="${escapeXml3(pin.image_url)}" type="image/jpeg" width="${pin.image_width}" height="${pin.image_height}">
        <media:title>${escapeXml3(pin.title)}</media:title>
        <media:description>${escapeXml3(pin.description)}</media:description>
        ${pin.image_alt ? `<media:text type="plain">${escapeXml3(pin.image_alt)}</media:text>` : ""}
      </media:content>
      <enclosure url="${escapeXml3(pin.image_url)}" type="image/jpeg" length="0"/>
      ${pin.article_label ? `<dc:creator>${escapeXml3(pin.article_label)}</dc:creator>` : ""}
      ${pin.board_name ? `<category>${escapeXml3(pin.board_name)}</category>` : ""}
    </item>`;
        }).join("\n")}
  </channel>
</rss>`;
        return new Response(rss, {
          headers: {
            "Content-Type": "application/xml; charset=utf-8",
            "Cache-Control": "public, max-age=300"
            // 5 minutes cache
          }
        });
      } catch (error5) {
        console.error("Pinterest RSS generation error:", error5);
        return new Response(`<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Error</title>
    <description>Failed to generate RSS feed</description>
    <link>${site?.toString() || "https://recipes-saas.com"}</link>
  </channel>
</rss>`, {
          status: 500,
          headers: {
            "Content-Type": "application/xml; charset=utf-8"
          }
        });
      }
    }, "GET");
    __name(escapeXml3, "escapeXml");
    _page56 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET36
    }, Symbol.toStringTag, { value: "Module" }));
    page56 = /* @__PURE__ */ __name(() => _page56, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/rss/recipes.xml.astro.mjs
var recipes_xml_astro_exports = {};
__export(recipes_xml_astro_exports, {
  page: () => page57,
  renderers: () => renderers
});
function escapeXml4(unsafe) {
  if (!unsafe) return "";
  return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var MessagePort4, MessageChannelPolyfill3, GET37, _page57, page57;
var init_recipes_xml_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/rss/recipes.xml.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    GET37 = /* @__PURE__ */ __name(async ({ locals, site }) => {
      try {
        const siteUrl = site?.toString() || "https://recipes-saas.com";
        const db = locals.runtime?.env?.DB;
        let articles2 = [];
        if (db) {
          const { results } = await db.prepare(`
        SELECT 
          slug, label, headline, short_description, 
          images_json, published_at, author_slug, category_slug
        FROM articles 
        WHERE is_online = 1 
        ORDER BY published_at DESC 
        LIMIT 50
      `).all();
          articles2 = results || [];
        }
        const getRecipeImageUrl = /* @__PURE__ */ __name((article) => {
          const cover = extractImage(article.images_json, "cover", 1200);
          const thumbnail = extractImage(article.images_json, "thumbnail", 1200);
          return cover.imageUrl || thumbnail.imageUrl || "";
        }, "getRecipeImageUrl");
        const rss = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" 
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Freecipies - Easy and Quick Recipes</title>
    <description>Discover delicious, easy-to-follow recipes with everyday ingredients. From quick weeknight dinners to impressive desserts.</description>
    <link>${siteUrl}</link>
    <atom:link href="${siteUrl}/rss.xml" rel="self" type="application/rss+xml"/>
    <language>en-us</language>
    <lastBuildDate>${(/* @__PURE__ */ new Date()).toUTCString()}</lastBuildDate>
    <image>
      <url>${siteUrl}/logo.png</url>
      <title>Freecipies</title>
      <link>${siteUrl}</link>
    </image>
    ${articles2.map((article) => {
          const imageUrl = getRecipeImageUrl(article);
          return `
    <item>
      <title>${escapeXml4(article.headline || article.label)}</title>
      <link>${siteUrl}/recipes/${article.slug}</link>
      <guid isPermaLink="true">${siteUrl}/recipes/${article.slug}</guid>
      <description>${escapeXml4(article.short_description || "")}</description>
      <pubDate>${article.published_at ? new Date(article.published_at).toUTCString() : (/* @__PURE__ */ new Date()).toUTCString()}</pubDate>
      ${article.author_slug ? `<dc:creator>${escapeXml4(article.author_slug)}</dc:creator>` : ""}
      ${article.category_slug ? `<category>${escapeXml4(article.category_slug)}</category>` : ""}
      ${imageUrl ? `<enclosure url="${escapeXml4(imageUrl)}" type="image/jpeg"/>` : ""}
    </item>`;
        }).join("\n")}
  </channel>
</rss>`;
        return new Response(rss, {
          headers: {
            "Content-Type": "application/xml; charset=utf-8",
            "Cache-Control": "public, max-age=3600"
          }
        });
      } catch (error5) {
        console.error("RSS generation error:", error5);
        const siteUrl = site?.toString() || "https://recipes-saas.com";
        const fallbackRss = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Freecipies</title>
    <description>Easy and Quick Recipes</description>
    <link>${siteUrl}</link>
  </channel>
</rss>`;
        return new Response(fallbackRss, {
          headers: {
            "Content-Type": "application/xml; charset=utf-8"
          }
        });
      }
    }, "GET");
    __name(escapeXml4, "escapeXml");
    _page57 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET37
    }, Symbol.toStringTag, { value: "Module" }));
    page57 = /* @__PURE__ */ __name(() => _page57, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/sitemap.astro.mjs
var sitemap_astro_exports = {};
__export(sitemap_astro_exports, {
  page: () => page58,
  renderers: () => renderers
});
function escapeXml5(str) {
  if (!str) return "";
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var MessagePort4, MessageChannelPolyfill3, prerender41, GET38, _page58, page58;
var init_sitemap_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/sitemap.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_categories_service_BzGDlPlq();
    init_tags_service_DE4uyghe();
    init_authors_service_DDYOeshw();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    prerender41 = false;
    GET38 = /* @__PURE__ */ __name(async ({ locals, site }) => {
      const env3 = locals.runtime.env;
      const baseUrl = site?.toString().replace(/\/$/, "") || "https://recipes-saas.com";
      let recipes = [];
      let categories2 = [];
      let tags2 = [];
      let authors2 = [];
      try {
        const [recipesResult, categoriesResult, tagsResult, authorsResult] = await Promise.all([
          getArticles(env3.DB, { type: "recipe", limit: 1e3 }),
          getCategories(env3.DB, { isOnline: true }),
          getTags(env3.DB, { isOnline: true }),
          getAuthors(env3.DB, { isOnline: true })
        ]);
        recipes = recipesResult.items;
        categories2 = categoriesResult;
        tags2 = tagsResult;
        authors2 = authorsResult;
      } catch (error5) {
        console.error("Error fetching data for sitemap:", error5);
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const staticPages = [
        { url: "/", priority: "1.0", changefreq: "daily" },
        { url: "/recipes", priority: "0.9", changefreq: "daily" },
        { url: "/categories", priority: "0.8", changefreq: "weekly" },
        { url: "/tags", priority: "0.8", changefreq: "weekly" },
        { url: "/authors", priority: "0.7", changefreq: "weekly" },
        { url: "/contact", priority: "0.5", changefreq: "monthly" },
        { url: "/faqs", priority: "0.5", changefreq: "monthly" },
        { url: "/about", priority: "0.6", changefreq: "monthly" }
      ];
      const getAbsoluteImageUrl = /* @__PURE__ */ __name((url) => {
        if (!url) return "";
        if (url.startsWith("http://") || url.startsWith("https://")) return url;
        return `${baseUrl}${url.startsWith("/") ? "" : "/"}${url}`;
      }, "getAbsoluteImageUrl");
      const getRecipeImageUrl = /* @__PURE__ */ __name((recipe) => {
        const cover = extractImage(recipe.imagesJson, "cover", 1200);
        const thumbnail = extractImage(recipe.imagesJson, "thumbnail", 1200);
        return cover.imageUrl || thumbnail.imageUrl || recipe.imageUrl || "";
      }, "getRecipeImageUrl");
      const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9"
        xmlns:image="http://www.google.com/schemas/sitemap-image/1.1">
    ${staticPages.map((page62) => `
    <url>
        <loc>${baseUrl}${page62.url}</loc>
        <lastmod>${today}</lastmod>
        <changefreq>${page62.changefreq}</changefreq>
        <priority>${page62.priority}</priority>
    </url>`).join("")}
    ${recipes.map((recipe) => {
        const imageUrl = getRecipeImageUrl(recipe);
        return `
    <url>
        <loc>${baseUrl}/recipes/${recipe.slug}</loc>
        <lastmod>${recipe.updatedAt ? new Date(recipe.updatedAt).toISOString().split("T")[0] : today}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.8</priority>${imageUrl ? `
        <image:image>
            <image:loc>${escapeXml5(getAbsoluteImageUrl(imageUrl))}</image:loc>
            <image:title>${escapeXml5(recipe.headline)}</image:title>
        </image:image>` : ""}
    </url>`;
      }).join("")}
    ${categories2.map((cat) => `
    <url>
        <loc>${baseUrl}/categories/${cat.slug}</loc>
        <lastmod>${today}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.7</priority>
    </url>`).join("")}
    ${tags2.map((tag2) => `
    <url>
        <loc>${baseUrl}/tags/${tag2.slug}</loc>
        <lastmod>${today}</lastmod>
        <changefreq>weekly</changefreq>
        <priority>0.6</priority>
    </url>`).join("")}
    ${authors2.map((author) => `
    <url>
        <loc>${baseUrl}/authors/${author.slug}</loc>
        <lastmod>${today}</lastmod>
        <changefreq>monthly</changefreq>
        <priority>0.6</priority>
    </url>`).join("")}
</urlset>`;
      return new Response(sitemap.trim(), {
        status: 200,
        headers: {
          "Content-Type": "application/xml",
          "Cache-Control": "public, max-age=3600"
          // Cache for 1 hour
        }
      });
    }, "GET");
    __name(escapeXml5, "escapeXml");
    _page58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      GET: GET38,
      prerender: prerender41
    }, Symbol.toStringTag, { value: "Module" }));
    page58 = /* @__PURE__ */ __name(() => _page58, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/tags/_slug_.astro.mjs
var slug_astro_exports14 = {};
__export(slug_astro_exports14, {
  page: () => page59,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro11, $$slug4, $$file11, $$url11, _page59, page59;
var init_slug_astro14 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/tags/_slug_.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_RecipeCard_3G_w8UC6();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_tags_service_DE4uyghe();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro11 = createAstro("https://localhost:4321");
    $$slug4 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro11, $$props, $$slots);
      Astro2.self = $$slug4;
      const { slug } = Astro2.params;
      const { env: env3 } = Astro2.locals.runtime;
      if (!slug) return Astro2.redirect("/404");
      const tag2 = await getTagBySlug(env3.DB, slug);
      if (!tag2) return Astro2.redirect("/404");
      const { items: rawArticles, total } = await getArticles(env3.DB, {});
      const articles2 = hydrateArticles(rawArticles);
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": `${tag2.label} Recipes`, "description": `Discover delicious recipes tagged with ${tag2.label}`, "data-astro-cid-ytpo4vtr": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="tag-archive" data-astro-cid-ytpo4vtr> <!-- Hero Section --> <section class="hero-section" data-astro-cid-ytpo4vtr> <div class="hero-container" data-astro-cid-ytpo4vtr> <h1 class="hero-title" data-astro-cid-ytpo4vtr>${tag2.label}</h1> <div class="tag-meta" data-astro-cid-ytpo4vtr> <span class="recipe-count" data-astro-cid-ytpo4vtr>${total} ${total === 1 ? "recipe" : "recipes"}</span> </div> </div> </section> <!-- Recipes Grid --> <section class="recipes-section" data-astro-cid-ytpo4vtr> <div class="section-container" data-astro-cid-ytpo4vtr> <div class="section-header" data-astro-cid-ytpo4vtr> <h2 class="section-title" data-astro-cid-ytpo4vtr>Recipes tagged "${tag2.label}"</h2> </div> ${articles2.length > 0 ? renderTemplate`<div class="recipes-grid" data-astro-cid-ytpo4vtr> ${articles2.map((article) => renderTemplate`${renderComponent($$result2, "RecipeCard", $$RecipeCard, { "recipe": article, "data-astro-cid-ytpo4vtr": true })}`)} </div>` : renderTemplate`<div class="empty-state" data-astro-cid-ytpo4vtr> <p data-astro-cid-ytpo4vtr>No recipes found with this tag.</p> </div>`} </div> </section> <!-- Back to Tags --> <section class="back-section" data-astro-cid-ytpo4vtr> <div class="section-container" data-astro-cid-ytpo4vtr> <a href="/tags" class="back-link" data-astro-cid-ytpo4vtr> Browse all tags</a> </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/[slug].astro", void 0);
    $$file11 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/[slug].astro";
    $$url11 = "/tags/[slug]";
    _page59 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$slug4,
      file: $$file11,
      url: $$url11
    }, Symbol.toStringTag, { value: "Module" }));
    page59 = /* @__PURE__ */ __name(() => _page59, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/tags.astro.mjs
var tags_astro_exports2 = {};
__export(tags_astro_exports2, {
  page: () => page60,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, $$Astro$18, $$TagCard, $$Astro12, $$Index4, $$file12, $$url12, _page60, page60;
var init_tags_astro2 = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/tags.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_pinterest_schema_eG5oHE2g();
    init_tags_service_DE4uyghe();
    init_articles_service_DgNeye45();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    $$Astro$18 = createAstro("https://localhost:4321");
    $$TagCard = createComponent(($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$18, $$props, $$slots);
      Astro2.self = $$TagCard;
      const { tag: tag2, showArticleCount = false, articleCount = 0 } = Astro2.props;
      const tagUrl = `/tags/${tag2.slug}`;
      return renderTemplate`${maybeRenderHead()}<a${addAttribute(tagUrl, "href")} class="tag-card" data-astro-cid-zvzsvsys> <div class="tag-content" data-astro-cid-zvzsvsys> ${tag2.imageUrl && renderTemplate`<div class="tag-image" data-astro-cid-zvzsvsys> <img${addAttribute(tag2.imageUrl, "src")}${addAttribute(tag2.imageAlt || tag2.label, "alt")} loading="lazy" data-astro-cid-zvzsvsys> </div>`} <div class="tag-info" data-astro-cid-zvzsvsys> <h3 class="tag-label" data-astro-cid-zvzsvsys>${tag2.label}</h3> ${tag2.headline && renderTemplate`<p class="tag-headline" data-astro-cid-zvzsvsys>${tag2.headline}</p>`} ${showArticleCount && renderTemplate`<span class="article-count" data-astro-cid-zvzsvsys> ${articleCount} ${articleCount === 1 ? "recipe" : "recipes"} </span>`} </div> </div> </a> `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/TagCard.astro", void 0);
    $$Astro12 = createAstro("https://localhost:4321");
    $$Index4 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro12, $$props, $$slots);
      Astro2.self = $$Index4;
      const { env: env3 } = Astro2.locals.runtime;
      const rawTags = await getTags(env3.DB);
      const tags2 = rawTags.map(hydrateTag);
      const tagArticleCounts = /* @__PURE__ */ new Map();
      for (const tag2 of tags2) {
        const { total } = await getArticles(env3.DB, { tagSlug: tag2.slug });
        tagArticleCounts.set(tag2.slug, total);
      }
      const sortedTags = [...tags2].sort((a2, b) => {
        return (tagArticleCounts.get(b.slug) || 0) - (tagArticleCounts.get(a2.slug) || 0);
      });
      const pageTitle = "Recipe Tags - Freecipies";
      const pageDescription = "Browse recipes by tags. Find exactly what you're looking for with our organized recipe tags.";
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": pageTitle, "description": pageDescription, "data-astro-cid-os4i7owy": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="tags-page" data-astro-cid-os4i7owy> <!-- Hero Section --> <section class="hero-section" data-astro-cid-os4i7owy> <div class="hero-container" data-astro-cid-os4i7owy> <h1 class="hero-title" data-astro-cid-os4i7owy>Browse by Tags</h1> <p class="hero-subtitle" data-astro-cid-os4i7owy>
Find recipes organized by ingredients, cooking methods, and dietary
          preferences
</p> </div> </section> <!-- Tags Grid --> <section class="tags-section" data-astro-cid-os4i7owy> <div class="section-container" data-astro-cid-os4i7owy> <h2 class="sr-only" data-astro-cid-os4i7owy>Tag list</h2> ${sortedTags.length > 0 ? renderTemplate`<div class="tags-grid" data-astro-cid-os4i7owy> ${sortedTags.map((tag2) => renderTemplate`${renderComponent($$result2, "TagCard", $$TagCard, { "tag": tag2, "showArticleCount": true, "articleCount": tagArticleCounts.get(tag2.slug) || 0, "data-astro-cid-os4i7owy": true })}`)} </div>` : renderTemplate`<div class="empty-state" data-astro-cid-os4i7owy> <p data-astro-cid-os4i7owy>No tags found.</p> </div>`} </div> </section> </main> `, "default") })} `;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/index.astro", void 0);
    $$file12 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/index.astro";
    $$url12 = "/tags";
    _page60 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Index4,
      file: $$file12,
      url: $$url12
    }, Symbol.toStringTag, { value: "Module" }));
    page60 = /* @__PURE__ */ __name(() => _page60, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/pages/index.astro.mjs
var index_astro_exports = {};
__export(index_astro_exports, {
  page: () => page61,
  renderers: () => renderers
});
var MessagePort4, MessageChannelPolyfill3, __freeze$12, __defProp$12, __template$12, _a$12, $$Astro$19, $$StoriesBar, __freeze2, __defProp3, __template2, _a2, $$WebStoryViewer, $$Astro13, $$Index5, $$file13, $$url13, _page61, page61;
var init_index_astro = __esm({
  ".wrangler/tmp/pages-AQW1MV/pages/index.astro.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_server_B79ahsw9();
    init_Layout_DDkk2Mp3();
    init_pinterest_schema_eG5oHE2g();
    init_articles_service_DgNeye45();
    init_categories_service_BzGDlPlq();
    init_hydration_PCOoIFzn();
    init_renderers();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __freeze$12 = Object.freeze;
    __defProp$12 = Object.defineProperty;
    __template$12 = /* @__PURE__ */ __name((cooked, raw) => __freeze$12(__defProp$12(cooked, "raw", { value: __freeze$12(cooked.slice()) })), "__template$1");
    $$Astro$19 = createAstro("https://localhost:4321");
    $$StoriesBar = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro$19, $$props, $$slots);
      Astro2.self = $$StoriesBar;
      const { env: env3 } = Astro2.locals.runtime;
      const oneDayAgo = /* @__PURE__ */ new Date();
      oneDayAgo.setHours(oneDayAgo.getHours() - 24);
      let { items: stories } = await getArticles(env3.DB, {
        isOnline: true,
        limit: 15
      });
      if (stories.length === 0) {
        const { items: fallback } = await getArticles(env3.DB, { limit: 12 });
        stories = fallback;
      }
      stories = stories.sort((a2, b) => (b.viewCount || 0) - (a2.viewCount || 0));
      const storiesWithPages = stories.map((story) => {
        const preview = extractImage(story.imagesJson, "thumbnail", 120);
        const cover = extractImage(story.imagesJson, "cover", 1200);
        preview.imageUrl ? preview : cover;
        const storyImage = cover.imageUrl || preview.imageUrl || story.imageUrl;
        return {
          ...story,
          storyImage,
          storyPreview: {
            imageUrl: preview.imageUrl || story.imageUrl,
            imageAlt: preview.imageAlt || story.headline,
            imageWidth: preview.imageWidth || 80,
            imageHeight: preview.imageHeight || 80,
            srcSet: getImageSrcSet(story.imagesJson, "thumbnail")
          },
          storyPages: [
            {
              imageUrl: storyImage,
              title: story.headline,
              text: story.shortDescription || story.tldr || ""
            },
            ...storyImage ? [
              {
                imageUrl: storyImage,
                title: "Swipe to continue",
                text: "Tap right to see more"
              }
            ] : [],
            {
              imageUrl: storyImage,
              title: story.headline,
              text: "Ready to cook?"
            }
          ]
        };
      });
      return renderTemplate(_a$12 || (_a$12 = __template$12(["", "<script>(function(){", '\n  // Pass data to client-side safely without bloating DOM\n  window.STORIES_DATA = storiesData;\n})();<\/script><script>\n  // Handle story item clicks - using is:inline to ensure it runs\n  (function () {\n    console.log("StoriesBar script initializing");\n\n    function initStoryClicks() {\n      const storyItems = document.querySelectorAll(".story-item");\n      console.log("Found story items:", storyItems.length);\n\n      storyItems.forEach((item) => {\n        item.addEventListener("click", (e) => {\n          e.preventDefault();\n          e.stopPropagation();\n\n          const index = parseInt(item.getAttribute("data-story-index") || "0");\n          console.log("Story item clicked:", index);\n\n          const route = item.getAttribute("data-story-route");\n          const slug = item.getAttribute("data-story-slug");\n          const headline = item.getAttribute("data-story-headline");\n\n          // Get pages from global object instead of parsing DOM attribute\n          const storyWithPages =\n            window.STORIES_DATA && window.STORIES_DATA[index];\n          const pages = storyWithPages ? storyWithPages.storyPages : [];\n\n          console.log("Story data from global:", {\n            route,\n            slug,\n            headline,\n            pagesFound: pages.length > 0,\n          });\n\n          if (pages.length > 0) {\n            try {\n              const storyData = {\n                route: route,\n                slug: slug,\n                headline: headline,\n              };\n\n              // Check if openWebStory exists\n              if (typeof window.openWebStory === "function") {\n                console.log("Calling openWebStory");\n                window.openWebStory(storyData, pages);\n              } else {\n                console.error("openWebStory function not found on window");\n              }\n            } catch (err) {\n              console.error("Failed to open story:", err);\n            }\n          } else {\n            console.error("No story pages data found");\n          }\n        });\n      });\n    }\n\n    // Mouse drag scroll for desktop\n    function initDragScroll() {\n      const slider = document.querySelector(".stories-scroll");\n      if (!slider) return;\n\n      let isDown = false;\n      let startX;\n      let scrollLeft;\n\n      slider.addEventListener("mousedown", (e) => {\n        // Ignore if clicking on a story item\n        if (e.target.closest(".story-item")) return;\n        isDown = true;\n        slider.style.cursor = "grabbing";\n        slider.style.scrollBehavior = "auto"; // Disable smooth scroll for instant drag\n        startX = e.pageX - slider.offsetLeft;\n        scrollLeft = slider.scrollLeft;\n      });\n\n      slider.addEventListener("mouseleave", () => {\n        isDown = false;\n        slider.style.cursor = "grab";\n        slider.style.scrollBehavior = "smooth"; // Re-enable smooth scroll\n      });\n\n      slider.addEventListener("mouseup", () => {\n        isDown = false;\n        slider.style.cursor = "grab";\n        slider.style.scrollBehavior = "smooth"; // Re-enable smooth scroll\n      });\n\n      slider.addEventListener("mousemove", (e) => {\n        if (!isDown) return;\n        e.preventDefault();\n        const x = e.pageX - slider.offsetLeft;\n        const walk = (x - startX) * 2; // Scroll speed multiplier\n        slider.scrollLeft = scrollLeft - walk;\n      });\n\n      // Set initial cursor\n      slider.style.cursor = "grab";\n    }\n\n    // Initialize when DOM is ready\n    if (document.readyState === "loading") {\n      document.addEventListener("DOMContentLoaded", () => {\n        initStoryClicks();\n        initDragScroll();\n      });\n    } else {\n      initStoryClicks();\n      initDragScroll();\n    }\n  })();\n<\/script>'])), stories.length > 0 && renderTemplate`${maybeRenderHead()}<section class="stories-section" data-astro-cid-obl65slz><div class="stories-container" data-astro-cid-obl65slz><div class="stories-scroll" data-astro-cid-obl65slz>${storiesWithPages.map((story, idx) => renderTemplate`<button type="button" class="story-item"${addAttribute(idx, "data-story-index")}${addAttribute(story.slug, "data-story-slug")}${addAttribute(story.route || `/recipes/${story.slug}`, "data-story-route")}${addAttribute(story.headline, "data-story-headline")} data-astro-cid-obl65slz><div class="story-ring" data-astro-cid-obl65slz><div class="story-image-wrapper" data-astro-cid-obl65slz>${story.storyPreview?.imageUrl ? renderTemplate`<img${addAttribute(story.storyPreview.imageUrl, "src")}${addAttribute(story.storyPreview.imageAlt || story.headline, "alt")}${addAttribute(story.storyPreview.imageWidth || 80, "width")}${addAttribute(story.storyPreview.imageHeight || 80, "height")}${addAttribute(story.storyPreview.srcSet || void 0, "srcset")}${addAttribute(story.storyPreview.srcSet ? "80px" : void 0, "sizes")} loading="lazy" data-astro-cid-obl65slz>` : renderTemplate`<div class="story-placeholder" data-astro-cid-obl65slz>${story.headline.charAt(0)}</div>`}</div></div><span class="story-title" data-astro-cid-obl65slz>${story.headline}</span></button>`)}</div></div></section>`, defineScriptVars({ storiesData: storiesWithPages }));
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/StoriesBar.astro", void 0);
    __freeze2 = Object.freeze;
    __defProp3 = Object.defineProperty;
    __template2 = /* @__PURE__ */ __name((cooked, raw) => __freeze2(__defProp3(cooked, "raw", { value: __freeze2(raw || cooked.slice()) })), "__template");
    $$WebStoryViewer = createComponent(($$result, $$props, $$slots) => {
      return renderTemplate(_a2 || (_a2 = __template2(["", '<div id="web-story-viewer" class="story-viewer" data-astro-cid-vbs6sfrm> <div class="story-container" data-astro-cid-vbs6sfrm> <!-- Close button --> <button class="story-close" aria-label="Close story" data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <line x1="18" y1="6" x2="6" y2="18" data-astro-cid-vbs6sfrm></line> <line x1="6" y1="6" x2="18" y2="18" data-astro-cid-vbs6sfrm></line> </svg> </button> <!-- Story content container --> <div class="story-content" data-story-content data-astro-cid-vbs6sfrm> <!-- Pages will be injected here by client script --> </div> <!-- Navigation Buttons --> <button class="story-nav-btn story-nav-prev" aria-label="Previous" data-story-prev data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <polyline points="15 18 9 12 15 6" data-astro-cid-vbs6sfrm></polyline> </svg> </button> <button class="story-nav-btn story-nav-next" aria-label="Next" data-story-next data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <polyline points="9 18 15 12 9 6" data-astro-cid-vbs6sfrm></polyline> </svg> </button> <!-- Progress bars --> <div class="story-progress" data-astro-cid-vbs6sfrm> <div class="progress-bar" data-story-progress data-astro-cid-vbs6sfrm></div> </div> </div> </div> <script>\n    (function () {\n        class WebStoryViewer {\n            constructor() {\n                this.viewer = document.getElementById("web-story-viewer");\n                this.content = this.viewer?.querySelector(\n                    "[data-story-content]",\n                );\n                this.closeBtn = this.viewer?.querySelector(".story-close");\n                this.prevBtn = this.viewer?.querySelector("[data-story-prev]");\n                this.nextBtn = this.viewer?.querySelector("[data-story-next]");\n\n                this.currentStory = null;\n                this.currentPage = 0;\n\n                console.log("WebStoryViewer initialized");\n                this.init();\n            }\n\n            init() {\n                if (!this.viewer) return;\n\n                this.closeBtn?.addEventListener("click", () => this.close());\n                this.prevBtn?.addEventListener("click", (e) => {\n                    e.stopPropagation();\n                    this.previousPage();\n                });\n                this.nextBtn?.addEventListener("click", (e) => {\n                    e.stopPropagation();\n                    this.nextPage();\n                });\n\n                document.addEventListener("keydown", (e) => {\n                    if (!this.viewer?.classList.contains("active")) return;\n                    if (e.key === "ArrowLeft") this.previousPage();\n                    if (e.key === "ArrowRight") this.nextPage();\n                    if (e.key === "Escape") this.close();\n                });\n\n                let touchStartX = 0;\n                this.viewer.addEventListener("touchstart", (e) => {\n                    touchStartX = e.changedTouches[0].screenX;\n                });\n                this.viewer.addEventListener("touchend", (e) => {\n                    const diff = touchStartX - e.changedTouches[0].screenX;\n                    if (Math.abs(diff) > 50) {\n                        diff > 0 ? this.nextPage() : this.previousPage();\n                    }\n                });\n            }\n\n            open(story, pages) {\n                console.log("=== OPENING STORY ===");\n                console.log("Story object:", JSON.stringify(story));\n                console.log("Pages array:", JSON.stringify(pages));\n\n                this.currentStory = story;\n                this.currentPage = 0;\n                this.renderPages(pages);\n                this.viewer?.classList.add("active");\n                document.body.style.overflow = "hidden";\n                this.showPage(0);\n            }\n\n            close() {\n                // Clear auto-advance timer\n                if (this.autoAdvanceTimer) {\n                    clearTimeout(this.autoAdvanceTimer);\n                    this.autoAdvanceTimer = null;\n                }\n                this.viewer?.classList.remove("active");\n                document.body.style.overflow = "";\n                this.currentStory = null;\n                this.currentPage = 0;\n            }\n\n            renderPages(pages) {\n                if (!this.content) {\n                    console.error("Content element not found!");\n                    return;\n                }\n\n                console.log("Rendering", pages.length, "pages");\n\n                // Render progress bars with INLINE styles for visibility\n                const progressContainer =\n                    this.viewer?.querySelector(".story-progress");\n                if (progressContainer) {\n                    // Force container styles\n                    progressContainer.style.cssText =\n                        "position:absolute;top:20px;left:16px;right:60px;display:flex;gap:8px;z-index:99999;pointer-events:none;";\n\n                    progressContainer.innerHTML = pages\n                        .map(\n                            (_, i) => `\n                            <div class="progress-bar" style="flex:1;height:6px;background:#555;border-radius:3px;overflow:hidden;">\n                                <div class="progress-fill" data-progress="${i}" style="height:100%;width:0%;background:#ff6600;transition:width 5s linear;"></div>\n                            </div>\n                        `,\n                        )\n                        .join("");\n                    console.log(\n                        "Progress bars rendered with inline styles:",\n                        pages.length,\n                    );\n                }\n\n                // IMPORTANT: Capture story reference before map\n                const storyData = this.currentStory;\n                const numPages = pages.length;\n\n                console.log("Story data for CTA:", storyData);\n\n                // Build pages HTML with INLINE STYLES\n                let pagesHtml = "";\n                for (let i = 0; i < pages.length; i++) {\n                    const page = pages[i];\n                    const isLastPage = i === numPages - 1;\n\n                    console.log(\n                        `Building page ${i}: title="${page.title}", text="${page.text}", isLast=${isLastPage}`,\n                    );\n\n                    let ctaHtml = "";\n                    if (isLastPage && storyData) {\n                        const href =\n                            storyData.route || "/recipes/" + storyData.slug;\n                        console.log("Adding CTA with href:", href);\n                        ctaHtml = `\n                            <a href="${href}" style="display:inline-flex;align-items:center;gap:10px;background:linear-gradient(135deg,#ff6600,#ff8800);color:#fff;padding:16px 28px;border-radius:50px;text-decoration:none;font-weight:700;font-size:17px;box-shadow:0 4px 15px rgba(255,102,0,0.4);margin-top:16px;z-index:99999;position:relative;">\n                                Read Full Recipe\n                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">\n                                    <path d="M5 12h14M12 5l7 7-7 7"/>\n                                </svg>\n                            </a>\n                        `;\n                    }\n\n                    const imageUrl = page.imageUrl || "";\n                    const imageAlt = page.imageAlt || "";\n                    const title = page.title || "";\n                    const text = page.text || "";\n\n                    // Overlay with inline gradient\n                    const overlayStyle =\n                        "position:absolute;inset:0;background:linear-gradient(to bottom,rgba(0,0,0,0.5) 0%,transparent 25%,transparent 50%,rgba(0,0,0,0.9) 100%);display:flex;flex-direction:column;justify-content:flex-end;padding:60px 24px 40px;color:#fff;z-index:10;";\n\n                    // Title style\n                    const titleStyle =\n                        "font-size:26px;font-weight:700;margin:0 0 12px;line-height:1.3;text-shadow:0 2px 4px rgba(0,0,0,0.8);color:#fff;";\n\n                    // Text style\n                    const textStyle =\n                        "font-size:16px;line-height:1.5;margin:0 0 20px;text-shadow:0 1px 3px rgba(0,0,0,0.8);color:#fff;opacity:0.95;";\n\n                    pagesHtml += `\n                        <div class="story-page" data-page="${i}" style="position:absolute;inset:0;opacity:0;visibility:hidden;">\n                            <div style="position:absolute;inset:0;">\n                                <img src="${imageUrl}" alt="${imageAlt}" style="width:100%;height:100%;object-fit:cover;" />\n                            </div>\n                            <div style="${overlayStyle}">\n                                <h2 style="${titleStyle}">${title}</h2>\n                                <p style="${textStyle}">${text}</p>\n                                ${ctaHtml}\n                            </div>\n                        </div>\n                    `;\n                }\n\n                this.content.innerHTML = pagesHtml;\n                console.log("Pages HTML injected into content");\n            }\n\n            showPage(index) {\n                const pages = this.content?.querySelectorAll(".story-page");\n                if (!pages || index < 0 || index >= pages.length) return;\n\n                // Hide all pages with inline styles\n                pages.forEach((p) => {\n                    p.style.opacity = "0";\n                    p.style.visibility = "hidden";\n                });\n\n                // Show current page with inline styles\n                pages[index].style.opacity = "1";\n                pages[index].style.visibility = "visible";\n\n                this.updateProgress(index, pages.length);\n                this.currentPage = index;\n                console.log("Showing page", index);\n            }\n\n            updateProgress(current, total) {\n                // Clear any existing auto-advance timer\n                if (this.autoAdvanceTimer) {\n                    clearTimeout(this.autoAdvanceTimer);\n                }\n\n                const fills = this.viewer?.querySelectorAll("[data-progress]");\n                fills?.forEach((fill, i) => {\n                    if (i < current) {\n                        // Previous bars: immediately full (no transition)\n                        fill.style.transition = "none";\n                        fill.style.width = "100%";\n                    } else if (i === current) {\n                        // Current bar: start empty, then fill with 10s animation\n                        fill.style.transition = "none";\n                        fill.style.width = "0%";\n                        // Force reflow then animate\n                        fill.offsetHeight;\n                        fill.style.transition = "width 10s linear";\n                        setTimeout(() => {\n                            fill.style.width = "100%";\n                        }, 10);\n                    } else {\n                        // Future bars: empty (no transition)\n                        fill.style.transition = "none";\n                        fill.style.width = "0%";\n                    }\n                });\n\n                // Auto-advance after 10 seconds\n                this.autoAdvanceTimer = setTimeout(() => {\n                    const totalPages =\n                        this.content?.querySelectorAll(".story-page").length ||\n                        0;\n                    if (this.currentPage < totalPages - 1) {\n                        // Go to next page\n                        this.showPage(this.currentPage + 1);\n                    } else {\n                        // Last page - close the viewer\n                        this.close();\n                    }\n                }, 10000);\n            }\n\n            nextPage() {\n                const totalPages =\n                    this.content?.querySelectorAll(".story-page").length || 0;\n                if (this.currentPage < totalPages - 1) {\n                    this.showPage(this.currentPage + 1);\n                }\n            }\n\n            previousPage() {\n                if (this.currentPage > 0) {\n                    this.showPage(this.currentPage - 1);\n                }\n            }\n        }\n\n        const storyViewer = new WebStoryViewer();\n        window.openWebStory = function (story, pages) {\n            storyViewer.open(story, pages);\n        };\n    })();\n<\/script> '], ["", '<div id="web-story-viewer" class="story-viewer" data-astro-cid-vbs6sfrm> <div class="story-container" data-astro-cid-vbs6sfrm> <!-- Close button --> <button class="story-close" aria-label="Close story" data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <line x1="18" y1="6" x2="6" y2="18" data-astro-cid-vbs6sfrm></line> <line x1="6" y1="6" x2="18" y2="18" data-astro-cid-vbs6sfrm></line> </svg> </button> <!-- Story content container --> <div class="story-content" data-story-content data-astro-cid-vbs6sfrm> <!-- Pages will be injected here by client script --> </div> <!-- Navigation Buttons --> <button class="story-nav-btn story-nav-prev" aria-label="Previous" data-story-prev data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <polyline points="15 18 9 12 15 6" data-astro-cid-vbs6sfrm></polyline> </svg> </button> <button class="story-nav-btn story-nav-next" aria-label="Next" data-story-next data-astro-cid-vbs6sfrm> <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-vbs6sfrm> <polyline points="9 18 15 12 9 6" data-astro-cid-vbs6sfrm></polyline> </svg> </button> <!-- Progress bars --> <div class="story-progress" data-astro-cid-vbs6sfrm> <div class="progress-bar" data-story-progress data-astro-cid-vbs6sfrm></div> </div> </div> </div> <script>\n    (function () {\n        class WebStoryViewer {\n            constructor() {\n                this.viewer = document.getElementById("web-story-viewer");\n                this.content = this.viewer?.querySelector(\n                    "[data-story-content]",\n                );\n                this.closeBtn = this.viewer?.querySelector(".story-close");\n                this.prevBtn = this.viewer?.querySelector("[data-story-prev]");\n                this.nextBtn = this.viewer?.querySelector("[data-story-next]");\n\n                this.currentStory = null;\n                this.currentPage = 0;\n\n                console.log("WebStoryViewer initialized");\n                this.init();\n            }\n\n            init() {\n                if (!this.viewer) return;\n\n                this.closeBtn?.addEventListener("click", () => this.close());\n                this.prevBtn?.addEventListener("click", (e) => {\n                    e.stopPropagation();\n                    this.previousPage();\n                });\n                this.nextBtn?.addEventListener("click", (e) => {\n                    e.stopPropagation();\n                    this.nextPage();\n                });\n\n                document.addEventListener("keydown", (e) => {\n                    if (!this.viewer?.classList.contains("active")) return;\n                    if (e.key === "ArrowLeft") this.previousPage();\n                    if (e.key === "ArrowRight") this.nextPage();\n                    if (e.key === "Escape") this.close();\n                });\n\n                let touchStartX = 0;\n                this.viewer.addEventListener("touchstart", (e) => {\n                    touchStartX = e.changedTouches[0].screenX;\n                });\n                this.viewer.addEventListener("touchend", (e) => {\n                    const diff = touchStartX - e.changedTouches[0].screenX;\n                    if (Math.abs(diff) > 50) {\n                        diff > 0 ? this.nextPage() : this.previousPage();\n                    }\n                });\n            }\n\n            open(story, pages) {\n                console.log("=== OPENING STORY ===");\n                console.log("Story object:", JSON.stringify(story));\n                console.log("Pages array:", JSON.stringify(pages));\n\n                this.currentStory = story;\n                this.currentPage = 0;\n                this.renderPages(pages);\n                this.viewer?.classList.add("active");\n                document.body.style.overflow = "hidden";\n                this.showPage(0);\n            }\n\n            close() {\n                // Clear auto-advance timer\n                if (this.autoAdvanceTimer) {\n                    clearTimeout(this.autoAdvanceTimer);\n                    this.autoAdvanceTimer = null;\n                }\n                this.viewer?.classList.remove("active");\n                document.body.style.overflow = "";\n                this.currentStory = null;\n                this.currentPage = 0;\n            }\n\n            renderPages(pages) {\n                if (!this.content) {\n                    console.error("Content element not found!");\n                    return;\n                }\n\n                console.log("Rendering", pages.length, "pages");\n\n                // Render progress bars with INLINE styles for visibility\n                const progressContainer =\n                    this.viewer?.querySelector(".story-progress");\n                if (progressContainer) {\n                    // Force container styles\n                    progressContainer.style.cssText =\n                        "position:absolute;top:20px;left:16px;right:60px;display:flex;gap:8px;z-index:99999;pointer-events:none;";\n\n                    progressContainer.innerHTML = pages\n                        .map(\n                            (_, i) => \\`\n                            <div class="progress-bar" style="flex:1;height:6px;background:#555;border-radius:3px;overflow:hidden;">\n                                <div class="progress-fill" data-progress="\\${i}" style="height:100%;width:0%;background:#ff6600;transition:width 5s linear;"></div>\n                            </div>\n                        \\`,\n                        )\n                        .join("");\n                    console.log(\n                        "Progress bars rendered with inline styles:",\n                        pages.length,\n                    );\n                }\n\n                // IMPORTANT: Capture story reference before map\n                const storyData = this.currentStory;\n                const numPages = pages.length;\n\n                console.log("Story data for CTA:", storyData);\n\n                // Build pages HTML with INLINE STYLES\n                let pagesHtml = "";\n                for (let i = 0; i < pages.length; i++) {\n                    const page = pages[i];\n                    const isLastPage = i === numPages - 1;\n\n                    console.log(\n                        \\`Building page \\${i}: title="\\${page.title}", text="\\${page.text}", isLast=\\${isLastPage}\\`,\n                    );\n\n                    let ctaHtml = "";\n                    if (isLastPage && storyData) {\n                        const href =\n                            storyData.route || "/recipes/" + storyData.slug;\n                        console.log("Adding CTA with href:", href);\n                        ctaHtml = \\`\n                            <a href="\\${href}" style="display:inline-flex;align-items:center;gap:10px;background:linear-gradient(135deg,#ff6600,#ff8800);color:#fff;padding:16px 28px;border-radius:50px;text-decoration:none;font-weight:700;font-size:17px;box-shadow:0 4px 15px rgba(255,102,0,0.4);margin-top:16px;z-index:99999;position:relative;">\n                                Read Full Recipe\n                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">\n                                    <path d="M5 12h14M12 5l7 7-7 7"/>\n                                </svg>\n                            </a>\n                        \\`;\n                    }\n\n                    const imageUrl = page.imageUrl || "";\n                    const imageAlt = page.imageAlt || "";\n                    const title = page.title || "";\n                    const text = page.text || "";\n\n                    // Overlay with inline gradient\n                    const overlayStyle =\n                        "position:absolute;inset:0;background:linear-gradient(to bottom,rgba(0,0,0,0.5) 0%,transparent 25%,transparent 50%,rgba(0,0,0,0.9) 100%);display:flex;flex-direction:column;justify-content:flex-end;padding:60px 24px 40px;color:#fff;z-index:10;";\n\n                    // Title style\n                    const titleStyle =\n                        "font-size:26px;font-weight:700;margin:0 0 12px;line-height:1.3;text-shadow:0 2px 4px rgba(0,0,0,0.8);color:#fff;";\n\n                    // Text style\n                    const textStyle =\n                        "font-size:16px;line-height:1.5;margin:0 0 20px;text-shadow:0 1px 3px rgba(0,0,0,0.8);color:#fff;opacity:0.95;";\n\n                    pagesHtml += \\`\n                        <div class="story-page" data-page="\\${i}" style="position:absolute;inset:0;opacity:0;visibility:hidden;">\n                            <div style="position:absolute;inset:0;">\n                                <img src="\\${imageUrl}" alt="\\${imageAlt}" style="width:100%;height:100%;object-fit:cover;" />\n                            </div>\n                            <div style="\\${overlayStyle}">\n                                <h2 style="\\${titleStyle}">\\${title}</h2>\n                                <p style="\\${textStyle}">\\${text}</p>\n                                \\${ctaHtml}\n                            </div>\n                        </div>\n                    \\`;\n                }\n\n                this.content.innerHTML = pagesHtml;\n                console.log("Pages HTML injected into content");\n            }\n\n            showPage(index) {\n                const pages = this.content?.querySelectorAll(".story-page");\n                if (!pages || index < 0 || index >= pages.length) return;\n\n                // Hide all pages with inline styles\n                pages.forEach((p) => {\n                    p.style.opacity = "0";\n                    p.style.visibility = "hidden";\n                });\n\n                // Show current page with inline styles\n                pages[index].style.opacity = "1";\n                pages[index].style.visibility = "visible";\n\n                this.updateProgress(index, pages.length);\n                this.currentPage = index;\n                console.log("Showing page", index);\n            }\n\n            updateProgress(current, total) {\n                // Clear any existing auto-advance timer\n                if (this.autoAdvanceTimer) {\n                    clearTimeout(this.autoAdvanceTimer);\n                }\n\n                const fills = this.viewer?.querySelectorAll("[data-progress]");\n                fills?.forEach((fill, i) => {\n                    if (i < current) {\n                        // Previous bars: immediately full (no transition)\n                        fill.style.transition = "none";\n                        fill.style.width = "100%";\n                    } else if (i === current) {\n                        // Current bar: start empty, then fill with 10s animation\n                        fill.style.transition = "none";\n                        fill.style.width = "0%";\n                        // Force reflow then animate\n                        fill.offsetHeight;\n                        fill.style.transition = "width 10s linear";\n                        setTimeout(() => {\n                            fill.style.width = "100%";\n                        }, 10);\n                    } else {\n                        // Future bars: empty (no transition)\n                        fill.style.transition = "none";\n                        fill.style.width = "0%";\n                    }\n                });\n\n                // Auto-advance after 10 seconds\n                this.autoAdvanceTimer = setTimeout(() => {\n                    const totalPages =\n                        this.content?.querySelectorAll(".story-page").length ||\n                        0;\n                    if (this.currentPage < totalPages - 1) {\n                        // Go to next page\n                        this.showPage(this.currentPage + 1);\n                    } else {\n                        // Last page - close the viewer\n                        this.close();\n                    }\n                }, 10000);\n            }\n\n            nextPage() {\n                const totalPages =\n                    this.content?.querySelectorAll(".story-page").length || 0;\n                if (this.currentPage < totalPages - 1) {\n                    this.showPage(this.currentPage + 1);\n                }\n            }\n\n            previousPage() {\n                if (this.currentPage > 0) {\n                    this.showPage(this.currentPage - 1);\n                }\n            }\n        }\n\n        const storyViewer = new WebStoryViewer();\n        window.openWebStory = function (story, pages) {\n            storyViewer.open(story, pages);\n        };\n    })();\n<\/script> '])), maybeRenderHead());
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/WebStoryViewer.astro", void 0);
    $$Astro13 = createAstro("https://localhost:4321");
    $$Index5 = createComponent(async ($$result, $$props, $$slots) => {
      const Astro2 = $$result.createAstro($$Astro13, $$props, $$slots);
      Astro2.self = $$Index5;
      const { env: env3 } = Astro2.locals.runtime;
      const siteTitle = "Easy and Quick Recipes for Everyone - Freecipies";
      const siteDescription = "Discover delicious, easy-to-follow recipes with everyday ingredients. From quick weeknight dinners to impressive desserts, Freecipies makes cooking fun and accessible!";
      let allRecipes = [];
      let categories2 = [];
      try {
        const { items: recipes } = await getArticles(env3.DB, { limit: 12 });
        allRecipes = recipes.map(hydrateArticle);
        const rawCategories = await getCategories(env3.DB, { isOnline: true });
        categories2 = rawCategories.map(hydrateCategory);
      } catch (error5) {
        console.error("Error fetching data for homepage:", error5);
      }
      const featuredRecipes = allRecipes.slice(0, 4);
      const popularRecipes = allRecipes.slice(0, 4);
      const moreRecipes = allRecipes.slice(4, 8);
      const categoryColorMap = new Map(categories2.map((c) => [c.slug, c.color || "#ff6600"]));
      const getRecipeUrl = /* @__PURE__ */ __name((recipe) => recipe.route || `/recipes/${recipe.slug}`, "getRecipeUrl");
      const getCategoryColor = /* @__PURE__ */ __name((categorySlug) => categoryColorMap.get(categorySlug) || "#ff6600", "getCategoryColor");
      const getRecipeImage = /* @__PURE__ */ __name((recipe, targetWidth, prefer = "cover") => {
        const cover = extractImage(recipe.imagesJson, "cover", targetWidth);
        const thumbnail = extractImage(recipe.imagesJson, "thumbnail", targetWidth);
        const slotName2 = prefer === "cover" ? cover.imageUrl ? "cover" : "thumbnail" : thumbnail.imageUrl ? "thumbnail" : "cover";
        const selected = slotName2 === "cover" ? cover : thumbnail;
        const srcSet = getImageSrcSet(recipe.imagesJson, slotName2);
        return { selected, srcSet };
      }, "getRecipeImage");
      const getCategoryImage = /* @__PURE__ */ __name((category, targetWidth, prefer = "thumbnail") => {
        const cover = extractImage(category.imagesJson, "cover", targetWidth);
        const thumbnail = extractImage(category.imagesJson, "thumbnail", targetWidth);
        const slotName2 = prefer === "cover" ? cover.imageUrl ? "cover" : "thumbnail" : thumbnail.imageUrl ? "thumbnail" : "cover";
        const selected = slotName2 === "cover" ? cover : thumbnail;
        const srcSet = getImageSrcSet(category.imagesJson, slotName2);
        return { selected, srcSet };
      }, "getCategoryImage");
      return renderTemplate`${renderComponent($$result, "Layout", $$Layout, { "title": siteTitle, "description": siteDescription, "data-astro-cid-j7pv25f6": true }, { "default": /* @__PURE__ */ __name(async ($$result2) => renderTemplate` ${maybeRenderHead()}<main class="homepage" data-astro-cid-j7pv25f6> ${renderComponent($$result2, "StoriesBar", $$StoriesBar, { "data-astro-cid-j7pv25f6": true })} ${featuredRecipes.length > 0 && renderTemplate`<section class="hero-grid-section" data-astro-cid-j7pv25f6> <div class="hero-grid" data-astro-cid-j7pv25f6>  <div class="hero-slider" id="heroSlider" data-astro-cid-j7pv25f6> <div class="slider-track" data-astro-cid-j7pv25f6> ${featuredRecipes.slice(0, 4).map((recipe, index2) => {
        const { selected, srcSet } = getRecipeImage(recipe, 1200, "cover");
        const sizes = "(max-width: 900px) 100vw, 60vw";
        return renderTemplate`<a${addAttribute(getRecipeUrl(recipe), "href")}${addAttribute(["slide", { active: index2 === 0 }], "class:list")}${addAttribute(index2, "data-index")} data-astro-cid-j7pv25f6> <div class="card-image" data-astro-cid-j7pv25f6> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 1200, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 675, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")}${addAttribute(index2 === 0 ? "eager" : "lazy", "loading")}${addAttribute(index2 === 0 ? "high" : "auto", "fetchpriority")} data-astro-cid-j7pv25f6>`} <div class="card-overlay" data-astro-cid-j7pv25f6></div> </div> <div class="card-content" data-astro-cid-j7pv25f6> <span class="card-category"${addAttribute(`--badge-color: ${getCategoryColor(recipe.categorySlug)};`, "style")} data-astro-cid-j7pv25f6> ${recipe.categoryLabel} </span> <h2 class="card-title" data-astro-cid-j7pv25f6>${recipe.headline}</h2> </div> </a>`;
      })} </div>  <div class="slider-dots" data-astro-cid-j7pv25f6> ${featuredRecipes.slice(0, 4).map((_, index2) => renderTemplate`<button${addAttribute(["dot", { active: index2 === 0 }], "class:list")}${addAttribute(index2, "data-index")}${addAttribute(`Slide ${index2 + 1}`, "aria-label")} data-astro-cid-j7pv25f6></button>`)} </div> </div>  <div class="hero-side-cards" data-astro-cid-j7pv25f6> ${featuredRecipes.slice(1, 3).map((recipe) => {
        const { selected, srcSet } = getRecipeImage(recipe, 600, "cover");
        const sizes = "(max-width: 900px) 100vw, 40vw";
        return renderTemplate`<a${addAttribute(getRecipeUrl(recipe), "href")} class="recipe-card recipe-card-small" data-astro-cid-j7pv25f6> <div class="card-image" data-astro-cid-j7pv25f6> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 600, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 400, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" data-astro-cid-j7pv25f6>`} <div class="card-overlay" data-astro-cid-j7pv25f6></div> </div> <div class="card-content" data-astro-cid-j7pv25f6> <span class="card-category"${addAttribute(`--badge-color: ${getCategoryColor(recipe.categorySlug)};`, "style")} data-astro-cid-j7pv25f6>${recipe.categoryLabel}</span> <h3 class="card-title" data-astro-cid-j7pv25f6>${recipe.headline}</h3> </div> </a>`;
      })} </div> </div> </section>`} <!-- Popular Recipes Section --> ${popularRecipes.length > 0 && renderTemplate`<section class="section popular-recipes-section" data-astro-cid-j7pv25f6> <div class="container" data-astro-cid-j7pv25f6> <div class="section-header" data-astro-cid-j7pv25f6> <h2 class="section-title" data-astro-cid-j7pv25f6> <span class="title-dot" data-astro-cid-j7pv25f6></span>
Popular Recipes
</h2> </div> <div class="popular-grid" data-astro-cid-j7pv25f6> ${popularRecipes.map((recipe) => {
        const { selected, srcSet } = getRecipeImage(recipe, 400, "cover");
        const sizes = "(max-width: 600px) 100vw, (max-width: 1024px) 50vw, 25vw";
        return renderTemplate`<article class="foxiz-card" data-astro-cid-j7pv25f6> <a${addAttribute(getRecipeUrl(recipe), "href")} class="foxiz-card-image" data-astro-cid-j7pv25f6> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 400, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 300, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" data-astro-cid-j7pv25f6>`} <span class="foxiz-badge"${addAttribute(`--badge-color: ${getCategoryColor(recipe.categorySlug)};`, "style")} data-astro-cid-j7pv25f6> ${recipe.categoryLabel} </span> </a> <div class="foxiz-card-body" data-astro-cid-j7pv25f6> <h3 class="foxiz-card-title" data-astro-cid-j7pv25f6> <a${addAttribute(getRecipeUrl(recipe), "href")} data-astro-cid-j7pv25f6>${recipe.headline}</a> </h3> <div class="foxiz-tags" data-astro-cid-j7pv25f6> ${recipe.categoryLabel && renderTemplate`<a${addAttribute(`/categories/${recipe.categorySlug}`, "href")} class="foxiz-tag" data-astro-cid-j7pv25f6> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-j7pv25f6> <path d="M4 4h6l2 3h8v10H4z" data-astro-cid-j7pv25f6></path> </svg> ${recipe.categoryLabel} </a>`} ${recipe.recipeJson?.cookTime && renderTemplate`<span class="foxiz-tag" data-astro-cid-j7pv25f6> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-j7pv25f6> <circle cx="12" cy="12" r="10" data-astro-cid-j7pv25f6></circle> <path d="M12 6v6l4 2" data-astro-cid-j7pv25f6></path> </svg> ${recipe.recipeJson.cookTime} </span>`} </div> </div> </article>`;
      })} </div> </div> </section>`} <!-- Want to Learn How to Make Section --> ${categories2.length > 0 && renderTemplate`<section class="section categories-section" data-astro-cid-j7pv25f6> <div class="container" data-astro-cid-j7pv25f6> <h2 class="section-title centered" data-astro-cid-j7pv25f6>Want to Learn How to Make?</h2> <!-- Category Filter Buttons --> <div class="category-filter-row" data-astro-cid-j7pv25f6> ${categories2.slice(0, 4).map((category) => renderTemplate`<a${addAttribute(`/categories/${category.slug}`, "href")} class="category-filter-btn" data-astro-cid-j7pv25f6> ${category.label} </a>`)} </div> <!-- Category Chips with Images --> <div class="category-chips-row" data-astro-cid-j7pv25f6> ${categories2.map((category) => {
        const { selected, srcSet } = getCategoryImage(category, 80, "thumbnail");
        const sizes = "80px";
        return renderTemplate`<a${addAttribute(`/categories/${category.slug}`, "href")} class="category-chip" data-astro-cid-j7pv25f6> <div class="chip-image-wrapper" data-astro-cid-j7pv25f6> ${selected.imageUrl || category.imageUrl ? renderTemplate`<img${addAttribute(selected.imageUrl || category.imageUrl, "src")}${addAttribute(selected.imageAlt || category.imageAlt || category.label, "alt")}${addAttribute(selected.imageWidth || category.imageWidth || 80, "width")}${addAttribute(selected.imageHeight || category.imageHeight || 80, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" data-astro-cid-j7pv25f6>` : renderTemplate`<div class="chip-placeholder" data-astro-cid-j7pv25f6> ${category.label.charAt(0)} </div>`} </div> <span class="chip-label" data-astro-cid-j7pv25f6>${category.label}</span> <span class="chip-type" data-astro-cid-j7pv25f6>Category</span> </a>`;
      })} </div> </div> </section>`} <!-- More Recipes Section --> ${moreRecipes.length > 0 && renderTemplate`<section class="section more-recipes-section" data-astro-cid-j7pv25f6> <div class="container" data-astro-cid-j7pv25f6> <div class="section-header" data-astro-cid-j7pv25f6> <h2 class="section-title" data-astro-cid-j7pv25f6> <span class="title-dot" data-astro-cid-j7pv25f6></span>
More Recipes
</h2> <a href="/recipes" class="view-all" data-astro-cid-j7pv25f6>
View All 
</a> </div> <div class="recipes-grid" data-astro-cid-j7pv25f6> ${moreRecipes.map((recipe) => {
        const { selected, srcSet } = getRecipeImage(recipe, 400, "cover");
        const sizes = "(max-width: 768px) 50vw, 25vw";
        return renderTemplate`<a${addAttribute(getRecipeUrl(recipe), "href")} class="recipe-card-vertical" data-astro-cid-j7pv25f6> <div class="card-image-wrapper" data-astro-cid-j7pv25f6> ${(selected.imageUrl || recipe.imageUrl) && renderTemplate`<img${addAttribute(selected.imageUrl || recipe.imageUrl, "src")}${addAttribute(selected.imageAlt || recipe.imageAlt || recipe.headline, "alt")}${addAttribute(selected.imageWidth || recipe.imageWidth || 400, "width")}${addAttribute(selected.imageHeight || recipe.imageHeight || 300, "height")}${addAttribute(srcSet || void 0, "srcset")}${addAttribute(srcSet ? sizes : void 0, "sizes")} loading="lazy" data-astro-cid-j7pv25f6>`} <span class="card-category-badge"${addAttribute(`--badge-color: ${getCategoryColor(recipe.categorySlug)};`, "style")} data-astro-cid-j7pv25f6> ${recipe.categoryLabel} </span> </div> <div class="card-body" data-astro-cid-j7pv25f6> <h3 class="card-title" data-astro-cid-j7pv25f6>${recipe.headline}</h3> <div class="card-meta" data-astro-cid-j7pv25f6> ${recipe.recipeJson?.prepTime && renderTemplate`<span class="meta-item" data-astro-cid-j7pv25f6> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" data-astro-cid-j7pv25f6> <circle cx="12" cy="12" r="10" data-astro-cid-j7pv25f6></circle> <path d="M12 6v6l4 2" data-astro-cid-j7pv25f6></path> </svg> ${recipe.recipeJson.prepTime} </span>`} </div> </div> </a>`;
      })} </div> </div> </section>`} <!-- Newsletter Banner --> <section class="newsletter-banner" data-astro-cid-j7pv25f6> <div class="container" data-astro-cid-j7pv25f6> <div class="newsletter-content" data-astro-cid-j7pv25f6> <h2 data-astro-cid-j7pv25f6>Get New Recipes Weekly</h2> <p data-astro-cid-j7pv25f6>Subscribe to receive delicious recipes straight to your inbox.</p> <form class="newsletter-form" data-astro-cid-j7pv25f6> <input type="email" placeholder="Your email address" required data-astro-cid-j7pv25f6> <button type="submit" data-astro-cid-j7pv25f6>Subscribe</button> </form> </div> </div> </section> </main> ${renderComponent($$result2, "WebStoryViewer", $$WebStoryViewer, { "data-astro-cid-j7pv25f6": true })} `, "default") })}  ${renderScript($$result, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro?astro&type=script&index=0&lang.ts")}`;
    }, "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro", void 0);
    $$file13 = "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro";
    $$url13 = "";
    _page61 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: $$Index5,
      file: $$file13,
      url: $$url13
    }, Symbol.toStringTag, { value: "Module" }));
    page61 = /* @__PURE__ */ __name(() => _page61, "page");
  }
});

// .wrangler/tmp/pages-AQW1MV/noop-entrypoint.mjs
var noop_entrypoint_exports = {};
__export(noop_entrypoint_exports, {
  server: () => server
});
var MessagePort4, MessageChannelPolyfill3, server;
var init_noop_entrypoint = __esm({
  ".wrangler/tmp/pages-AQW1MV/noop-entrypoint.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof MessageChannel === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    server = {};
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/worker_threads/message-port.mjs
import { EventEmitter as EventEmitter2 } from "node:events";
var MessagePort;
var init_message_port = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/worker_threads/message-port.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    MessagePort = class extends EventEmitter2 {
      static {
        __name(this, "MessagePort");
      }
      close() {
      }
      postMessage(value, transferList) {
      }
      ref() {
      }
      unref() {
      }
      start() {
      }
      addEventListener(type, listener) {
        this.on(type, listener);
      }
      removeEventListener(type, listener) {
        this.off(type, listener);
      }
      dispatchEvent(event) {
        return this.emit(event.type, event);
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/worker_threads/message-channel.mjs
var MessageChannel2;
var init_message_channel = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/worker_threads/message-channel.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_message_port();
    MessageChannel2 = class {
      static {
        __name(this, "MessageChannel");
      }
      port1 = new MessagePort();
      port2 = new MessagePort();
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/worker_threads.mjs
var init_worker_threads = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/worker_threads.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_message_channel();
  }
});

// .wrangler/tmp/pages-AQW1MV/_astro-internal_middleware.mjs
var astro_internal_middleware_exports = {};
__export(astro_internal_middleware_exports, {
  onRequest: () => onRequest
});
var MessagePort4, MessageChannelPolyfill3, __vite_import_meta_env__2, DEFAULT_ALLOWED_HEADERS, DEFAULT_ALLOWED_METHODS, buildAllowedOrigins, onRequest$2, onRequest$1, onRequest;
var init_astro_internal_middleware = __esm({
  ".wrangler/tmp/pages-AQW1MV/_astro-internal_middleware.mjs"() {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_index_DjxFTAWA();
    init_worker_threads();
    init_astro_designed_error_pages_B6wD2ieN();
    init_server_B79ahsw9();
    if (typeof MessageChannel2 === "undefined") {
      let MessagePort3 = function() {
        this.onmessage = null;
        this._target = null;
      }, MessageChannelPolyfill = function() {
        this.port1 = new MessagePort3();
        this.port2 = new MessagePort3();
        this.port1._target = this.port2;
        this.port2._target = this.port1;
      };
      MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
      __name(MessagePort3, "MessagePort");
      __name(MessageChannelPolyfill, "MessageChannelPolyfill");
      MessagePort3.prototype.postMessage = function(data) {
        var handler = this._target && this._target.onmessage;
        if (typeof handler === "function") {
          handler({ data });
        }
      };
      globalThis.MessageChannel = MessageChannelPolyfill;
    }
    __vite_import_meta_env__2 = { "ASSETS_PREFIX": void 0, "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SITE": "https://localhost:4321", "SSR": true };
    if (typeof globalThis.MessageChannel === "undefined") {
      globalThis.MessageChannel = MessageChannel2;
    }
    DEFAULT_ALLOWED_HEADERS = [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
      "Origin",
      "User-Agent",
      "Referer"
    ].join(", ");
    DEFAULT_ALLOWED_METHODS = "GET,POST,PUT,PATCH,DELETE,OPTIONS";
    buildAllowedOrigins = /* @__PURE__ */ __name((origin) => {
      const origins = /* @__PURE__ */ new Set([origin]);
      const envOrigins = Object.assign(__vite_import_meta_env__2, { OS: process.env.OS, PUBLIC: process.env.PUBLIC })?.PUBLIC_CORS_ORIGINS;
      if (envOrigins) {
        envOrigins.split(",").map((o2) => o2.trim()).filter(Boolean).forEach((o2) => origins.add(o2));
      }
      origins.add("http://localhost:4321");
      return origins;
    }, "buildAllowedOrigins");
    onRequest$2 = defineMiddleware(async (context3, next) => {
      const { request, url } = context3;
      const originHeader = request.headers.get("Origin");
      const allowedOrigins = buildAllowedOrigins(url.origin);
      const allowOrigin = originHeader && allowedOrigins.has(originHeader) ? originHeader : null;
      if (request.method === "OPTIONS" && originHeader) {
        const preflight = new Response(null, { status: 204 });
        if (allowOrigin) {
          preflight.headers.set("Access-Control-Allow-Origin", allowOrigin);
          preflight.headers.append("Vary", "Origin");
          preflight.headers.set("Access-Control-Allow-Methods", DEFAULT_ALLOWED_METHODS);
          preflight.headers.set("Access-Control-Allow-Headers", DEFAULT_ALLOWED_HEADERS);
          preflight.headers.set("Access-Control-Max-Age", "86400");
        }
        return preflight;
      }
      const response = await next();
      const csp = [
        "default-src 'self'",
        "script-src 'self' 'unsafe-eval' 'unsafe-inline' https: blob:",
        "style-src 'self' 'unsafe-inline' https:",
        "img-src 'self' data: https: blob:",
        "font-src 'self' data: https:",
        "connect-src 'self' wss: ws: https:",
        "worker-src 'self' blob:",
        "frame-src 'self' https:",
        "object-src 'none'",
        "base-uri 'self'",
        "frame-ancestors 'self'"
      ].join("; ");
      if (!response.headers.has("Content-Security-Policy")) {
        response.headers.set("Content-Security-Policy", csp);
      }
      if (url.protocol === "https:" && !response.headers.has("Strict-Transport-Security")) {
        response.headers.set("Strict-Transport-Security", "max-age=63072000; includeSubDomains; preload");
      }
      if (!response.headers.has("X-Content-Type-Options")) {
        response.headers.set("X-Content-Type-Options", "nosniff");
      }
      if (!response.headers.has("Referrer-Policy")) {
        response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
      }
      if (!response.headers.has("Permissions-Policy")) {
        response.headers.set("Permissions-Policy", "geolocation=(), microphone=(), camera=(), payment=(), usb=()");
      }
      if (!response.headers.has("Cross-Origin-Opener-Policy")) {
        response.headers.set("Cross-Origin-Opener-Policy", "same-origin");
      }
      if (!response.headers.has("Cross-Origin-Resource-Policy")) {
        response.headers.set("Cross-Origin-Resource-Policy", "same-origin");
      }
      if (allowOrigin && !response.headers.has("Access-Control-Allow-Origin")) {
        response.headers.set("Access-Control-Allow-Origin", allowOrigin);
        response.headers.append("Vary", "Origin");
        response.headers.set("Access-Control-Allow-Methods", DEFAULT_ALLOWED_METHODS);
        response.headers.set("Access-Control-Allow-Headers", DEFAULT_ALLOWED_HEADERS);
      }
      return response;
    });
    onRequest$1 = /* @__PURE__ */ __name((context3, next) => {
      if (context3.isPrerendered) {
        context3.locals.runtime ??= {
          env: process.env
        };
      }
      return next();
    }, "onRequest$1");
    onRequest = sequence(
      onRequest$1,
      onRequest$2
    );
  }
});

// .wrangler/tmp/bundle-1QI512/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-1QI512/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/pages-AQW1MV/zl5dey19hob.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/pages-AQW1MV/bundledWorker-0.2699154439704958.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_renderers();
import { Writable as Writable2 } from "node:stream";
import { EventEmitter as EventEmitter3 } from "node:events";

// .wrangler/tmp/pages-AQW1MV/chunks/_@astrojs-ssr-adapter_DmRsPEtz.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_path_BA_Tke6N();
init_remote_DLFRGwa();
init_index_DjxFTAWA();
init_server_B79ahsw9();

// .wrangler/tmp/pages-AQW1MV/chunks/noop-middleware_BOHnKSmu.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_server_B79ahsw9();
if (typeof MessageChannel === "undefined") {
  let MessagePort3 = function() {
    this.onmessage = null;
    this._target = null;
  }, MessageChannelPolyfill = function() {
    this.port1 = new MessagePort3();
    this.port2 = new MessagePort3();
    this.port1._target = this.port2;
    this.port2._target = this.port1;
  };
  MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
  __name(MessagePort3, "MessagePort");
  __name(MessageChannelPolyfill, "MessageChannelPolyfill");
  MessagePort3.prototype.postMessage = function(data) {
    var handler = this._target && this._target.onmessage;
    if (typeof handler === "function") {
      handler({ data });
    }
  };
  globalThis.MessageChannel = MessageChannelPolyfill;
}
var MessagePort4;
var MessageChannelPolyfill3;
var NOOP_MIDDLEWARE_FN = /* @__PURE__ */ __name(async (_ctx, next) => {
  const response = await next();
  response.headers.set(NOOP_MIDDLEWARE_HEADER, "true");
  return response;
}, "NOOP_MIDDLEWARE_FN");

// .wrangler/tmp/pages-AQW1MV/chunks/_@astrojs-ssr-adapter_DmRsPEtz.mjs
init_astro_designed_error_pages_B6wD2ieN();
import "cloudflare:workers";
if (typeof MessageChannel === "undefined") {
  let MessagePort3 = function() {
    this.onmessage = null;
    this._target = null;
  }, MessageChannelPolyfill = function() {
    this.port1 = new MessagePort3();
    this.port2 = new MessagePort3();
    this.port1._target = this.port2;
    this.port2._target = this.port1;
  };
  MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
  __name(MessagePort3, "MessagePort");
  __name(MessageChannelPolyfill, "MessageChannelPolyfill");
  MessagePort3.prototype.postMessage = function(data) {
    var handler = this._target && this._target.onmessage;
    if (typeof handler === "function") {
      handler({ data });
    }
  };
  globalThis.MessageChannel = MessageChannelPolyfill;
}
var MessagePort4;
var MessageChannelPolyfill3;
function createI18nMiddleware(i18n, base, trailingSlash, format) {
  if (!i18n) return (_, next) => next();
  const payload = {
    ...i18n,
    trailingSlash,
    base,
    format
  };
  const _redirectToDefaultLocale = redirectToDefaultLocale(payload);
  const _noFoundForNonLocaleRoute = notFound(payload);
  const _requestHasLocale = requestHasLocale(payload.locales);
  const _redirectToFallback = redirectToFallback(payload);
  const prefixAlways = /* @__PURE__ */ __name((context3, response) => {
    const url = context3.url;
    if (url.pathname === base + "/" || url.pathname === base) {
      return _redirectToDefaultLocale(context3);
    } else if (!_requestHasLocale(context3)) {
      return _noFoundForNonLocaleRoute(context3, response);
    }
    return void 0;
  }, "prefixAlways");
  const prefixOtherLocales = /* @__PURE__ */ __name((context3, response) => {
    let pathnameContainsDefaultLocale = false;
    const url = context3.url;
    for (const segment of url.pathname.split("/")) {
      if (normalizeTheLocale(segment) === normalizeTheLocale(i18n.defaultLocale)) {
        pathnameContainsDefaultLocale = true;
        break;
      }
    }
    if (pathnameContainsDefaultLocale) {
      const newLocation = url.pathname.replace(`/${i18n.defaultLocale}`, "");
      response.headers.set("Location", newLocation);
      return _noFoundForNonLocaleRoute(context3);
    }
    return void 0;
  }, "prefixOtherLocales");
  return async (context3, next) => {
    const response = await next();
    const type = response.headers.get(ROUTE_TYPE_HEADER);
    const isReroute = response.headers.get(REROUTE_DIRECTIVE_HEADER);
    if (isReroute === "no" && typeof i18n.fallback === "undefined") {
      return response;
    }
    if (type !== "page" && type !== "fallback") {
      return response;
    }
    if (requestIs404Or500(context3.request, base)) {
      return response;
    }
    if (isRequestServerIsland(context3.request, base)) {
      return response;
    }
    const { currentLocale } = context3;
    switch (i18n.strategy) {
      // NOTE: theoretically, we should never hit this code path
      case "manual": {
        return response;
      }
      case "domains-prefix-other-locales": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = prefixOtherLocales(context3, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-other-locales": {
        const result = prefixOtherLocales(context3, response);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always-no-redirect": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = _noFoundForNonLocaleRoute(context3, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-always-no-redirect": {
        const result = _noFoundForNonLocaleRoute(context3, response);
        if (result) {
          return result;
        }
        break;
      }
      case "pathname-prefix-always": {
        const result = prefixAlways(context3, response);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always": {
        if (localeHasntDomain(i18n, currentLocale)) {
          const result = prefixAlways(context3, response);
          if (result) {
            return result;
          }
        }
        break;
      }
    }
    return _redirectToFallback(context3, response);
  };
}
__name(createI18nMiddleware, "createI18nMiddleware");
function localeHasntDomain(i18n, currentLocale) {
  for (const domainLocale of Object.values(i18n.domainLookupTable)) {
    if (domainLocale === currentLocale) {
      return false;
    }
  }
  return true;
}
__name(localeHasntDomain, "localeHasntDomain");
var NOOP_ACTIONS_MOD = {
  server: {}
};
var FORM_CONTENT_TYPES = [
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
];
var SAFE_METHODS = ["GET", "HEAD", "OPTIONS"];
function createOriginCheckMiddleware() {
  return defineMiddleware((context3, next) => {
    const { request, url, isPrerendered } = context3;
    if (isPrerendered) {
      return next();
    }
    if (SAFE_METHODS.includes(request.method)) {
      return next();
    }
    const isSameOrigin = request.headers.get("origin") === url.origin;
    const hasContentType2 = request.headers.has("content-type");
    if (hasContentType2) {
      const formLikeHeader = hasFormLikeHeader(request.headers.get("content-type"));
      if (formLikeHeader && !isSameOrigin) {
        return new Response(`Cross-site ${request.method} form submissions are forbidden`, {
          status: 403
        });
      }
    } else {
      if (!isSameOrigin) {
        return new Response(`Cross-site ${request.method} form submissions are forbidden`, {
          status: 403
        });
      }
    }
    return next();
  });
}
__name(createOriginCheckMiddleware, "createOriginCheckMiddleware");
function hasFormLikeHeader(contentType) {
  if (contentType) {
    for (const FORM_CONTENT_TYPE of FORM_CONTENT_TYPES) {
      if (contentType.toLowerCase().includes(FORM_CONTENT_TYPE)) {
        return true;
      }
    }
  }
  return false;
}
__name(hasFormLikeHeader, "hasFormLikeHeader");
function createDefaultRoutes(manifest2) {
  const root = new URL(manifest2.hrefRoot);
  return [
    {
      instance: default404Instance,
      matchesComponent: /* @__PURE__ */ __name((filePath) => filePath.href === new URL(DEFAULT_404_COMPONENT, root).href, "matchesComponent"),
      route: DEFAULT_404_ROUTE.route,
      component: DEFAULT_404_COMPONENT
    },
    {
      instance: createEndpoint(manifest2),
      matchesComponent: /* @__PURE__ */ __name((filePath) => filePath.href === new URL(SERVER_ISLAND_COMPONENT, root).href, "matchesComponent"),
      route: SERVER_ISLAND_ROUTE,
      component: SERVER_ISLAND_COMPONENT
    }
  ];
}
__name(createDefaultRoutes, "createDefaultRoutes");
var Pipeline = class {
  static {
    __name(this, "Pipeline");
  }
  constructor(logger, manifest2, runtimeMode, renderers2, resolve, serverLike, streaming, adapterName = manifest2.adapterName, clientDirectives = manifest2.clientDirectives, inlinedScripts = manifest2.inlinedScripts, compressHTML = manifest2.compressHTML, i18n = manifest2.i18n, middleware = manifest2.middleware, routeCache = new RouteCache(logger, runtimeMode), site = manifest2.site ? new URL(manifest2.site) : void 0, defaultRoutes = createDefaultRoutes(manifest2), actions = manifest2.actions) {
    this.logger = logger;
    this.manifest = manifest2;
    this.runtimeMode = runtimeMode;
    this.renderers = renderers2;
    this.resolve = resolve;
    this.serverLike = serverLike;
    this.streaming = streaming;
    this.adapterName = adapterName;
    this.clientDirectives = clientDirectives;
    this.inlinedScripts = inlinedScripts;
    this.compressHTML = compressHTML;
    this.i18n = i18n;
    this.middleware = middleware;
    this.routeCache = routeCache;
    this.site = site;
    this.defaultRoutes = defaultRoutes;
    this.actions = actions;
    this.internalMiddleware = [];
    if (i18n?.strategy !== "manual") {
      this.internalMiddleware.push(
        createI18nMiddleware(i18n, manifest2.base, manifest2.trailingSlash, manifest2.buildFormat)
      );
    }
  }
  internalMiddleware;
  resolvedMiddleware = void 0;
  resolvedActions = void 0;
  /**
   * Resolves the middleware from the manifest, and returns the `onRequest` function. If `onRequest` isn't there,
   * it returns a no-op function
   */
  async getMiddleware() {
    if (this.resolvedMiddleware) {
      return this.resolvedMiddleware;
    } else if (this.middleware) {
      const middlewareInstance = await this.middleware();
      const onRequest2 = middlewareInstance.onRequest ?? NOOP_MIDDLEWARE_FN;
      const internalMiddlewares = [onRequest2];
      if (this.manifest.checkOrigin) {
        internalMiddlewares.unshift(createOriginCheckMiddleware());
      }
      this.resolvedMiddleware = sequence(...internalMiddlewares);
      return this.resolvedMiddleware;
    } else {
      this.resolvedMiddleware = NOOP_MIDDLEWARE_FN;
      return this.resolvedMiddleware;
    }
  }
  setActions(actions) {
    this.resolvedActions = actions;
  }
  async getActions() {
    if (this.resolvedActions) {
      return this.resolvedActions;
    } else if (this.actions) {
      return await this.actions();
    }
    return NOOP_ACTIONS_MOD;
  }
  async getAction(path3) {
    const pathKeys = path3.split(".").map((key) => decodeURIComponent(key));
    let { server: server2 } = await this.getActions();
    if (!server2 || !(typeof server2 === "object")) {
      throw new TypeError(
        `Expected \`server\` export in actions file to be an object. Received ${typeof server2}.`
      );
    }
    for (const key of pathKeys) {
      if (!(key in server2)) {
        throw new AstroError({
          ...ActionNotFoundError,
          message: ActionNotFoundError.message(pathKeys.join("."))
        });
      }
      server2 = server2[key];
    }
    if (typeof server2 !== "function") {
      throw new TypeError(
        `Expected handler for action ${pathKeys.join(".")} to be a function. Received ${typeof server2}.`
      );
    }
    return server2;
  }
};
var RedirectComponentInstance = {
  default() {
    return new Response(null, {
      status: 301
    });
  }
};
var RedirectSinglePageBuiltModule = {
  page: /* @__PURE__ */ __name(() => Promise.resolve(RedirectComponentInstance), "page"),
  onRequest: /* @__PURE__ */ __name((_, next) => next(), "onRequest"),
  renderers: []
};
var dateTimeFormat = new Intl.DateTimeFormat([], {
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
  hour12: false
});
var levels = {
  debug: 20,
  info: 30,
  warn: 40,
  error: 50,
  silent: 90
};
function log3(opts, level, label, message2, newLine = true) {
  const logLevel = opts.level;
  const dest = opts.dest;
  const event = {
    label,
    level,
    message: message2,
    newLine
  };
  if (!isLogLevelEnabled(logLevel, level)) {
    return;
  }
  dest.write(event);
}
__name(log3, "log");
function isLogLevelEnabled(configuredLogLevel, level) {
  return levels[configuredLogLevel] <= levels[level];
}
__name(isLogLevelEnabled, "isLogLevelEnabled");
function info3(opts, label, message2, newLine = true) {
  return log3(opts, "info", label, message2, newLine);
}
__name(info3, "info");
function warn3(opts, label, message2, newLine = true) {
  return log3(opts, "warn", label, message2, newLine);
}
__name(warn3, "warn");
function error3(opts, label, message2, newLine = true) {
  return log3(opts, "error", label, message2, newLine);
}
__name(error3, "error");
function debug3(...args) {
  if ("_astroGlobalDebug" in globalThis) {
    globalThis._astroGlobalDebug(...args);
  }
}
__name(debug3, "debug");
function getEventPrefix({ level, label }) {
  const timestamp = `${dateTimeFormat.format(/* @__PURE__ */ new Date())}`;
  const prefix = [];
  if (level === "error" || level === "warn") {
    prefix.push(s.bold(timestamp));
    prefix.push(`[${level.toUpperCase()}]`);
  } else {
    prefix.push(timestamp);
  }
  if (label) {
    prefix.push(`[${label}]`);
  }
  if (level === "error") {
    return s.red(prefix.join(" "));
  }
  if (level === "warn") {
    return s.yellow(prefix.join(" "));
  }
  if (prefix.length === 1) {
    return s.dim(prefix[0]);
  }
  return s.dim(prefix[0]) + " " + s.blue(prefix.splice(1).join(" "));
}
__name(getEventPrefix, "getEventPrefix");
var Logger = class {
  static {
    __name(this, "Logger");
  }
  options;
  constructor(options) {
    this.options = options;
  }
  info(label, message2, newLine = true) {
    info3(this.options, label, message2, newLine);
  }
  warn(label, message2, newLine = true) {
    warn3(this.options, label, message2, newLine);
  }
  error(label, message2, newLine = true) {
    error3(this.options, label, message2, newLine);
  }
  debug(label, ...messages) {
    debug3(label, ...messages);
  }
  level() {
    return this.options.level;
  }
  forkIntegrationLogger(label) {
    return new AstroIntegrationLogger(this.options, label);
  }
};
var AstroIntegrationLogger = class _AstroIntegrationLogger {
  static {
    __name(this, "AstroIntegrationLogger");
  }
  options;
  label;
  constructor(logging, label) {
    this.options = logging;
    this.label = label;
  }
  /**
   * Creates a new logger instance with a new label, but the same log options.
   */
  fork(label) {
    return new _AstroIntegrationLogger(this.options, label);
  }
  info(message2) {
    info3(this.options, this.label, message2);
  }
  warn(message2) {
    warn3(this.options, this.label, message2);
  }
  error(message2) {
    error3(this.options, this.label, message2);
  }
  debug(message2) {
    debug3(this.label, message2);
  }
};
var consoleLogDestination = {
  write(event) {
    let dest = console.error;
    if (levels[event.level] < levels["error"]) {
      dest = console.info;
    }
    if (event.label === "SKIP_FORMAT") {
      dest(event.message);
    } else {
      dest(getEventPrefix(event) + " " + event.message);
    }
    return true;
  }
};
function getAssetsPrefix(fileExtension2, assetsPrefix) {
  let prefix = "";
  if (!assetsPrefix) {
    prefix = "";
  } else if (typeof assetsPrefix === "string") {
    prefix = assetsPrefix;
  } else {
    const dotLessFileExtension = fileExtension2.slice(1);
    prefix = assetsPrefix[dotLessFileExtension] || assetsPrefix.fallback;
  }
  return prefix;
}
__name(getAssetsPrefix, "getAssetsPrefix");
function createAssetLink(href, base, assetsPrefix, queryParams) {
  let url = "";
  if (assetsPrefix) {
    const pf = getAssetsPrefix(fileExtension(href), assetsPrefix);
    url = joinPaths(pf, slash(href));
  } else if (base) {
    url = prependForwardSlash(joinPaths(base, slash(href)));
  } else {
    url = href;
  }
  return url;
}
__name(createAssetLink, "createAssetLink");
function createStylesheetElement(stylesheet, base, assetsPrefix, queryParams) {
  if (stylesheet.type === "inline") {
    return {
      props: {},
      children: stylesheet.content
    };
  } else {
    return {
      props: {
        rel: "stylesheet",
        href: createAssetLink(stylesheet.src, base, assetsPrefix)
      },
      children: ""
    };
  }
}
__name(createStylesheetElement, "createStylesheetElement");
function createStylesheetElementSet(stylesheets, base, assetsPrefix, queryParams) {
  return new Set(
    stylesheets.map((s2) => createStylesheetElement(s2, base, assetsPrefix))
  );
}
__name(createStylesheetElementSet, "createStylesheetElementSet");
function createModuleScriptElement(script, base, assetsPrefix, queryParams) {
  if (script.type === "external") {
    return createModuleScriptElementWithSrc(script.value, base, assetsPrefix);
  } else {
    return {
      props: {
        type: "module"
      },
      children: script.value
    };
  }
}
__name(createModuleScriptElement, "createModuleScriptElement");
function createModuleScriptElementWithSrc(src, base, assetsPrefix, queryParams) {
  return {
    props: {
      type: "module",
      src: createAssetLink(src, base, assetsPrefix)
    },
    children: ""
  };
}
__name(createModuleScriptElementWithSrc, "createModuleScriptElementWithSrc");
function redirectTemplate({
  status,
  absoluteLocation,
  relativeLocation,
  from
}) {
  const delay = status === 302 ? 2 : 0;
  return `<!doctype html>
<title>Redirecting to: ${relativeLocation}</title>
<meta http-equiv="refresh" content="${delay};url=${relativeLocation}">
<meta name="robots" content="noindex">
<link rel="canonical" href="${absoluteLocation}">
<body>
	<a href="${relativeLocation}">Redirecting ${from ? `from <code>${from}</code> ` : ""}to <code>${relativeLocation}</code></a>
</body>`;
}
__name(redirectTemplate, "redirectTemplate");
var AppPipeline = class _AppPipeline extends Pipeline {
  static {
    __name(this, "AppPipeline");
  }
  static create({
    logger,
    manifest: manifest2,
    runtimeMode,
    renderers: renderers2,
    resolve,
    serverLike,
    streaming,
    defaultRoutes
  }) {
    const pipeline = new _AppPipeline(
      logger,
      manifest2,
      runtimeMode,
      renderers2,
      resolve,
      serverLike,
      streaming,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      defaultRoutes
    );
    return pipeline;
  }
  headElements(routeData) {
    const routeInfo = this.manifest.routes.find((route) => route.routeData === routeData);
    const links = /* @__PURE__ */ new Set();
    const scripts = /* @__PURE__ */ new Set();
    const styles = createStylesheetElementSet(routeInfo?.styles ?? []);
    for (const script of routeInfo?.scripts ?? []) {
      if ("stage" in script) {
        if (script.stage === "head-inline") {
          scripts.add({
            props: {},
            children: script.children
          });
        }
      } else {
        scripts.add(createModuleScriptElement(script));
      }
    }
    return { links, styles, scripts };
  }
  componentMetadata() {
  }
  async getComponentByRoute(routeData) {
    const module = await this.getModuleForRoute(routeData);
    return module.page();
  }
  async tryRewrite(payload, request) {
    const { newUrl, pathname, routeData } = findRouteToRewrite({
      payload,
      request,
      routes: this.manifest?.routes.map((r2) => r2.routeData),
      trailingSlash: this.manifest.trailingSlash,
      buildFormat: this.manifest.buildFormat,
      base: this.manifest.base,
      outDir: this.serverLike ? this.manifest.buildClientDir : this.manifest.outDir
    });
    const componentInstance = await this.getComponentByRoute(routeData);
    return { newUrl, pathname, componentInstance, routeData };
  }
  async getModuleForRoute(route) {
    for (const defaultRoute of this.defaultRoutes) {
      if (route.component === defaultRoute.component) {
        return {
          page: /* @__PURE__ */ __name(() => Promise.resolve(defaultRoute.instance), "page"),
          renderers: []
        };
      }
    }
    if (route.type === "redirect") {
      return RedirectSinglePageBuiltModule;
    } else {
      if (this.manifest.pageMap) {
        const importComponentInstance = this.manifest.pageMap.get(route.component);
        if (!importComponentInstance) {
          throw new Error(
            `Unexpectedly unable to find a component instance for route ${route.route}`
          );
        }
        return await importComponentInstance();
      } else if (this.manifest.pageModule) {
        return this.manifest.pageModule;
      }
      throw new Error(
        "Astro couldn't find the correct page to render, probably because it wasn't correctly mapped for SSR usage. This is an internal error, please file an issue."
      );
    }
  }
};
var App = class _App {
  static {
    __name(this, "App");
  }
  #manifest;
  #manifestData;
  #logger = new Logger({
    dest: consoleLogDestination,
    level: "info"
  });
  #baseWithoutTrailingSlash;
  #pipeline;
  #adapterLogger;
  constructor(manifest2, streaming = true) {
    this.#manifest = manifest2;
    this.#manifestData = {
      routes: manifest2.routes.map((route) => route.routeData)
    };
    ensure404Route(this.#manifestData);
    this.#baseWithoutTrailingSlash = removeTrailingForwardSlash(this.#manifest.base);
    this.#pipeline = this.#createPipeline(streaming);
    this.#adapterLogger = new AstroIntegrationLogger(
      this.#logger.options,
      this.#manifest.adapterName
    );
  }
  getAdapterLogger() {
    return this.#adapterLogger;
  }
  getAllowedDomains() {
    return this.#manifest.allowedDomains;
  }
  get manifest() {
    return this.#manifest;
  }
  set manifest(value) {
    this.#manifest = value;
  }
  matchesAllowedDomains(forwardedHost, protocol) {
    return _App.validateForwardedHost(forwardedHost, this.#manifest.allowedDomains, protocol);
  }
  static validateForwardedHost(forwardedHost, allowedDomains, protocol) {
    if (!allowedDomains || allowedDomains.length === 0) {
      return false;
    }
    try {
      const testUrl = new URL(`${protocol || "https"}://${forwardedHost}`);
      return allowedDomains.some((pattern) => {
        return matchPattern(testUrl, pattern);
      });
    } catch {
      return false;
    }
  }
  /**
   * Validate a hostname by rejecting any with path separators.
   * Prevents path injection attacks. Invalid hostnames return undefined.
   */
  static sanitizeHost(hostname) {
    if (!hostname) return void 0;
    if (/[/\\]/.test(hostname)) return void 0;
    return hostname;
  }
  /**
   * Validate forwarded headers (proto, host, port) against allowedDomains.
   * Returns validated values or undefined for rejected headers.
   * Uses strict defaults: http/https only for proto, rejects port if not in allowedDomains.
   */
  static validateForwardedHeaders(forwardedProtocol, forwardedHost, forwardedPort, allowedDomains) {
    const result = {};
    if (forwardedProtocol) {
      if (allowedDomains && allowedDomains.length > 0) {
        const hasProtocolPatterns = allowedDomains.some(
          (pattern) => pattern.protocol !== void 0
        );
        if (hasProtocolPatterns) {
          try {
            const testUrl = new URL(`${forwardedProtocol}://example.com`);
            const isAllowed = allowedDomains.some((pattern) => matchPattern(testUrl, pattern));
            if (isAllowed) {
              result.protocol = forwardedProtocol;
            }
          } catch {
          }
        } else if (/^https?$/.test(forwardedProtocol)) {
          result.protocol = forwardedProtocol;
        }
      } else if (/^https?$/.test(forwardedProtocol)) {
        result.protocol = forwardedProtocol;
      }
    }
    if (forwardedPort && allowedDomains && allowedDomains.length > 0) {
      const hasPortPatterns = allowedDomains.some((pattern) => pattern.port !== void 0);
      if (hasPortPatterns) {
        const isAllowed = allowedDomains.some((pattern) => pattern.port === forwardedPort);
        if (isAllowed) {
          result.port = forwardedPort;
        }
      }
    }
    if (forwardedHost && forwardedHost.length > 0 && allowedDomains && allowedDomains.length > 0) {
      const protoForValidation = result.protocol || "https";
      const sanitized = _App.sanitizeHost(forwardedHost);
      if (sanitized) {
        try {
          const hostnameOnly = sanitized.split(":")[0];
          const portFromHost = sanitized.includes(":") ? sanitized.split(":")[1] : void 0;
          const portForValidation = result.port || portFromHost;
          const hostWithPort = portForValidation ? `${hostnameOnly}:${portForValidation}` : hostnameOnly;
          const testUrl = new URL(`${protoForValidation}://${hostWithPort}`);
          const isAllowed = allowedDomains.some((pattern) => matchPattern(testUrl, pattern));
          if (isAllowed) {
            result.host = sanitized;
          }
        } catch {
        }
      }
    }
    return result;
  }
  /**
   * Creates a pipeline by reading the stored manifest
   *
   * @param streaming
   * @private
   */
  #createPipeline(streaming = false) {
    return AppPipeline.create({
      logger: this.#logger,
      manifest: this.#manifest,
      runtimeMode: "production",
      renderers: this.#manifest.renderers,
      defaultRoutes: createDefaultRoutes(this.#manifest),
      resolve: /* @__PURE__ */ __name(async (specifier) => {
        if (!(specifier in this.#manifest.entryModules)) {
          throw new Error(`Unable to resolve [${specifier}]`);
        }
        const bundlePath = this.#manifest.entryModules[specifier];
        if (bundlePath.startsWith("data:") || bundlePath.length === 0) {
          return bundlePath;
        } else {
          return createAssetLink(bundlePath, this.#manifest.base, this.#manifest.assetsPrefix);
        }
      }, "resolve"),
      serverLike: true,
      streaming
    });
  }
  set setManifestData(newManifestData) {
    this.#manifestData = newManifestData;
  }
  removeBase(pathname) {
    if (pathname.startsWith(this.#manifest.base)) {
      return pathname.slice(this.#baseWithoutTrailingSlash.length + 1);
    }
    return pathname;
  }
  /**
   * It removes the base from the request URL, prepends it with a forward slash and attempts to decoded it.
   *
   * If the decoding fails, it logs the error and return the pathname as is.
   * @param request
   * @private
   */
  #getPathnameFromRequest(request) {
    const url = new URL(request.url);
    const pathname = prependForwardSlash(this.removeBase(url.pathname));
    try {
      return validateAndDecodePathname(pathname);
    } catch (e2) {
      this.getAdapterLogger().error(e2.toString());
      return pathname;
    }
  }
  /**
   * Given a `Request`, it returns the `RouteData` that matches its `pathname`. By default, prerendered
   * routes aren't returned, even if they are matched.
   *
   * When `allowPrerenderedRoutes` is `true`, the function returns matched prerendered routes too.
   * @param request
   * @param allowPrerenderedRoutes
   */
  match(request, allowPrerenderedRoutes = false) {
    const url = new URL(request.url);
    if (this.#manifest.assets.has(url.pathname)) return void 0;
    let pathname = this.#computePathnameFromDomain(request);
    if (!pathname) {
      pathname = prependForwardSlash(this.removeBase(url.pathname));
    }
    try {
      pathname = validateAndDecodePathname(pathname);
    } catch {
      return void 0;
    }
    let routeData = matchRoute(pathname, this.#manifestData);
    if (!routeData) return void 0;
    if (allowPrerenderedRoutes) {
      return routeData;
    } else if (routeData.prerender) {
      return void 0;
    }
    return routeData;
  }
  #computePathnameFromDomain(request) {
    let pathname = void 0;
    const url = new URL(request.url);
    if (this.#manifest.i18n && (this.#manifest.i18n.strategy === "domains-prefix-always" || this.#manifest.i18n.strategy === "domains-prefix-other-locales" || this.#manifest.i18n.strategy === "domains-prefix-always-no-redirect")) {
      const validated = _App.validateForwardedHeaders(
        request.headers.get("X-Forwarded-Proto") ?? void 0,
        request.headers.get("X-Forwarded-Host") ?? void 0,
        request.headers.get("X-Forwarded-Port") ?? void 0,
        this.#manifest.allowedDomains
      );
      let protocol = validated.protocol ? validated.protocol + ":" : url.protocol;
      let host = validated.host ?? request.headers.get("Host");
      if (host && protocol) {
        host = host.split(":")[0];
        try {
          let locale;
          const hostAsUrl = new URL(`${protocol}//${host}`);
          for (const [domainKey, localeValue] of Object.entries(
            this.#manifest.i18n.domainLookupTable
          )) {
            const domainKeyAsUrl = new URL(domainKey);
            if (hostAsUrl.host === domainKeyAsUrl.host && hostAsUrl.protocol === domainKeyAsUrl.protocol) {
              locale = localeValue;
              break;
            }
          }
          if (locale) {
            pathname = prependForwardSlash(
              joinPaths(normalizeTheLocale(locale), this.removeBase(url.pathname))
            );
            if (url.pathname.endsWith("/")) {
              pathname = appendForwardSlash(pathname);
            }
          }
        } catch (e2) {
          this.#logger.error(
            "router",
            `Astro tried to parse ${protocol}//${host} as an URL, but it threw a parsing error. Check the X-Forwarded-Host and X-Forwarded-Proto headers.`
          );
          this.#logger.error("router", `Error: ${e2}`);
        }
      }
    }
    return pathname;
  }
  #redirectTrailingSlash(pathname) {
    const { trailingSlash } = this.#manifest;
    if (pathname === "/" || isInternalPath(pathname)) {
      return pathname;
    }
    const path3 = collapseDuplicateTrailingSlashes(pathname, trailingSlash !== "never");
    if (path3 !== pathname) {
      return path3;
    }
    if (trailingSlash === "ignore") {
      return pathname;
    }
    if (trailingSlash === "always" && !hasFileExtension(pathname)) {
      return appendForwardSlash(pathname);
    }
    if (trailingSlash === "never") {
      return removeTrailingForwardSlash(pathname);
    }
    return pathname;
  }
  async render(request, renderOptions) {
    let routeData;
    let locals;
    let clientAddress;
    let addCookieHeader;
    const url = new URL(request.url);
    const redirect = this.#redirectTrailingSlash(url.pathname);
    const prerenderedErrorPageFetch = renderOptions?.prerenderedErrorPageFetch ?? fetch;
    if (redirect !== url.pathname) {
      const status = request.method === "GET" ? 301 : 308;
      return new Response(
        redirectTemplate({
          status,
          relativeLocation: url.pathname,
          absoluteLocation: redirect,
          from: request.url
        }),
        {
          status,
          headers: {
            location: redirect + url.search
          }
        }
      );
    }
    addCookieHeader = renderOptions?.addCookieHeader;
    clientAddress = renderOptions?.clientAddress ?? Reflect.get(request, clientAddressSymbol);
    routeData = renderOptions?.routeData;
    locals = renderOptions?.locals;
    if (routeData) {
      this.#logger.debug(
        "router",
        "The adapter " + this.#manifest.adapterName + " provided a custom RouteData for ",
        request.url
      );
      this.#logger.debug("router", "RouteData:\n" + routeData);
    }
    if (locals) {
      if (typeof locals !== "object") {
        const error5 = new AstroError(LocalsNotAnObject);
        this.#logger.error(null, error5.stack);
        return this.#renderError(request, {
          status: 500,
          error: error5,
          clientAddress,
          prerenderedErrorPageFetch
        });
      }
    }
    if (!routeData) {
      routeData = this.match(request);
      this.#logger.debug("router", "Astro matched the following route for " + request.url);
      this.#logger.debug("router", "RouteData:\n" + routeData);
    }
    if (!routeData) {
      routeData = this.#manifestData.routes.find(
        (route) => route.component === "404.astro" || route.component === DEFAULT_404_COMPONENT
      );
    }
    if (!routeData) {
      this.#logger.debug("router", "Astro hasn't found routes that match " + request.url);
      this.#logger.debug("router", "Here's the available routes:\n", this.#manifestData);
      return this.#renderError(request, {
        locals,
        status: 404,
        clientAddress,
        prerenderedErrorPageFetch
      });
    }
    const pathname = this.#getPathnameFromRequest(request);
    const defaultStatus = this.#getDefaultStatusCode(routeData, pathname);
    let response;
    let session;
    try {
      const mod = await this.#pipeline.getModuleForRoute(routeData);
      const renderContext = await RenderContext.create({
        pipeline: this.#pipeline,
        locals,
        pathname,
        request,
        routeData,
        status: defaultStatus,
        clientAddress
      });
      session = renderContext.session;
      response = await renderContext.render(await mod.page());
    } catch (err) {
      this.#logger.error(null, err.stack || err.message || String(err));
      return this.#renderError(request, {
        locals,
        status: 500,
        error: err,
        clientAddress,
        prerenderedErrorPageFetch
      });
    } finally {
      await session?.[PERSIST_SYMBOL]();
    }
    if (REROUTABLE_STATUS_CODES.includes(response.status) && // If the body isn't null, that means the user sets the 404 status
    // but uses the current route to handle the 404
    response.body === null && response.headers.get(REROUTE_DIRECTIVE_HEADER) !== "no") {
      return this.#renderError(request, {
        locals,
        response,
        status: response.status,
        // We don't have an error to report here. Passing null means we pass nothing intentionally
        // while undefined means there's no error
        error: response.status === 500 ? null : void 0,
        clientAddress,
        prerenderedErrorPageFetch
      });
    }
    if (response.headers.has(REROUTE_DIRECTIVE_HEADER)) {
      response.headers.delete(REROUTE_DIRECTIVE_HEADER);
    }
    if (addCookieHeader) {
      for (const setCookieHeaderValue of _App.getSetCookieFromResponse(response)) {
        response.headers.append("set-cookie", setCookieHeaderValue);
      }
    }
    Reflect.set(response, responseSentSymbol, true);
    return response;
  }
  setCookieHeaders(response) {
    return getSetCookiesFromResponse(response);
  }
  /**
   * Reads all the cookies written by `Astro.cookie.set()` onto the passed response.
   * For example,
   * ```ts
   * for (const cookie_ of App.getSetCookieFromResponse(response)) {
   *     const cookie: string = cookie_
   * }
   * ```
   * @param response The response to read cookies from.
   * @returns An iterator that yields key-value pairs as equal-sign-separated strings.
   */
  static getSetCookieFromResponse = getSetCookiesFromResponse;
  /**
   * If it is a known error code, try sending the according page (e.g. 404.astro / 500.astro).
   * This also handles pre-rendered /404 or /500 routes
   */
  async #renderError(request, {
    locals,
    status,
    response: originalResponse,
    skipMiddleware = false,
    error: error5,
    clientAddress,
    prerenderedErrorPageFetch
  }) {
    const errorRoutePath = `/${status}${this.#manifest.trailingSlash === "always" ? "/" : ""}`;
    const errorRouteData = matchRoute(errorRoutePath, this.#manifestData);
    const url = new URL(request.url);
    if (errorRouteData) {
      if (errorRouteData.prerender) {
        const maybeDotHtml = errorRouteData.route.endsWith(`/${status}`) ? ".html" : "";
        const statusURL = new URL(
          `${this.#baseWithoutTrailingSlash}/${status}${maybeDotHtml}`,
          url
        );
        if (statusURL.toString() !== request.url) {
          const response2 = await prerenderedErrorPageFetch(statusURL.toString());
          const override = { status, removeContentEncodingHeaders: true };
          return this.#mergeResponses(response2, originalResponse, override);
        }
      }
      const mod = await this.#pipeline.getModuleForRoute(errorRouteData);
      let session;
      try {
        const renderContext = await RenderContext.create({
          locals,
          pipeline: this.#pipeline,
          middleware: skipMiddleware ? NOOP_MIDDLEWARE_FN : void 0,
          pathname: this.#getPathnameFromRequest(request),
          request,
          routeData: errorRouteData,
          status,
          props: { error: error5 },
          clientAddress
        });
        session = renderContext.session;
        const response2 = await renderContext.render(await mod.page());
        return this.#mergeResponses(response2, originalResponse);
      } catch {
        if (skipMiddleware === false) {
          return this.#renderError(request, {
            locals,
            status,
            response: originalResponse,
            skipMiddleware: true,
            clientAddress,
            prerenderedErrorPageFetch
          });
        }
      } finally {
        await session?.[PERSIST_SYMBOL]();
      }
    }
    const response = this.#mergeResponses(new Response(null, { status }), originalResponse);
    Reflect.set(response, responseSentSymbol, true);
    return response;
  }
  #mergeResponses(newResponse, originalResponse, override) {
    let newResponseHeaders = newResponse.headers;
    if (override?.removeContentEncodingHeaders) {
      newResponseHeaders = new Headers(newResponseHeaders);
      newResponseHeaders.delete("Content-Encoding");
      newResponseHeaders.delete("Content-Length");
    }
    if (!originalResponse) {
      if (override !== void 0) {
        return new Response(newResponse.body, {
          status: override.status,
          statusText: newResponse.statusText,
          headers: newResponseHeaders
        });
      }
      return newResponse;
    }
    const status = override?.status ? override.status : originalResponse.status === 200 ? newResponse.status : originalResponse.status;
    try {
      originalResponse.headers.delete("Content-type");
    } catch {
    }
    const mergedHeaders = new Map([
      ...Array.from(newResponseHeaders),
      ...Array.from(originalResponse.headers)
    ]);
    const newHeaders = new Headers();
    for (const [name, value] of mergedHeaders) {
      newHeaders.set(name, value);
    }
    return new Response(newResponse.body, {
      status,
      statusText: status === 200 ? newResponse.statusText : originalResponse.statusText,
      // If you're looking at here for possible bugs, it means that it's not a bug.
      // With the middleware, users can meddle with headers, and we should pass to the 404/500.
      // If users see something weird, it's because they are setting some headers they should not.
      //
      // Although, we don't want it to replace the content-type, because the error page must return `text/html`
      headers: newHeaders
    });
  }
  #getDefaultStatusCode(routeData, pathname) {
    if (!routeData.pattern.test(pathname)) {
      for (const fallbackRoute of routeData.fallbackRoutes) {
        if (fallbackRoute.pattern.test(pathname)) {
          return 302;
        }
      }
    }
    const route = removeTrailingForwardSlash(routeData.route);
    if (route.endsWith("/404")) return 404;
    if (route.endsWith("/500")) return 500;
    return 200;
  }
};
async function handle(manifest2, app, request, env3, context3) {
  const { pathname } = new URL(request.url);
  const bindingName = "SESSION";
  globalThis.__env__ ??= {};
  globalThis.__env__[bindingName] = env3[bindingName];
  if (manifest2.assets.has(pathname)) {
    return env3.ASSETS.fetch(request.url.replace(/\.html$/, ""));
  }
  const routeData = app.match(request);
  if (!routeData) {
    const asset = await env3.ASSETS.fetch(
      request.url.replace(/index.html$/, "").replace(/\.html$/, "")
    );
    if (asset.status !== 404) {
      return asset;
    }
  }
  Reflect.set(request, Symbol.for("astro.clientAddress"), request.headers.get("cf-connecting-ip"));
  const locals = {
    runtime: {
      env: env3,
      cf: request.cf,
      caches,
      ctx: {
        waitUntil: /* @__PURE__ */ __name((promise) => context3.waitUntil(promise), "waitUntil"),
        // Currently not available: https://developers.cloudflare.com/pages/platform/known-issues/#pages-functions
        passThroughOnException: /* @__PURE__ */ __name(() => {
          throw new Error(
            "`passThroughOnException` is currently not available in Cloudflare Pages. See https://developers.cloudflare.com/pages/platform/known-issues/#pages-functions."
          );
        }, "passThroughOnException"),
        props: {}
      }
    }
  };
  const response = await app.render(
    request,
    {
      routeData,
      locals,
      prerenderedErrorPageFetch: /* @__PURE__ */ __name(async (url) => {
        return env3.ASSETS.fetch(url.replace(/\.html$/, ""));
      }, "prerenderedErrorPageFetch")
    }
  );
  if (app.setCookieHeaders) {
    for (const setCookieHeader of app.setCookieHeaders(response)) {
      response.headers.append("Set-Cookie", setCookieHeader);
    }
  }
  return response;
}
__name(handle, "handle");
function createExports(manifest2) {
  const app = new App(manifest2);
  const fetch2 = /* @__PURE__ */ __name(async (request, env3, context3) => {
    return await handle(manifest2, app, request, env3, context3);
  }, "fetch");
  return { default: { fetch: fetch2 } };
}
__name(createExports, "createExports");
var serverEntrypointModule = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExports
}, Symbol.toStringTag, { value: "Module" }));

// .wrangler/tmp/pages-AQW1MV/manifest_r20Y9df8.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_server_B79ahsw9();
init_astro_designed_error_pages_B6wD2ieN();
if (typeof MessageChannel === "undefined") {
  let MessagePort3 = function() {
    this.onmessage = null;
    this._target = null;
  }, MessageChannelPolyfill = function() {
    this.port1 = new MessagePort3();
    this.port2 = new MessagePort3();
    this.port1._target = this.port2;
    this.port2._target = this.port1;
  };
  MessagePort4 = MessagePort3, MessageChannelPolyfill3 = MessageChannelPolyfill;
  __name(MessagePort3, "MessagePort");
  __name(MessageChannelPolyfill, "MessageChannelPolyfill");
  MessagePort3.prototype.postMessage = function(data) {
    var handler = this._target && this._target.onmessage;
    if (typeof handler === "function") {
      handler({ data });
    }
  };
  globalThis.MessageChannel = MessageChannelPolyfill;
}
var MessagePort4;
var MessageChannelPolyfill3;
function sanitizeParams(params) {
  return Object.fromEntries(
    Object.entries(params).map(([key, value]) => {
      if (typeof value === "string") {
        return [key, value.normalize().replace(/#/g, "%23").replace(/\?/g, "%3F")];
      }
      return [key, value];
    })
  );
}
__name(sanitizeParams, "sanitizeParams");
function getParameter(part, params) {
  if (part.spread) {
    return params[part.content.slice(3)] || "";
  }
  if (part.dynamic) {
    if (!params[part.content]) {
      throw new TypeError(`Missing parameter: ${part.content}`);
    }
    return params[part.content];
  }
  return part.content.normalize().replace(/\?/g, "%3F").replace(/#/g, "%23").replace(/%5B/g, "[").replace(/%5D/g, "]");
}
__name(getParameter, "getParameter");
function getSegment(segment, params) {
  const segmentPath = segment.map((part) => getParameter(part, params)).join("");
  return segmentPath ? "/" + segmentPath : "";
}
__name(getSegment, "getSegment");
function getRouteGenerator(segments, addTrailingSlash) {
  return (params) => {
    const sanitizedParams = sanitizeParams(params);
    let trailing = "";
    if (addTrailingSlash === "always" && segments.length) {
      trailing = "/";
    }
    const path3 = segments.map((segment) => getSegment(segment, sanitizedParams)).join("") + trailing;
    return path3 || "/";
  };
}
__name(getRouteGenerator, "getRouteGenerator");
function deserializeRouteData(rawRouteData) {
  return {
    route: rawRouteData.route,
    type: rawRouteData.type,
    pattern: new RegExp(rawRouteData.pattern),
    params: rawRouteData.params,
    component: rawRouteData.component,
    generate: getRouteGenerator(rawRouteData.segments, rawRouteData._meta.trailingSlash),
    pathname: rawRouteData.pathname || void 0,
    segments: rawRouteData.segments,
    prerender: rawRouteData.prerender,
    redirect: rawRouteData.redirect,
    redirectRoute: rawRouteData.redirectRoute ? deserializeRouteData(rawRouteData.redirectRoute) : void 0,
    fallbackRoutes: rawRouteData.fallbackRoutes.map((fallback) => {
      return deserializeRouteData(fallback);
    }),
    isIndex: rawRouteData.isIndex,
    origin: rawRouteData.origin
  };
}
__name(deserializeRouteData, "deserializeRouteData");
function deserializeManifest(serializedManifest) {
  const routes2 = [];
  for (const serializedRoute of serializedManifest.routes) {
    routes2.push({
      ...serializedRoute,
      routeData: deserializeRouteData(serializedRoute.routeData)
    });
    const route = serializedRoute;
    route.routeData = deserializeRouteData(serializedRoute.routeData);
  }
  const assets = new Set(serializedManifest.assets);
  const componentMetadata = new Map(serializedManifest.componentMetadata);
  const inlinedScripts = new Map(serializedManifest.inlinedScripts);
  const clientDirectives = new Map(serializedManifest.clientDirectives);
  const serverIslandNameMap = new Map(serializedManifest.serverIslandNameMap);
  const key = decodeKey(serializedManifest.key);
  return {
    // in case user middleware exists, this no-op middleware will be reassigned (see plugin-ssr.ts)
    middleware() {
      return { onRequest: NOOP_MIDDLEWARE_FN };
    },
    ...serializedManifest,
    assets,
    componentMetadata,
    inlinedScripts,
    clientDirectives,
    routes: routes2,
    serverIslandNameMap,
    key
  };
}
__name(deserializeManifest, "deserializeManifest");
var manifest = deserializeManifest({ "hrefRoot": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/", "cacheDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/node_modules/.astro/", "outDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/dist/", "srcDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/src/", "publicDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/public/", "buildClientDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/dist/", "buildServerDir": "file:///C:/Users/Poste/Desktop/SaaS%20Astro/freecipies-blog/dist/_worker.js/", "adapterName": "@astrojs/cloudflare", "routes": [{ "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "type": "page", "component": "_server-islands.astro", "params": ["name"], "segments": [[{ "content": "_server-islands", "dynamic": false, "spread": false }], [{ "content": "name", "dynamic": true, "spread": false }]], "pattern": "^\\/_server-islands\\/([^/]+?)\\/?$", "prerender": false, "isIndex": false, "fallbackRoutes": [], "route": "/_server-islands/[name]", "origin": "internal", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "type": "endpoint", "isIndex": false, "route": "/_image", "pattern": "^\\/_image\\/?$", "segments": [[{ "content": "_image", "dynamic": false, "spread": false }]], "params": [], "component": "node_modules/.pnpm/@astrojs+cloudflare@12.6.12_f9354d53bede48c7476e55e087cd9165/node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint.js", "pathname": "/_image", "prerender": false, "fallbackRoutes": [], "origin": "internal", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/about.Dcxuk6NK.css" }, { "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }], "routeData": { "route": "/about", "isIndex": false, "type": "page", "pattern": "^\\/about\\/?$", "segments": [[{ "content": "about", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/about.astro", "pathname": "/about", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "inline", "content": "html,body,#admin-root[data-astro-cid-oigiyrrr]{height:100%;margin:0;padding:0}\n" }, { "type": "external", "src": "/_astro/index.DeDslQpt.css" }, { "type": "external", "src": "/_astro/AdminApp.D7Qti98B.css" }], "routeData": { "route": "/admin/[...path]", "isIndex": false, "type": "page", "pattern": "^\\/admin(?:\\/(.*?))?\\/?$", "segments": [[{ "content": "admin", "dynamic": false, "spread": false }], [{ "content": "...path", "dynamic": true, "spread": true }]], "params": ["...path"], "component": "src/pages/admin/[...path].astro", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/admin/articles/[id]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/admin\\/articles\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "admin", "dynamic": false, "spread": false }], [{ "content": "articles", "dynamic": false, "spread": false }], [{ "content": "id", "dynamic": true, "spread": false }]], "params": ["id"], "component": "src/pages/api/admin/articles/[id].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/articles/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/articles\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "articles", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/articles/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/articles", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/articles\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "articles", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/articles.ts", "pathname": "/api/articles", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/auth/login", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/auth\\/login\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "auth", "dynamic": false, "spread": false }], [{ "content": "login", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/auth/login.ts", "pathname": "/api/auth/login", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/auth/refresh", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/auth\\/refresh\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "auth", "dynamic": false, "spread": false }], [{ "content": "refresh", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/auth/refresh.ts", "pathname": "/api/auth/refresh", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/auth/verify", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/auth\\/verify\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "auth", "dynamic": false, "spread": false }], [{ "content": "verify", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/auth/verify.ts", "pathname": "/api/auth/verify", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/authors/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/authors\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "authors", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/authors/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/authors", "isIndex": true, "type": "endpoint", "pattern": "^\\/api\\/authors\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "authors", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/authors/index.ts", "pathname": "/api/authors", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/authors", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/authors\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "authors", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/authors.ts", "pathname": "/api/authors", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/branding/[...slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/branding(?:\\/(.*?))?\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "branding", "dynamic": false, "spread": false }], [{ "content": "...slug", "dynamic": true, "spread": true }]], "params": ["...slug"], "component": "src/pages/api/branding/[...slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/categories/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/categories\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "categories", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/categories/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/categories", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/categories\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "categories", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/categories.ts", "pathname": "/api/categories", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/content", "isIndex": true, "type": "endpoint", "pattern": "^\\/api\\/content\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "content", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/content/index.ts", "pathname": "/api/content", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/images/[...path]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/images(?:\\/(.*?))?\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "images", "dynamic": false, "spread": false }], [{ "content": "...path", "dynamic": true, "spread": true }]], "params": ["...path"], "component": "src/pages/api/images/[...path].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media/bulk-delete", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/bulk-delete\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }], [{ "content": "bulk-delete", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/media/bulk-delete.ts", "pathname": "/api/media/bulk-delete", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media/confirm", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/confirm\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }], [{ "content": "confirm", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/media/confirm.ts", "pathname": "/api/media/confirm", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media/upload-urls", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/upload-urls\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }], [{ "content": "upload-urls", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/media/upload-urls.ts", "pathname": "/api/media/upload-urls", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media/upload-variant", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/upload-variant\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }], [{ "content": "upload-variant", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/media/upload-variant.ts", "pathname": "/api/media/upload-variant", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media/[id]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }], [{ "content": "id", "dynamic": true, "spread": false }]], "params": ["id"], "component": "src/pages/api/media/[id].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/media", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/media\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "media", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/media.ts", "pathname": "/api/media", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/pins", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/pins\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "pins", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/pins.ts", "pathname": "/api/pins", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/pinterest-boards", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/pinterest-boards\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "pinterest-boards", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/pinterest-boards.ts", "pathname": "/api/pinterest-boards", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/proxy-image", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/proxy-image\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "proxy-image", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/proxy-image.ts", "pathname": "/api/proxy-image", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/recipes/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/recipes\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "recipes", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/recipes/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/recipes", "isIndex": true, "type": "endpoint", "pattern": "^\\/api\\/recipes\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "recipes", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/recipes/index.ts", "pathname": "/api/recipes", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/recipes", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/recipes\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "recipes", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/recipes.ts", "pathname": "/api/recipes", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/roundups/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/roundups\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "roundups", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/roundups/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/roundups", "isIndex": true, "type": "endpoint", "pattern": "^\\/api\\/roundups\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "roundups", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/roundups/index.ts", "pathname": "/api/roundups", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/seed-images", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/seed-images\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "seed-images", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/seed-images.ts", "pathname": "/api/seed-images", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/settings/image-upload", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/settings\\/image-upload\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "settings", "dynamic": false, "spread": false }], [{ "content": "image-upload", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/settings/image-upload.ts", "pathname": "/api/settings/image-upload", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/stats/dashboard", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/stats\\/dashboard\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "stats", "dynamic": false, "spread": false }], [{ "content": "dashboard", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/stats/dashboard.ts", "pathname": "/api/stats/dashboard", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/stats/popular", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/stats\\/popular\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "stats", "dynamic": false, "spread": false }], [{ "content": "popular", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/stats/popular.ts", "pathname": "/api/stats/popular", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/tags/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/tags\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "tags", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/tags/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/tags", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/tags\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "tags", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/tags.ts", "pathname": "/api/tags", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/templates/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/templates\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "templates", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/templates/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/templates", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/templates\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "templates", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/templates.ts", "pathname": "/api/templates", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/upload-font", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/upload-font\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "upload-font", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/upload-font.ts", "pathname": "/api/upload-font", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/upload-from-url", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/upload-from-url\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "upload-from-url", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/upload-from-url.ts", "pathname": "/api/upload-from-url", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/upload-image", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/upload-image\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "upload-image", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/upload-image.ts", "pathname": "/api/upload-image", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/upload-thumbnail", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/upload-thumbnail\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "upload-thumbnail", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/api/upload-thumbnail.ts", "pathname": "/api/upload-thumbnail", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/api/views/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/api\\/views\\/([^/]+?)\\/?$", "segments": [[{ "content": "api", "dynamic": false, "spread": false }], [{ "content": "views", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/api/views/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "inline", "content": ".author-profile[data-astro-cid-7aexiinu]{min-height:100vh}.hero-section[data-astro-cid-7aexiinu]{background:linear-gradient(135deg,#fff3e0,#ffe0b2);padding:clamp(3rem,8vw,5rem) 0}.hero-container[data-astro-cid-7aexiinu]{max-width:1000px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.author-header[data-astro-cid-7aexiinu]{display:flex;flex-direction:column;align-items:center;text-align:center;gap:2rem}@media(min-width:768px){.author-header[data-astro-cid-7aexiinu]{flex-direction:row;text-align:left;align-items:flex-start}}.avatar-container[data-astro-cid-7aexiinu]{flex-shrink:0}.author-avatar[data-astro-cid-7aexiinu]{width:150px;height:150px;border-radius:50%;object-fit:cover;box-shadow:0 8px 24px #00000026}.avatar-placeholder[data-astro-cid-7aexiinu]{width:150px;height:150px;border-radius:50%;background:linear-gradient(135deg,#ff6b35,#f7931e);display:flex;align-items:center;justify-content:center;box-shadow:0 8px 24px #00000026}.avatar-placeholder[data-astro-cid-7aexiinu] span[data-astro-cid-7aexiinu]{font-size:4rem;font-weight:700;color:#fff}.author-info[data-astro-cid-7aexiinu]{flex:1}.author-name[data-astro-cid-7aexiinu]{font-size:clamp(2rem,4vw,2.5rem);font-weight:800;margin:0;color:#1a1a1a}.author-job[data-astro-cid-7aexiinu]{font-size:1.125rem;color:#ff6b35;margin:.5rem 0 0;font-weight:600}.author-description[data-astro-cid-7aexiinu]{font-size:1rem;color:#555;line-height:1.6;margin:1rem 0 0;max-width:600px}.author-stats[data-astro-cid-7aexiinu]{display:flex;gap:2rem;margin-top:1.5rem}.stat[data-astro-cid-7aexiinu]{display:flex;flex-direction:column}.stat-value[data-astro-cid-7aexiinu]{font-size:1.75rem;font-weight:700;color:#1a1a1a}.stat-label[data-astro-cid-7aexiinu]{font-size:.875rem;color:#666}.social-links[data-astro-cid-7aexiinu]{display:flex;gap:1rem;margin-top:1.5rem;flex-wrap:wrap}.social-link[data-astro-cid-7aexiinu]{padding:.5rem 1rem;background:#fff;border-radius:8px;color:#333;text-decoration:none;font-size:.875rem;font-weight:500;transition:all .2s ease;box-shadow:0 2px 8px #00000014}.social-link[data-astro-cid-7aexiinu]:hover{background:#ff6b35;color:#fff}.bio-section[data-astro-cid-7aexiinu]{padding:clamp(2rem,5vw,3rem) 0;background:#fff}.section-container[data-astro-cid-7aexiinu]{max-width:1200px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.section-title[data-astro-cid-7aexiinu]{font-size:clamp(1.5rem,3vw,2rem);font-weight:700;margin:0 0 1.5rem;color:#1a1a1a}.bio-content[data-astro-cid-7aexiinu]{max-width:800px}.bio-content[data-astro-cid-7aexiinu] p[data-astro-cid-7aexiinu]{font-size:1rem;line-height:1.8;color:#444;margin:0 0 1rem}.recipes-section[data-astro-cid-7aexiinu]{padding:clamp(3rem,8vw,5rem) 0;background:#f9f9f9}.section-header[data-astro-cid-7aexiinu]{display:flex;justify-content:space-between;align-items:center;margin-bottom:2rem;flex-wrap:wrap;gap:1rem}.recipe-count[data-astro-cid-7aexiinu]{font-size:.875rem;color:#666;background:#fff;padding:.5rem 1rem;border-radius:20px}.recipes-grid[data-astro-cid-7aexiinu]{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:2rem}.empty-state[data-astro-cid-7aexiinu]{text-align:center;padding:4rem 0;color:#666}@media(max-width:768px){.recipes-grid[data-astro-cid-7aexiinu]{grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:1.5rem}}\n" }], "routeData": { "route": "/authors/[slug]", "isIndex": false, "type": "page", "pattern": "^\\/authors\\/([^/]+?)\\/?$", "segments": [[{ "content": "authors", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/authors/[slug].astro", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "inline", "content": ".author-card[data-astro-cid-32rj7774]{background:#fff;border-radius:16px;overflow:hidden;box-shadow:0 4px 12px #00000014;transition:all .3s ease}.author-card[data-astro-cid-32rj7774]:hover{transform:translateY(-4px);box-shadow:0 8px 24px #0000001f}.author-link[data-astro-cid-32rj7774]{display:flex;flex-direction:column;align-items:center;padding:2rem;text-decoration:none;color:inherit}.author-avatar[data-astro-cid-32rj7774]{width:120px;height:120px;border-radius:50%;overflow:hidden;margin-bottom:1.25rem;box-shadow:0 4px 12px #0000001a;flex-shrink:0}.author-avatar[data-astro-cid-32rj7774] img[data-astro-cid-32rj7774]{width:100%;height:100%;object-fit:cover}.avatar-placeholder[data-astro-cid-32rj7774]{width:100%;height:100%;background:linear-gradient(135deg,#ff6b35,#f7931e);display:flex;align-items:center;justify-content:center}.avatar-placeholder[data-astro-cid-32rj7774] span[data-astro-cid-32rj7774]{font-size:3rem;font-weight:700;color:#fff}.author-info[data-astro-cid-32rj7774]{text-align:center}.author-name[data-astro-cid-32rj7774]{font-size:1.25rem;font-weight:700;color:#1a1a1a;margin:0 0 .25rem;transition:color .2s ease}.author-card[data-astro-cid-32rj7774]:hover .author-name[data-astro-cid-32rj7774]{color:#ff6b35}.author-job[data-astro-cid-32rj7774]{font-size:.875rem;color:#666;margin:0 0 .75rem;font-weight:500}.author-description[data-astro-cid-32rj7774]{font-size:.875rem;color:#555;line-height:1.5;margin:0;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.author-meta[data-astro-cid-32rj7774]{margin-top:1rem;padding-top:1rem;border-top:1px solid #eee}.article-count[data-astro-cid-32rj7774]{display:inline-flex;align-items:center;gap:.5rem;font-size:.875rem;color:#666;font-weight:500}.icon[data-astro-cid-32rj7774]{width:16px;height:16px}@media(max-width:768px){.author-link[data-astro-cid-32rj7774]{padding:1.5rem}.author-avatar[data-astro-cid-32rj7774]{width:100px;height:100px}.avatar-placeholder[data-astro-cid-32rj7774] span[data-astro-cid-32rj7774]{font-size:2.5rem}}.authors-page[data-astro-cid-5ijxez7g]{min-height:100vh}.hero-section[data-astro-cid-5ijxez7g]{background:linear-gradient(135deg,#fff3e0,#ffe0b2);padding:clamp(3rem,8vw,5rem) 0;text-align:center}.hero-container[data-astro-cid-5ijxez7g]{max-width:800px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.hero-title[data-astro-cid-5ijxez7g]{font-size:clamp(2rem,5vw,3rem);font-weight:800;margin:0 0 1rem;color:#1a1a1a;letter-spacing:-.02em}.hero-subtitle[data-astro-cid-5ijxez7g]{font-size:clamp(1rem,2vw,1.125rem);line-height:1.6;color:#555;margin:0}.authors-section[data-astro-cid-5ijxez7g]{padding:clamp(3rem,8vw,5rem) 0;background:#f9f9f9}.section-container[data-astro-cid-5ijxez7g]{max-width:1200px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.authors-grid[data-astro-cid-5ijxez7g]{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:2rem}.empty-state[data-astro-cid-5ijxez7g]{text-align:center;padding:4rem 0;color:#666}@media(max-width:768px){.authors-grid[data-astro-cid-5ijxez7g]{grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:1.5rem}}\n" }], "routeData": { "route": "/authors", "isIndex": true, "type": "page", "pattern": "^\\/authors\\/?$", "segments": [[{ "content": "authors", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/authors/index.astro", "pathname": "/authors", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "external", "src": "/_astro/_slug_.Dv7FFRwW.css" }, { "type": "inline", "content": ".popular-recipes-widget[data-astro-cid-gjgjpeik]{background:#fff;border-radius:12px;padding:1.5rem;box-shadow:0 1px 3px #00000014}.widget-header[data-astro-cid-gjgjpeik]{display:flex;align-items:center;gap:.75rem;margin-bottom:1.5rem}.header-dot[data-astro-cid-gjgjpeik]{width:10px;height:10px;border-radius:50%;background:#f36}.widget-header[data-astro-cid-gjgjpeik] h3[data-astro-cid-gjgjpeik]{font-size:1.125rem;font-weight:700;color:#111;margin:0}.recipe-list[data-astro-cid-gjgjpeik]{display:flex;flex-direction:column;gap:1rem}.recipe-item[data-astro-cid-gjgjpeik]{display:flex;align-items:center;gap:1rem;text-decoration:none;padding:.5rem;margin:-.5rem;border-radius:8px;transition:background .2s ease}.recipe-item[data-astro-cid-gjgjpeik]:hover{background:#f8f8f8}.recipe-content[data-astro-cid-gjgjpeik]{flex:1;min-width:0}.recipe-title[data-astro-cid-gjgjpeik]{font-size:.9375rem;font-weight:600;color:#222;margin:0 0 .35rem;line-height:1.3;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.recipe-item[data-astro-cid-gjgjpeik]:hover .recipe-title[data-astro-cid-gjgjpeik]{color:#f36}.recipe-meta[data-astro-cid-gjgjpeik]{display:flex;align-items:center;flex-wrap:wrap;gap:.35rem;font-size:.8125rem;color:#5f5f5f}.category[data-astro-cid-gjgjpeik]{color:#666}.separator[data-astro-cid-gjgjpeik]{color:#9aa0a6}.cook-time[data-astro-cid-gjgjpeik]{color:#4b5563;font-weight:600}.recipe-thumb[data-astro-cid-gjgjpeik]{width:70px;height:70px;border-radius:50%;object-fit:cover;flex-shrink:0}.no-recipes[data-astro-cid-gjgjpeik]{color:#888;font-size:.875rem;text-align:center;padding:1rem 0}.newsletter-widget[data-astro-cid-e4daz5ew]{background:#1a1a1a;border-radius:12px;padding:2rem 1.5rem;text-align:center}.widget-icon[data-astro-cid-e4daz5ew]{margin-bottom:1rem}.widget-icon[data-astro-cid-e4daz5ew] svg[data-astro-cid-e4daz5ew]{width:48px;height:48px}.widget-title[data-astro-cid-e4daz5ew]{font-size:1.25rem;font-weight:700;color:#fff;margin:0 0 .5rem;line-height:1.3}.widget-subtitle[data-astro-cid-e4daz5ew]{font-size:.875rem;color:#999;margin:0 0 1.5rem;line-height:1.5}.subscribe-form[data-astro-cid-e4daz5ew]{display:flex;flex-direction:column;gap:.75rem}.email-input[data-astro-cid-e4daz5ew]{width:100%;padding:.875rem 1rem;background:#2a2a2a;border:1px solid #3a3a3a;border-radius:8px;color:#fff;font-size:.9375rem;transition:all .2s ease}.email-input[data-astro-cid-e4daz5ew]::placeholder{color:#666}.email-input[data-astro-cid-e4daz5ew]:focus{outline:none;border-color:#f36;background:#333}.subscribe-btn[data-astro-cid-e4daz5ew]{width:100%;padding:.875rem 1.5rem;background:linear-gradient(135deg,#f36,#ff6b35);border:none;border-radius:8px;color:#fff;font-size:.9375rem;font-weight:600;cursor:pointer;transition:all .2s ease}.subscribe-btn[data-astro-cid-e4daz5ew]:hover{transform:translateY(-1px);box-shadow:0 4px 12px #ff33664d}.subscribe-btn[data-astro-cid-e4daz5ew]:active{transform:translateY(0)}\n" }], "routeData": { "route": "/categories/[slug]", "isIndex": false, "type": "page", "pattern": "^\\/categories\\/([^/]+?)\\/?$", "segments": [[{ "content": "categories", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/categories/[slug].astro", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }], "routeData": { "route": "/categories", "isIndex": true, "type": "page", "pattern": "^\\/categories\\/?$", "segments": [[{ "content": "categories", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/categories/index.astro", "pathname": "/categories", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/contact.CKDPVv9J.css" }, { "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }], "routeData": { "route": "/contact", "isIndex": false, "type": "page", "pattern": "^\\/contact\\/?$", "segments": [[{ "content": "contact", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/contact.astro", "pathname": "/contact", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/faqs.SjqYPRjk.css" }, { "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }], "routeData": { "route": "/faqs", "isIndex": false, "type": "page", "pattern": "^\\/faqs\\/?$", "segments": [[{ "content": "faqs", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/faqs.astro", "pathname": "/faqs", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/feed/[slug]", "isIndex": false, "type": "endpoint", "pattern": "^\\/feed\\/([^/]+?)\\/?$", "segments": [[{ "content": "feed", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/feed/[slug].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/images/[...key]", "isIndex": false, "type": "endpoint", "pattern": "^\\/images(?:\\/(.*?))?\\/?$", "segments": [[{ "content": "images", "dynamic": false, "spread": false }], [{ "content": "...key", "dynamic": true, "spread": true }]], "params": ["...key"], "component": "src/pages/images/[...key].ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "external", "src": "/_astro/_slug_.48QIQ_n-.css" }, { "type": "inline", "content": ".popular-recipes-widget[data-astro-cid-gjgjpeik]{background:#fff;border-radius:12px;padding:1.5rem;box-shadow:0 1px 3px #00000014}.widget-header[data-astro-cid-gjgjpeik]{display:flex;align-items:center;gap:.75rem;margin-bottom:1.5rem}.header-dot[data-astro-cid-gjgjpeik]{width:10px;height:10px;border-radius:50%;background:#f36}.widget-header[data-astro-cid-gjgjpeik] h3[data-astro-cid-gjgjpeik]{font-size:1.125rem;font-weight:700;color:#111;margin:0}.recipe-list[data-astro-cid-gjgjpeik]{display:flex;flex-direction:column;gap:1rem}.recipe-item[data-astro-cid-gjgjpeik]{display:flex;align-items:center;gap:1rem;text-decoration:none;padding:.5rem;margin:-.5rem;border-radius:8px;transition:background .2s ease}.recipe-item[data-astro-cid-gjgjpeik]:hover{background:#f8f8f8}.recipe-content[data-astro-cid-gjgjpeik]{flex:1;min-width:0}.recipe-title[data-astro-cid-gjgjpeik]{font-size:.9375rem;font-weight:600;color:#222;margin:0 0 .35rem;line-height:1.3;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.recipe-item[data-astro-cid-gjgjpeik]:hover .recipe-title[data-astro-cid-gjgjpeik]{color:#f36}.recipe-meta[data-astro-cid-gjgjpeik]{display:flex;align-items:center;flex-wrap:wrap;gap:.35rem;font-size:.8125rem;color:#5f5f5f}.category[data-astro-cid-gjgjpeik]{color:#666}.separator[data-astro-cid-gjgjpeik]{color:#9aa0a6}.cook-time[data-astro-cid-gjgjpeik]{color:#4b5563;font-weight:600}.recipe-thumb[data-astro-cid-gjgjpeik]{width:70px;height:70px;border-radius:50%;object-fit:cover;flex-shrink:0}.no-recipes[data-astro-cid-gjgjpeik]{color:#888;font-size:.875rem;text-align:center;padding:1rem 0}.newsletter-widget[data-astro-cid-e4daz5ew]{background:#1a1a1a;border-radius:12px;padding:2rem 1.5rem;text-align:center}.widget-icon[data-astro-cid-e4daz5ew]{margin-bottom:1rem}.widget-icon[data-astro-cid-e4daz5ew] svg[data-astro-cid-e4daz5ew]{width:48px;height:48px}.widget-title[data-astro-cid-e4daz5ew]{font-size:1.25rem;font-weight:700;color:#fff;margin:0 0 .5rem;line-height:1.3}.widget-subtitle[data-astro-cid-e4daz5ew]{font-size:.875rem;color:#999;margin:0 0 1.5rem;line-height:1.5}.subscribe-form[data-astro-cid-e4daz5ew]{display:flex;flex-direction:column;gap:.75rem}.email-input[data-astro-cid-e4daz5ew]{width:100%;padding:.875rem 1rem;background:#2a2a2a;border:1px solid #3a3a3a;border-radius:8px;color:#fff;font-size:.9375rem;transition:all .2s ease}.email-input[data-astro-cid-e4daz5ew]::placeholder{color:#666}.email-input[data-astro-cid-e4daz5ew]:focus{outline:none;border-color:#f36;background:#333}.subscribe-btn[data-astro-cid-e4daz5ew]{width:100%;padding:.875rem 1.5rem;background:linear-gradient(135deg,#f36,#ff6b35);border:none;border-radius:8px;color:#fff;font-size:.9375rem;font-weight:600;cursor:pointer;transition:all .2s ease}.subscribe-btn[data-astro-cid-e4daz5ew]:hover{transform:translateY(-1px);box-shadow:0 4px 12px #ff33664d}.subscribe-btn[data-astro-cid-e4daz5ew]:active{transform:translateY(0)}\n" }], "routeData": { "route": "/recipes/[slug]", "isIndex": false, "type": "page", "pattern": "^\\/recipes\\/([^/]+?)\\/?$", "segments": [[{ "content": "recipes", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/recipes/[slug].astro", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "external", "src": "/_astro/index.DhFFEtNm.css" }], "routeData": { "route": "/recipes", "isIndex": true, "type": "page", "pattern": "^\\/recipes\\/?$", "segments": [[{ "content": "recipes", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/recipes/index.astro", "pathname": "/recipes", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/rss/pinterest/[board].xml", "isIndex": false, "type": "endpoint", "pattern": "^\\/rss\\/pinterest\\/([^/]+?)\\.xml\\/?$", "segments": [[{ "content": "rss", "dynamic": false, "spread": false }], [{ "content": "pinterest", "dynamic": false, "spread": false }], [{ "content": "board", "dynamic": true, "spread": false }, { "content": ".xml", "dynamic": false, "spread": false }]], "params": ["board"], "component": "src/pages/rss/pinterest/[board].xml.ts", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/rss/pinterest.xml", "isIndex": false, "type": "endpoint", "pattern": "^\\/rss\\/pinterest\\.xml\\/?$", "segments": [[{ "content": "rss", "dynamic": false, "spread": false }], [{ "content": "pinterest.xml", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/rss/pinterest.xml.ts", "pathname": "/rss/pinterest.xml", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/rss/recipes.xml", "isIndex": false, "type": "endpoint", "pattern": "^\\/rss\\/recipes\\.xml\\/?$", "segments": [[{ "content": "rss", "dynamic": false, "spread": false }], [{ "content": "recipes.xml", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/rss/recipes.xml.ts", "pathname": "/rss/recipes.xml", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [], "routeData": { "route": "/sitemap", "isIndex": false, "type": "endpoint", "pattern": "^\\/sitemap\\/?$", "segments": [[{ "content": "sitemap", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/sitemap.ts", "pathname": "/sitemap", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "inline", "content": ".tag-archive[data-astro-cid-ytpo4vtr]{min-height:100vh}.hero-section[data-astro-cid-ytpo4vtr]{background:linear-gradient(135deg,#e8f5e9,#c8e6c9);padding:clamp(3rem,8vw,5rem) 0;text-align:center}.hero-container[data-astro-cid-ytpo4vtr]{max-width:800px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.hero-title[data-astro-cid-ytpo4vtr]{font-size:clamp(2rem,5vw,3rem);font-weight:800;margin:0 0 .75rem;color:#1a1a1a;letter-spacing:-.02em}.tag-meta[data-astro-cid-ytpo4vtr]{display:flex;justify-content:center;gap:1rem}.recipe-count[data-astro-cid-ytpo4vtr]{background:#fff;padding:.5rem 1rem;border-radius:20px;font-size:.875rem;font-weight:500;color:#333}.recipes-section[data-astro-cid-ytpo4vtr]{padding:clamp(3rem,8vw,5rem) 0;background:#fafafa}.section-container[data-astro-cid-ytpo4vtr]{max-width:1200px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.section-header[data-astro-cid-ytpo4vtr]{margin-bottom:2rem}.section-title[data-astro-cid-ytpo4vtr]{font-size:clamp(1.5rem,3vw,2rem);font-weight:700;margin:0;color:#1a1a1a}.recipes-grid[data-astro-cid-ytpo4vtr]{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:2rem}.empty-state[data-astro-cid-ytpo4vtr]{text-align:center;padding:4rem 0;color:#666}.back-section[data-astro-cid-ytpo4vtr]{padding:2rem 0;background:#fff;border-top:1px solid #eee}.back-link[data-astro-cid-ytpo4vtr]{display:inline-flex;align-items:center;color:#b45309;text-decoration:none;font-weight:500;transition:color .2s ease}.back-link[data-astro-cid-ytpo4vtr]:hover{color:#92400e}@media(max-width:768px){.recipes-grid[data-astro-cid-ytpo4vtr]{grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:1.5rem}}\n" }], "routeData": { "route": "/tags/[slug]", "isIndex": false, "type": "page", "pattern": "^\\/tags\\/([^/]+?)\\/?$", "segments": [[{ "content": "tags", "dynamic": false, "spread": false }], [{ "content": "slug", "dynamic": true, "spread": false }]], "params": ["slug"], "component": "src/pages/tags/[slug].astro", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "inline", "content": ".tag-card[data-astro-cid-zvzsvsys]{display:block;background:#fff;border-radius:12px;overflow:hidden;text-decoration:none;color:inherit;box-shadow:0 2px 8px #0000000f;transition:all .3s ease;border:1px solid #eee}.tag-card[data-astro-cid-zvzsvsys]:hover{transform:translateY(-3px);box-shadow:0 6px 20px #0000001a;border-color:#ff6b35}.tag-content[data-astro-cid-zvzsvsys]{display:flex;align-items:center;gap:1rem;padding:1rem}.tag-image[data-astro-cid-zvzsvsys]{width:60px;height:60px;border-radius:8px;overflow:hidden;flex-shrink:0}.tag-image[data-astro-cid-zvzsvsys] img[data-astro-cid-zvzsvsys]{width:100%;height:100%;object-fit:cover}.tag-info[data-astro-cid-zvzsvsys]{flex:1;min-width:0}.tag-label[data-astro-cid-zvzsvsys]{font-size:1rem;font-weight:600;color:#1a1a1a;margin:0;transition:color .2s ease}.tag-card[data-astro-cid-zvzsvsys]:hover .tag-label[data-astro-cid-zvzsvsys]{color:#ff6b35}.tag-headline[data-astro-cid-zvzsvsys]{font-size:.8rem;color:#666;margin:.25rem 0 0;line-height:1.4;display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden}.article-count[data-astro-cid-zvzsvsys]{display:inline-block;margin-top:.5rem;font-size:.75rem;color:#555;background:#ececec;padding:.25rem .5rem;border-radius:4px}.tags-page[data-astro-cid-os4i7owy]{min-height:100vh}.hero-section[data-astro-cid-os4i7owy]{background:linear-gradient(135deg,#e8f5e9,#c8e6c9);padding:clamp(3rem,8vw,5rem) 0;text-align:center}.hero-container[data-astro-cid-os4i7owy]{max-width:800px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.hero-title[data-astro-cid-os4i7owy]{font-size:clamp(2rem,5vw,3rem);font-weight:800;margin:0 0 1rem;color:#1a1a1a;letter-spacing:-.02em}.hero-subtitle[data-astro-cid-os4i7owy]{font-size:clamp(1rem,2vw,1.125rem);line-height:1.6;color:#555;margin:0}.tags-section[data-astro-cid-os4i7owy]{padding:clamp(3rem,8vw,5rem) 0;background:#fafafa}.section-container[data-astro-cid-os4i7owy]{max-width:1200px;margin:0 auto;padding:0 clamp(1rem,3vw,1.5rem)}.tags-grid[data-astro-cid-os4i7owy]{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:1rem}.empty-state[data-astro-cid-os4i7owy]{text-align:center;padding:4rem 0;color:#666}@media(max-width:768px){.tags-grid[data-astro-cid-os4i7owy]{grid-template-columns:1fr;gap:.75rem}}\n" }], "routeData": { "route": "/tags", "isIndex": true, "type": "page", "pattern": "^\\/tags\\/?$", "segments": [[{ "content": "tags", "dynamic": false, "spread": false }]], "params": [], "component": "src/pages/tags/index.astro", "pathname": "/tags", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }, { "file": "", "links": [], "scripts": [], "styles": [{ "type": "external", "src": "/_astro/_slug_.VpO_Cw2U.css" }, { "type": "external", "src": "/_astro/index.B9h2MWSx.css" }], "routeData": { "route": "/", "isIndex": true, "type": "page", "pattern": "^\\/$", "segments": [], "params": [], "component": "src/pages/index.astro", "pathname": "/", "prerender": false, "fallbackRoutes": [], "distURL": [], "origin": "project", "_meta": { "trailingSlash": "ignore" } } }], "site": "https://localhost:4321", "base": "/", "trailingSlash": "ignore", "compressHTML": true, "componentMetadata": [["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/admin/[...path].astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/[slug].astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/about.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/[slug].astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/authors/index.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/[slug].astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/categories/index.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/faqs.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/recipes/index.astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/[slug].astro", { "propagation": "none", "containsHead": true }], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/tags/index.astro", { "propagation": "none", "containsHead": true }]], "renderers": [], "clientDirectives": [["idle", '(()=>{var l=(n,t)=>{let i=async()=>{await(await n())()},e=typeof t.value=="object"?t.value:void 0,s={timeout:e==null?void 0:e.timeout};"requestIdleCallback"in window?window.requestIdleCallback(i,s):setTimeout(i,s.timeout||200)};(self.Astro||(self.Astro={})).idle=l;window.dispatchEvent(new Event("astro:idle"));})();'], ["load", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();'], ["media", '(()=>{var n=(a,t)=>{let i=async()=>{await(await a())()};if(t.value){let e=matchMedia(t.value);e.matches?i():e.addEventListener("change",i,{once:!0})}};(self.Astro||(self.Astro={})).media=n;window.dispatchEvent(new Event("astro:media"));})();'], ["only", '(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();'], ["visible", '(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();']], "entryModules": { "\0virtual:astro:actions/noop-entrypoint": "noop-entrypoint.mjs", "\0@astro-page:src/pages/about@_@astro": "pages/about.astro.mjs", "\0@astro-page:src/pages/admin/[...path]@_@astro": "pages/admin/_---path_.astro.mjs", "\0@astro-page:src/pages/api/admin/articles/[id]@_@ts": "pages/api/admin/articles/_id_.astro.mjs", "\0@astro-page:src/pages/api/articles/[slug]@_@ts": "pages/api/articles/_slug_.astro.mjs", "\0@astro-page:src/pages/api/articles@_@ts": "pages/api/articles.astro.mjs", "\0@astro-page:src/pages/api/auth/login@_@ts": "pages/api/auth/login.astro.mjs", "\0@astro-page:src/pages/api/auth/refresh@_@ts": "pages/api/auth/refresh.astro.mjs", "\0@astro-page:src/pages/api/auth/verify@_@ts": "pages/api/auth/verify.astro.mjs", "\0@astro-page:src/pages/api/authors/[slug]@_@ts": "pages/api/authors/_slug_.astro.mjs", "\0@astro-page:src/pages/api/authors/index@_@ts": "pages/api/authors.astro.mjs", "\0@astro-page:src/pages/api/authors@_@ts": "pages/api/authors.astro2.mjs", "\0@astro-page:src/pages/api/branding/[...slug]@_@ts": "pages/api/branding/_---slug_.astro.mjs", "\0@astro-page:src/pages/api/categories/[slug]@_@ts": "pages/api/categories/_slug_.astro.mjs", "\0@astro-page:src/pages/api/categories@_@ts": "pages/api/categories.astro.mjs", "\0@astro-page:src/pages/api/content/index@_@ts": "pages/api/content.astro.mjs", "\0@astro-page:src/pages/api/images/[...path]@_@ts": "pages/api/images/_---path_.astro.mjs", "\0@astro-page:src/pages/api/media/bulk-delete@_@ts": "pages/api/media/bulk-delete.astro.mjs", "\0@astro-page:src/pages/api/media/confirm@_@ts": "pages/api/media/confirm.astro.mjs", "\0@astro-page:src/pages/api/media/upload-variant@_@ts": "pages/api/media/upload-variant.astro.mjs", "\0@astro-page:src/pages/api/media/[id]@_@ts": "pages/api/media/_id_.astro.mjs", "\0@astro-page:src/pages/api/media@_@ts": "pages/api/media.astro.mjs", "\0@astro-page:src/pages/api/pins@_@ts": "pages/api/pins.astro.mjs", "\0@astro-page:src/pages/api/pinterest-boards@_@ts": "pages/api/pinterest-boards.astro.mjs", "\0@astro-page:src/pages/api/proxy-image@_@ts": "pages/api/proxy-image.astro.mjs", "\0@astro-page:src/pages/api/recipes/index@_@ts": "pages/api/recipes.astro.mjs", "\0@astro-page:src/pages/api/roundups/[slug]@_@ts": "pages/api/roundups/_slug_.astro.mjs", "\0@astro-page:src/pages/api/roundups/index@_@ts": "pages/api/roundups.astro.mjs", "\0@astro-page:src/pages/api/seed-images@_@ts": "pages/api/seed-images.astro.mjs", "\0@astro-page:src/pages/api/settings/image-upload@_@ts": "pages/api/settings/image-upload.astro.mjs", "\0@astro-page:src/pages/api/stats/dashboard@_@ts": "pages/api/stats/dashboard.astro.mjs", "\0@astro-page:src/pages/api/stats/popular@_@ts": "pages/api/stats/popular.astro.mjs", "\0@astro-page:src/pages/api/tags/[slug]@_@ts": "pages/api/tags/_slug_.astro.mjs", "\0@astro-page:src/pages/api/tags@_@ts": "pages/api/tags.astro.mjs", "\0@astro-page:src/pages/api/templates/[slug]@_@ts": "pages/api/templates/_slug_.astro.mjs", "\0@astro-page:src/pages/api/templates@_@ts": "pages/api/templates.astro.mjs", "\0@astro-page:src/pages/api/upload-font@_@ts": "pages/api/upload-font.astro.mjs", "\0@astro-page:src/pages/api/upload-from-url@_@ts": "pages/api/upload-from-url.astro.mjs", "\0@astro-page:src/pages/api/upload-image@_@ts": "pages/api/upload-image.astro.mjs", "\0@astro-page:src/pages/api/upload-thumbnail@_@ts": "pages/api/upload-thumbnail.astro.mjs", "\0@astro-page:src/pages/api/views/[slug]@_@ts": "pages/api/views/_slug_.astro.mjs", "\0@astro-page:src/pages/authors/[slug]@_@astro": "pages/authors/_slug_.astro.mjs", "\0@astro-page:src/pages/contact@_@astro": "pages/contact.astro.mjs", "\0@astro-page:src/pages/faqs@_@astro": "pages/faqs.astro.mjs", "\0@astro-page:src/pages/feed/[slug]@_@ts": "pages/feed/_slug_.astro.mjs", "\0@astro-page:src/pages/images/[...key]@_@ts": "pages/images/_---key_.astro.mjs", "\0@astro-page:src/pages/recipes/index@_@astro": "pages/recipes.astro.mjs", "\0@astro-page:src/pages/rss/pinterest/[board].xml@_@ts": "pages/rss/pinterest/_board_.xml.astro.mjs", "\0@astro-page:src/pages/rss/pinterest.xml@_@ts": "pages/rss/pinterest.xml.astro.mjs", "\0@astro-page:src/pages/rss/recipes.xml@_@ts": "pages/rss/recipes.xml.astro.mjs", "\0@astro-page:src/pages/sitemap@_@ts": "pages/sitemap.astro.mjs", "\0@astro-page:src/pages/tags/[slug]@_@astro": "pages/tags/_slug_.astro.mjs", "\0@astrojs-ssr-virtual-entry": "index.js", "\0astro-internal:middleware": "_astro-internal_middleware.mjs", "\0@astro-page:src/pages/api/media/upload-urls@_@ts": "pages/api/media/upload-urls.astro.mjs", "\0@astro-page:src/pages/api/recipes/[slug]@_@ts": "pages/api/recipes/_slug_.astro.mjs", "\0@astro-page:src/pages/api/recipes@_@ts": "pages/api/recipes.astro2.mjs", "\0@astro-page:src/pages/authors/index@_@astro": "pages/authors.astro.mjs", "\0@astro-page:src/pages/categories/index@_@astro": "pages/categories.astro.mjs", "\0@astro-page:src/pages/tags/index@_@astro": "pages/tags.astro.mjs", "\0@astro-page:src/pages/index@_@astro": "pages/index.astro.mjs", "\0@astro-page:src/pages/recipes/[slug]@_@astro": "pages/recipes/_slug_.astro.mjs", "\0@astro-page:src/pages/categories/[slug]@_@astro": "pages/categories/_slug_.astro.mjs", "\0@astro-renderers": "renderers.mjs", "\0@astrojs-ssr-adapter": "_@astrojs-ssr-adapter.mjs", "\0@astro-page:node_modules/.pnpm/@astrojs+cloudflare@12.6.12_f9354d53bede48c7476e55e087cd9165/node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint@_@js": "pages/_image.astro.mjs", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/astro@5.16.6_@types+node@25_fe4d1830cdec2e66cb5e3dbb9af723fd/node_modules/astro/dist/assets/services/sharp.js": "chunks/sharp_DscWmDXI.mjs", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/unstorage@1.17.3_aws4fetch@1.0.20/node_modules/unstorage/drivers/cloudflare-kv-binding.mjs": "chunks/cloudflare-kv-binding_BA_YU2bU.mjs", "\0@astrojs-manifest": "manifest_r20Y9df8.mjs", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/modules/authors/index.ts": "chunks/index_CjdOo55e.mjs", "@astrojs/react/client.js": "_astro/client.COsshssH.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro?astro&type=script&index=0&lang.ts": "_astro/contact.astro_astro_type_script_index_0_lang.Bjx5NWo7.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro?astro&type=script&index=0&lang.ts": "_astro/index.astro_astro_type_script_index_0_lang.D0OnXcvl.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/NewsletterWidget.astro?astro&type=script&index=0&lang.ts": "_astro/NewsletterWidget.astro_astro_type_script_index_0_lang.BbKphN90.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/layouts/RecipeLayout.astro?astro&type=script&index=0&lang.ts": "_astro/RecipeLayout.astro_astro_type_script_index_0_lang.ATSKrZpR.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Header.astro?astro&type=script&index=0&lang.ts": "_astro/Header.astro_astro_type_script_index_0_lang.BQ4xfI8j.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/SocialShareBar.astro?astro&type=script&index=0&lang.ts": "_astro/SocialShareBar.astro_astro_type_script_index_0_lang.B13KplJo.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/homepage/Homepage.jsx": "_astro/Homepage.B34ylfMM.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/articles/ArticlesList.jsx": "_astro/ArticlesList.CQ7Tor_4.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/articles/ArticleEditor.jsx": "_astro/ArticleEditor.X9U8B5BE.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/recipes/RecipesList.jsx": "_astro/RecipesList.DtGqtHT_.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/articles/RecipeEditor.jsx": "_astro/RecipeEditor.DWhOefzL.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/roundups/RoundupsList.jsx": "_astro/RoundupsList.C-e--Q53.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/articles/RoundupEditor.jsx": "_astro/RoundupEditor.DvIqffNv.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/categories/CategoriesList.jsx": "_astro/CategoriesList.CFBva0t6.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/categories/CategoryEditor.jsx": "_astro/CategoryEditor.dkJIEsSY.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/authors/AuthorsList.jsx": "_astro/AuthorsList.CwoDBynI.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/authors/AuthorEditor.jsx": "_astro/AuthorEditor.B68wz5Xi.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/tags/TagsList.jsx": "_astro/TagsList.CYCCba8p.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/settings/Settings.jsx": "_astro/Settings.ClEBGcNO.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/auth/Login.jsx": "_astro/Login.CEbnnEww.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/pinterest/BoardsList.jsx": "_astro/BoardsList.dT2vVI5E.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/pages/pinterest/BoardEditor.jsx": "_astro/BoardEditor.uXcJlQsR.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/modules/templates/components/index.ts": "_astro/index.Dy-noWir.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/emoji-mart@5.6.0/node_modules/emoji-mart/dist/module.js": "_astro/module.CBGc_-fI.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@emoji-mart+data@1.2.1/node_modules/@emoji-mart/data/sets/15/native.json": "_astro/native.BfJN-Xtg.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+webp@1.5.0/node_modules/@jsquash/webp/index.js": "_astro/index.k7ASq2Y2.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+avif@2.1.1/node_modules/@jsquash/avif/index.js": "_astro/index.0si6LHiV.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+webp@1.5.0/node_modules/@jsquash/webp/codec/enc/webp_enc_simd.js": "_astro/webp_enc_simd._xAJBEvU.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+webp@1.5.0/node_modules/@jsquash/webp/codec/enc/webp_enc.js": "_astro/webp_enc.zg4Mv9SD.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+avif@2.1.1/node_modules/@jsquash/avif/codec/enc/avif_enc_mt.js": "_astro/avif_enc_mt.eeRLyb0K.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/node_modules/.pnpm/@jsquash+avif@2.1.1/node_modules/@jsquash/avif/codec/enc/avif_enc.js": "_astro/avif_enc.Duo8tsNU.js", "C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/admin/AdminApp": "_astro/AdminApp.Gtf9ljcg.js", "astro:scripts/before-hydration.js": "" }, "inlinedScripts": [["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/contact.astro?astro&type=script&index=0&lang.ts", `if(typeof MessageChannel>"u"){let e=function(){this.onmessage=null,this._target=null},t=function(){this.port1=new e,this.port2=new e,this.port1._target=this.port2,this.port2._target=this.port1};var a=e,i=t;e.prototype.postMessage=function(n){var s=this._target&&this._target.onmessage;typeof s=="function"&&s({data:n})},globalThis.MessageChannel=t}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("contactForm"),t=document.getElementById("formStatus");e?.addEventListener("submit",async n=>{n.preventDefault();const s=new FormData(e);Object.fromEntries(s.entries()),t.textContent="Sending message...",t.className="form-status",t.style.display="block",await new Promise(o=>setTimeout(o,1500)),t.textContent="\u2713 Message sent successfully! We'll get back to you soon.",t.className="form-status success",e.reset(),setTimeout(()=>{t.style.display="none"},5e3)})});`], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/pages/index.astro?astro&type=script&index=0&lang.ts", 'if(typeof MessageChannel>"u"){let e=function(){this.onmessage=null,this._target=null},n=function(){this.port1=new e,this.port2=new e,this.port1._target=this.port2,this.port2._target=this.port1};var h=e,f=n;e.prototype.postMessage=function(o){var t=this._target&&this._target.onmessage;typeof t=="function"&&t({data:o})},globalThis.MessageChannel=n}document.addEventListener("DOMContentLoaded",()=>{const e=document.getElementById("heroSlider");if(!e)return;const n=e.querySelectorAll(".slide"),o=e.querySelectorAll(".dot");let t=0,r;function l(s){n.forEach(i=>i.classList.remove("active")),o.forEach(i=>i.classList.remove("active")),t=s,n[t]?.classList.add("active"),o[t]?.classList.add("active")}function c(){const s=(t+1)%n.length;l(s)}function a(){r=setInterval(c,5e3)}function d(){clearInterval(r)}o.forEach(s=>{s.addEventListener("click",i=>{i.preventDefault();const u=parseInt(s.dataset.index||"0");l(u),d(),a()})}),e.addEventListener("mouseenter",d),e.addEventListener("mouseleave",a),a()});'], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/NewsletterWidget.astro?astro&type=script&index=0&lang.ts", 'if(typeof MessageChannel>"u"){let e=function(){this.onmessage=null,this._target=null},n=function(){this.port1=new e,this.port2=new e,this.port1._target=this.port2,this.port2._target=this.port1};var i=e,u=n;e.prototype.postMessage=function(r){var s=this._target&&this._target.onmessage;typeof s=="function"&&s({data:r})},globalThis.MessageChannel=n}document.querySelectorAll(".subscribe-form").forEach(e=>{e.addEventListener("submit",async n=>{n.preventDefault();const r=n.target,s=r.querySelector(".email-input"),t=r.querySelector(".subscribe-btn");if(!s.value)return;const o=t.textContent;t.textContent="Subscribing...",t.disabled=!0;try{await new Promise(a=>setTimeout(a,1e3)),t.textContent="Subscribed! \u2713",t.style.background="#10b981",s.value="",setTimeout(()=>{t.textContent=o,t.style.background="",t.disabled=!1},3e3)}catch{t.textContent="Error - Try again",t.style.background="#ef4444",setTimeout(()=>{t.textContent=o,t.style.background="",t.disabled=!1},2e3)}})});'], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/layouts/RecipeLayout.astro?astro&type=script&index=0&lang.ts", 'if(typeof MessageChannel>"u"){let t=function(){this.onmessage=null,this._target=null},e=function(){this.port1=new t,this.port2=new t,this.port1._target=this.port2,this.port2._target=this.port1};var s=t,i=e;t.prototype.postMessage=function(o){var n=this._target&&this._target.onmessage;typeof n=="function"&&n({data:o})},globalThis.MessageChannel=e}document.querySelectorAll(".ingredient-list li").forEach(t=>{t.addEventListener("click",()=>{const e=t.querySelector(".checkbox");e&&(e.style.background==="rgb(16, 185, 129)"?(e.style.background="",t.style.opacity="1",t.style.textDecoration="none"):(e.style.background="#10b981",t.style.opacity="0.6",t.style.textDecoration="line-through"))})});'], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/Header.astro?astro&type=script&index=0&lang.ts", 'if(typeof MessageChannel>"u"){let e=function(){this.onmessage=null,this._target=null},s=function(){this.port1=new e,this.port2=new e,this.port1._target=this.port2,this.port2._target=this.port1};var h=e,p=s;e.prototype.postMessage=function(l){var o=this._target&&this._target.onmessage;typeof o=="function"&&o({data:l})},globalThis.MessageChannel=s}const c=document.querySelector(".mobile-menu-btn"),i=document.querySelector("#mobile-nav"),r=e=>{const s=typeof e=="boolean"?e:!i?.classList.contains("active");i?.classList.toggle("active",s),c?.setAttribute("aria-expanded",String(s))};c?.addEventListener("click",()=>{r()});const n=document.querySelector(".search-btn"),t=document.querySelector("#search-modal"),d=document.querySelector(".close-search"),u=()=>{t?.classList.add("active"),t?.setAttribute("aria-hidden","false"),n?.setAttribute("aria-expanded","true"),document.querySelector(".search-input")?.focus()},a=()=>{t?.classList.remove("active"),t?.setAttribute("aria-hidden","true"),n?.setAttribute("aria-expanded","false")};n?.addEventListener("click",()=>{u()});d?.addEventListener("click",()=>{a()});t?.addEventListener("click",e=>{e.target===t&&a()});document.addEventListener("keydown",e=>{e.key==="Escape"&&(a(),r(!1))});'], ["C:/Users/Poste/Desktop/SaaS Astro/freecipies-blog/src/components/SocialShareBar.astro?astro&type=script&index=0&lang.ts", 'if(typeof MessageChannel>"u"){let t=function(){this.onmessage=null,this._target=null},e=function(){this.port1=new t,this.port2=new t,this.port1._target=this.port2,this.port2._target=this.port1};var a=t,s=e;t.prototype.postMessage=function(o){var r=this._target&&this._target.onmessage;typeof r=="function"&&r({data:o})},globalThis.MessageChannel=e}document.querySelectorAll(".copy-link").forEach(t=>{t.addEventListener("click",async()=>{const e=t.getAttribute("data-url");if(e)try{await navigator.clipboard.writeText(e),t.style.background="#10b981",t.style.color="white",setTimeout(()=>{t.style.background="",t.style.color=""},2e3)}catch(o){console.error("Failed to copy:",o)}})});']], "assets": ["/_astro/_slug_.Dv7FFRwW.css", "/_astro/_slug_.48QIQ_n-.css", "/_astro/_slug_.VpO_Cw2U.css", "/_astro/about.Dcxuk6NK.css", "/_astro/contact.CKDPVv9J.css", "/_astro/faqs.SjqYPRjk.css", "/_astro/index.B9h2MWSx.css", "/_astro/index.DhFFEtNm.css", "/favicon.svg", "/robots.txt", "/logos/android-chrome-192x192.png", "/logos/android-chrome-512x512.png", "/logos/apple-touch-icon.png", "/logos/favicon-16x16.png", "/logos/favicon-32x32.png", "/logos/favicon.svg", "/logos/logo-main.png", "/logos/logo-mobile.svg", "/logos/site.webmanifest", "/_worker.js/index.js", "/_worker.js/noop-entrypoint.mjs", "/_worker.js/renderers.mjs", "/_worker.js/_@astrojs-ssr-adapter.mjs", "/_worker.js/_astro-internal_middleware.mjs", "/_astro/AdminApp.AnSQ9CYF.js", "/_astro/AdminApp.D7Qti98B.css", "/_astro/AdminApp.Gtf9ljcg.js", "/_astro/arrow-left.Bqay3Ugd.js", "/_astro/ArticleEditor.X9U8B5BE.js", "/_astro/ArticlesList.CQ7Tor_4.js", "/_astro/AuthorEditor.B68wz5Xi.js", "/_astro/AuthorsList.CwoDBynI.js", "/_astro/avif_dec-B7YOdlSS.wasm", "/_astro/avif_dec.B7YOdlSS.wasm", "/_astro/avif_enc-BJWWnvkU.js", "/_astro/avif_enc-Co4TcJko.wasm", "/_astro/avif_enc.Co4TcJko.wasm", "/_astro/avif_enc.Duo8tsNU.js", "/_astro/avif_enc_mt-BL4_K_Gk.js", "/_astro/avif_enc_mt-D-E57tnV.js", "/_astro/avif_enc_mt-DFoVXd45.wasm", "/_astro/avif_enc_mt.DFoVXd45.wasm", "/_astro/avif_enc_mt.eeRLyb0K.js", "/_astro/avif_enc_mt.worker-EOU6xgn7.js", "/_astro/badge.C_6Ub5w0.js", "/_astro/BoardEditor.uXcJlQsR.js", "/_astro/BoardsList.dT2vVI5E.js", "/_astro/CategoriesList.CFBva0t6.js", "/_astro/CategoryEditor.dkJIEsSY.js", "/_astro/check.CFMn8cJ7.js", "/_astro/circle-check.CQLtEaDl.js", "/_astro/client.CDb96Dt8.js", "/_astro/client.COsshssH.js", "/_astro/ColorPicker.B8JX-2QC.js", "/_astro/confirmation-modal.CWox5otA.js", "/_astro/ContentListBase.JzGWy6Mh.js", "/_astro/editorConstants.DXS7yJ2E.js", "/_astro/ellipsis-vertical.BR-l1Y5E.js", "/_astro/encoder.worker-B-siqQel.js", "/_astro/external-link.CwQ55278.js", "/_astro/eye-off.haC7guZB.js", "/_astro/grid-3x3.C85mj7qK.js", "/_astro/hash.B-5r8Gaf.js", "/_astro/Homepage.B34ylfMM.js", "/_astro/hydration.Ddj1MmrX.js", "/_astro/image-upload.zc8VV4WC.js", "/_astro/index-C34gy56G.js", "/_astro/index-CWvpOmY5.js", "/_astro/index-CxUojzED.js", "/_astro/index.0si6LHiV.js", "/_astro/index.CktDif0o.js", "/_astro/index.CykAQbOv.js", "/_astro/index.CYKBWK8s.js", "/_astro/index.D2AUv59i.js", "/_astro/index.DeDslQpt.css", "/_astro/index.Dy-noWir.js", "/_astro/index.HdTbdW90.js", "/_astro/index.k7ASq2Y2.js", "/_astro/index.OKMfQzHL.js", "/_astro/index.X2ko3myk.js", "/_astro/index.XDu3YyTo.js", "/_astro/input.CysHfccG.js", "/_astro/label.CCVwTECs.js", "/_astro/layout-grid.CYInicZs.js", "/_astro/link-2.DWECMgdg.js", "/_astro/lock.D9osp8IX.js", "/_astro/Login.CEbnnEww.js", "/_astro/MediaDialog.C6ilFsQ1.js", "/_astro/MediaLibrary.Tj4beAzM.js", "/_astro/minus.DjjJSnC4.js", "/_astro/module.CBGc_-fI.js", "/_astro/native.BfJN-Xtg.js", "/_astro/palette.DtpP6Du1.js", "/_astro/panels-top-left.GsiIZ515.js", "/_astro/popover.PqJZbRuz.js", "/_astro/RecipeBuilder.BCuxcgRP.js", "/_astro/RecipeEditor.DWhOefzL.js", "/_astro/RecipesList.DtGqtHT_.js", "/_astro/refresh-cw.BSKShUL5.js", "/_astro/RoundupBuilder.CAZq4IOT.js", "/_astro/RoundupEditor.DvIqffNv.js", "/_astro/RoundupsList.C-e--Q53.js", "/_astro/save.Bdg-ducK.js", "/_astro/scroll-area.NjbCfy3k.js", "/_astro/select.CcIB2B0R.js", "/_astro/separator.DKCv7IE2.js", "/_astro/settings-2.BSrdLAh3.js", "/_astro/Settings.ClEBGcNO.js", "/_astro/square-pen.CUPB1oJ6.js", "/_astro/star.BNmledXb.js", "/_astro/switch.CWqnd1LK.js", "/_astro/tabs.ePXTHEh3.js", "/_astro/TagsList.CYCCba8p.js", "/_astro/textarea.DaxEJxRd.js", "/_astro/trash-2.C-qkNbfR.js", "/_astro/useImageUploadSettings.BCjC4dsv.js", "/_astro/webp_dec-C990n7mh.wasm", "/_astro/webp_dec.C990n7mh.wasm", "/_astro/webp_enc-BpZvKflB.wasm", "/_astro/webp_enc-D9z5FJM8.js", "/_astro/webp_enc.BpZvKflB.wasm", "/_astro/webp_enc.zg4Mv9SD.js", "/_astro/webp_enc_simd-CFvKQ_80.wasm", "/_astro/webp_enc_simd-CSUKUY1G.js", "/_astro/webp_enc_simd.CFvKQ_80.wasm", "/_astro/webp_enc_simd._xAJBEvU.js", "/_astro/youtube.RGbsiEC2.js", "/_worker.js/chunks/articles.service_DgNeye45.mjs", "/_worker.js/chunks/astro-designed-error-pages_B6wD2ieN.mjs", "/_worker.js/chunks/astro_BBeRhM1W.mjs", "/_worker.js/chunks/auth.service_GsDnjv--.mjs", "/_worker.js/chunks/authors.service_DDYOeshw.mjs", "/_worker.js/chunks/categories.service_BzGDlPlq.mjs", "/_worker.js/chunks/cloudflare-kv-binding_BA_YU2bU.mjs", "/_worker.js/chunks/drizzle_BakpoMbM.mjs", "/_worker.js/chunks/error-handler_D5quUcAZ.mjs", "/_worker.js/chunks/handlers_CrpakuiS.mjs", "/_worker.js/chunks/helpers_CpZsZXUI.mjs", "/_worker.js/chunks/helpers_Dlog4nju.mjs", "/_worker.js/chunks/helpers_NuS9JhFo.mjs", "/_worker.js/chunks/hydration_PCOoIFzn.mjs", "/_worker.js/chunks/image-endpoint_D6uoC0U6.mjs", "/_worker.js/chunks/index_CjdOo55e.mjs", "/_worker.js/chunks/index_DjxFTAWA.mjs", "/_worker.js/chunks/Layout_DDkk2Mp3.mjs", "/_worker.js/chunks/media.service_BzvilGys.mjs", "/_worker.js/chunks/NewsletterWidget_CY-qZb0v.mjs", "/_worker.js/chunks/noop-middleware_BOHnKSmu.mjs", "/_worker.js/chunks/path_BA-Tke6N.mjs", "/_worker.js/chunks/pinterest.schema_eG5oHE2g.mjs", "/_worker.js/chunks/r2.service_BByT9ix6.mjs", "/_worker.js/chunks/RecipeCard_3G-w8UC6.mjs", "/_worker.js/chunks/remote_DLFRGwa-.mjs", "/_worker.js/chunks/settings.service_C4TTblSS.mjs", "/_worker.js/chunks/sharp_DscWmDXI.mjs", "/_worker.js/chunks/tags.service_DE4uyghe.mjs", "/_worker.js/chunks/templates.schema_DMbF8Dv3.mjs", "/_worker.js/chunks/_@astrojs-ssr-adapter_DmRsPEtz.mjs", "/_worker.js/pages/about.astro.mjs", "/_worker.js/pages/authors.astro.mjs", "/_worker.js/pages/categories.astro.mjs", "/_worker.js/pages/contact.astro.mjs", "/_worker.js/pages/faqs.astro.mjs", "/_worker.js/pages/index.astro.mjs", "/_worker.js/pages/recipes.astro.mjs", "/_worker.js/pages/sitemap.astro.mjs", "/_worker.js/pages/tags.astro.mjs", "/_worker.js/pages/_image.astro.mjs", "/_worker.js/_astro/about.Dcxuk6NK.css", "/_worker.js/_astro/contact.CKDPVv9J.css", "/_worker.js/_astro/faqs.SjqYPRjk.css", "/_worker.js/_astro/index.B9h2MWSx.css", "/_worker.js/_astro/index.DhFFEtNm.css", "/_worker.js/_astro/_slug_.48QIQ_n-.css", "/_worker.js/_astro/_slug_.Dv7FFRwW.css", "/_worker.js/_astro/_slug_.VpO_Cw2U.css", "/_worker.js/chunks/astro/server_B79ahsw9.mjs", "/_worker.js/pages/admin/_---path_.astro.mjs", "/_worker.js/pages/categories/_slug_.astro.mjs", "/_worker.js/pages/api/articles.astro.mjs", "/_worker.js/pages/api/authors.astro.mjs", "/_worker.js/pages/api/authors.astro2.mjs", "/_worker.js/pages/api/categories.astro.mjs", "/_worker.js/pages/api/content.astro.mjs", "/_worker.js/pages/api/media.astro.mjs", "/_worker.js/pages/api/pins.astro.mjs", "/_worker.js/pages/api/pinterest-boards.astro.mjs", "/_worker.js/pages/api/proxy-image.astro.mjs", "/_worker.js/pages/api/recipes.astro.mjs", "/_worker.js/pages/api/recipes.astro2.mjs", "/_worker.js/pages/api/roundups.astro.mjs", "/_worker.js/pages/api/seed-images.astro.mjs", "/_worker.js/pages/api/tags.astro.mjs", "/_worker.js/pages/api/templates.astro.mjs", "/_worker.js/pages/api/upload-font.astro.mjs", "/_worker.js/pages/api/upload-from-url.astro.mjs", "/_worker.js/pages/api/upload-image.astro.mjs", "/_worker.js/pages/api/upload-thumbnail.astro.mjs", "/_worker.js/pages/feed/_slug_.astro.mjs", "/_worker.js/pages/images/_---key_.astro.mjs", "/_worker.js/pages/recipes/_slug_.astro.mjs", "/_worker.js/pages/authors/_slug_.astro.mjs", "/_worker.js/pages/rss/pinterest.xml.astro.mjs", "/_worker.js/pages/rss/recipes.xml.astro.mjs", "/_worker.js/pages/tags/_slug_.astro.mjs", "/_worker.js/pages/api/articles/_slug_.astro.mjs", "/_worker.js/pages/api/auth/login.astro.mjs", "/_worker.js/pages/api/auth/refresh.astro.mjs", "/_worker.js/pages/api/auth/verify.astro.mjs", "/_worker.js/pages/api/authors/_slug_.astro.mjs", "/_worker.js/pages/api/branding/_---slug_.astro.mjs", "/_worker.js/pages/api/categories/_slug_.astro.mjs", "/_worker.js/pages/api/images/_---path_.astro.mjs", "/_worker.js/pages/api/media/bulk-delete.astro.mjs", "/_worker.js/pages/api/media/confirm.astro.mjs", "/_worker.js/pages/api/media/upload-urls.astro.mjs", "/_worker.js/pages/api/media/upload-variant.astro.mjs", "/_worker.js/pages/api/media/_id_.astro.mjs", "/_worker.js/pages/api/recipes/_slug_.astro.mjs", "/_worker.js/pages/api/roundups/_slug_.astro.mjs", "/_worker.js/pages/api/settings/image-upload.astro.mjs", "/_worker.js/pages/api/stats/dashboard.astro.mjs", "/_worker.js/pages/api/stats/popular.astro.mjs", "/_worker.js/pages/api/tags/_slug_.astro.mjs", "/_worker.js/pages/api/views/_slug_.astro.mjs", "/_worker.js/pages/api/templates/_slug_.astro.mjs", "/_worker.js/pages/rss/pinterest/_board_.xml.astro.mjs", "/_worker.js/pages/api/admin/articles/_id_.astro.mjs"], "buildFormat": "directory", "checkOrigin": true, "allowedDomains": [], "serverIslandNameMap": [], "key": "yiwhiAw1fOUsoBZPSMurgCOxfl94/dVuwwCUybx3KMg=", "sessionConfig": { "driver": "cloudflare-kv-binding", "options": { "binding": "SESSION" } } });
if (manifest.sessionConfig) manifest.sessionConfig.driverModule = () => Promise.resolve().then(() => (init_cloudflare_kv_binding_BA_YU2bU(), cloudflare_kv_binding_BA_YU2bU_exports));

// .wrangler/tmp/pages-AQW1MV/bundledWorker-0.2699154439704958.mjs
var __defProp4 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target, value) => __defProp4(target, "name", { value, configurable: true }), "__name");
// @__NO_SIDE_EFFECTS__
function createNotImplementedError2(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
__name(createNotImplementedError2, "createNotImplementedError");
__name2(createNotImplementedError2, "createNotImplementedError");
// @__NO_SIDE_EFFECTS__
function notImplemented2(name) {
  const fn = /* @__PURE__ */ __name2(() => {
    throw /* @__PURE__ */ createNotImplementedError2(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
__name(notImplemented2, "notImplemented");
__name2(notImplemented2, "notImplemented");
// @__NO_SIDE_EFFECTS__
function notImplementedClass2(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
__name(notImplementedClass2, "notImplementedClass");
__name2(notImplementedClass2, "notImplementedClass");
var _timeOrigin2 = globalThis.performance?.timeOrigin ?? Date.now();
var _performanceNow2 = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin2;
var nodeTiming2 = {
  name: "node",
  entryType: "node",
  startTime: 0,
  duration: 0,
  nodeStart: 0,
  v8Start: 0,
  bootstrapComplete: 0,
  environment: 0,
  loopStart: 0,
  loopExit: 0,
  idleTime: 0,
  uvMetricsInfo: {
    loopCount: 0,
    events: 0,
    eventsWaiting: 0
  },
  detail: void 0,
  toJSON() {
    return this;
  }
};
var PerformanceEntry2 = class {
  static {
    __name(this, "PerformanceEntry");
  }
  static {
    __name2(this, "PerformanceEntry");
  }
  __unenv__ = true;
  detail;
  entryType = "event";
  name;
  startTime;
  constructor(name, options) {
    this.name = name;
    this.startTime = options?.startTime || _performanceNow2();
    this.detail = options?.detail;
  }
  get duration() {
    return _performanceNow2() - this.startTime;
  }
  toJSON() {
    return {
      name: this.name,
      entryType: this.entryType,
      startTime: this.startTime,
      duration: this.duration,
      detail: this.detail
    };
  }
};
var PerformanceMark3 = class PerformanceMark22 extends PerformanceEntry2 {
  static {
    __name(this, "PerformanceMark2");
  }
  static {
    __name2(this, "PerformanceMark");
  }
  entryType = "mark";
  constructor() {
    super(...arguments);
  }
  get duration() {
    return 0;
  }
};
var PerformanceMeasure2 = class extends PerformanceEntry2 {
  static {
    __name(this, "PerformanceMeasure");
  }
  static {
    __name2(this, "PerformanceMeasure");
  }
  entryType = "measure";
};
var PerformanceResourceTiming2 = class extends PerformanceEntry2 {
  static {
    __name(this, "PerformanceResourceTiming");
  }
  static {
    __name2(this, "PerformanceResourceTiming");
  }
  entryType = "resource";
  serverTiming = [];
  connectEnd = 0;
  connectStart = 0;
  decodedBodySize = 0;
  domainLookupEnd = 0;
  domainLookupStart = 0;
  encodedBodySize = 0;
  fetchStart = 0;
  initiatorType = "";
  name = "";
  nextHopProtocol = "";
  redirectEnd = 0;
  redirectStart = 0;
  requestStart = 0;
  responseEnd = 0;
  responseStart = 0;
  secureConnectionStart = 0;
  startTime = 0;
  transferSize = 0;
  workerStart = 0;
  responseStatus = 0;
};
var PerformanceObserverEntryList2 = class {
  static {
    __name(this, "PerformanceObserverEntryList");
  }
  static {
    __name2(this, "PerformanceObserverEntryList");
  }
  __unenv__ = true;
  getEntries() {
    return [];
  }
  getEntriesByName(_name, _type) {
    return [];
  }
  getEntriesByType(type) {
    return [];
  }
};
var Performance2 = class {
  static {
    __name(this, "Performance");
  }
  static {
    __name2(this, "Performance");
  }
  __unenv__ = true;
  timeOrigin = _timeOrigin2;
  eventCounts = /* @__PURE__ */ new Map();
  _entries = [];
  _resourceTimingBufferSize = 0;
  navigation = void 0;
  timing = void 0;
  timerify(_fn, _options) {
    throw /* @__PURE__ */ createNotImplementedError2("Performance.timerify");
  }
  get nodeTiming() {
    return nodeTiming2;
  }
  eventLoopUtilization() {
    return {};
  }
  markResourceTiming() {
    return new PerformanceResourceTiming2("");
  }
  onresourcetimingbufferfull = null;
  now() {
    if (this.timeOrigin === _timeOrigin2) {
      return _performanceNow2();
    }
    return Date.now() - this.timeOrigin;
  }
  clearMarks(markName) {
    this._entries = markName ? this._entries.filter((e2) => e2.name !== markName) : this._entries.filter((e2) => e2.entryType !== "mark");
  }
  clearMeasures(measureName) {
    this._entries = measureName ? this._entries.filter((e2) => e2.name !== measureName) : this._entries.filter((e2) => e2.entryType !== "measure");
  }
  clearResourceTimings() {
    this._entries = this._entries.filter((e2) => e2.entryType !== "resource" || e2.entryType !== "navigation");
  }
  getEntries() {
    return this._entries;
  }
  getEntriesByName(name, type) {
    return this._entries.filter((e2) => e2.name === name && (!type || e2.entryType === type));
  }
  getEntriesByType(type) {
    return this._entries.filter((e2) => e2.entryType === type);
  }
  mark(name, options) {
    const entry = new PerformanceMark3(name, options);
    this._entries.push(entry);
    return entry;
  }
  measure(measureName, startOrMeasureOptions, endMark) {
    let start;
    let end;
    if (typeof startOrMeasureOptions === "string") {
      start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
      end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
    } else {
      start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
      end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
    }
    const entry = new PerformanceMeasure2(measureName, {
      startTime: start,
      detail: {
        start,
        end
      }
    });
    this._entries.push(entry);
    return entry;
  }
  setResourceTimingBufferSize(maxSize) {
    this._resourceTimingBufferSize = maxSize;
  }
  addEventListener(type, listener, options) {
    throw /* @__PURE__ */ createNotImplementedError2("Performance.addEventListener");
  }
  removeEventListener(type, listener, options) {
    throw /* @__PURE__ */ createNotImplementedError2("Performance.removeEventListener");
  }
  dispatchEvent(event) {
    throw /* @__PURE__ */ createNotImplementedError2("Performance.dispatchEvent");
  }
  toJSON() {
    return this;
  }
};
var PerformanceObserver2 = class {
  static {
    __name(this, "PerformanceObserver");
  }
  static {
    __name2(this, "PerformanceObserver");
  }
  __unenv__ = true;
  static supportedEntryTypes = [];
  _callback = null;
  constructor(callback) {
    this._callback = callback;
  }
  takeRecords() {
    return [];
  }
  disconnect() {
    throw /* @__PURE__ */ createNotImplementedError2("PerformanceObserver.disconnect");
  }
  observe(options) {
    throw /* @__PURE__ */ createNotImplementedError2("PerformanceObserver.observe");
  }
  bind(fn) {
    return fn;
  }
  runInAsyncScope(fn, thisArg, ...args) {
    return fn.call(thisArg, ...args);
  }
  asyncId() {
    return 0;
  }
  triggerAsyncId() {
    return 0;
  }
  emitDestroy() {
    return this;
  }
};
var performance3 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance2();
globalThis.performance = performance3;
globalThis.Performance = Performance2;
globalThis.PerformanceEntry = PerformanceEntry2;
globalThis.PerformanceMark = PerformanceMark3;
globalThis.PerformanceMeasure = PerformanceMeasure2;
globalThis.PerformanceObserver = PerformanceObserver2;
globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList2;
globalThis.PerformanceResourceTiming = PerformanceResourceTiming2;
var noop_default2 = Object.assign(() => {
}, { __unenv__: true });
var _console2 = globalThis.console;
var _ignoreErrors2 = true;
var _stderr2 = new Writable2();
var _stdout2 = new Writable2();
var log4 = _console2?.log ?? noop_default2;
var info4 = _console2?.info ?? log4;
var trace3 = _console2?.trace ?? info4;
var debug4 = _console2?.debug ?? log4;
var table3 = _console2?.table ?? log4;
var error4 = _console2?.error ?? log4;
var warn4 = _console2?.warn ?? error4;
var createTask3 = _console2?.createTask ?? /* @__PURE__ */ notImplemented2("console.createTask");
var clear3 = _console2?.clear ?? noop_default2;
var count3 = _console2?.count ?? noop_default2;
var countReset3 = _console2?.countReset ?? noop_default2;
var dir3 = _console2?.dir ?? noop_default2;
var dirxml3 = _console2?.dirxml ?? noop_default2;
var group3 = _console2?.group ?? noop_default2;
var groupEnd3 = _console2?.groupEnd ?? noop_default2;
var groupCollapsed3 = _console2?.groupCollapsed ?? noop_default2;
var profile3 = _console2?.profile ?? noop_default2;
var profileEnd3 = _console2?.profileEnd ?? noop_default2;
var time3 = _console2?.time ?? noop_default2;
var timeEnd3 = _console2?.timeEnd ?? noop_default2;
var timeLog3 = _console2?.timeLog ?? noop_default2;
var timeStamp3 = _console2?.timeStamp ?? noop_default2;
var Console2 = _console2?.Console ?? /* @__PURE__ */ notImplementedClass2("console.Console");
var _times2 = /* @__PURE__ */ new Map();
var _stdoutErrorHandler2 = noop_default2;
var _stderrErrorHandler2 = noop_default2;
var workerdConsole2 = globalThis["console"];
var {
  assert: assert3,
  clear: clear22,
  // @ts-expect-error undocumented public API
  context: context2,
  count: count22,
  countReset: countReset22,
  // @ts-expect-error undocumented public API
  createTask: createTask22,
  debug: debug22,
  dir: dir22,
  dirxml: dirxml22,
  error: error22,
  group: group22,
  groupCollapsed: groupCollapsed22,
  groupEnd: groupEnd22,
  info: info22,
  log: log22,
  profile: profile22,
  profileEnd: profileEnd22,
  table: table22,
  time: time22,
  timeEnd: timeEnd22,
  timeLog: timeLog22,
  timeStamp: timeStamp22,
  trace: trace22,
  warn: warn22
} = workerdConsole2;
Object.assign(workerdConsole2, {
  Console: Console2,
  _ignoreErrors: _ignoreErrors2,
  _stderr: _stderr2,
  _stderrErrorHandler: _stderrErrorHandler2,
  _stdout: _stdout2,
  _stdoutErrorHandler: _stdoutErrorHandler2,
  _times: _times2
});
var console_default2 = workerdConsole2;
globalThis.console = console_default2;
var hrtime4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name2(/* @__PURE__ */ __name(function hrtime22(startTime) {
  const now = Date.now();
  const seconds = Math.trunc(now / 1e3);
  const nanos = now % 1e3 * 1e6;
  if (startTime) {
    let diffSeconds = seconds - startTime[0];
    let diffNanos = nanos - startTime[0];
    if (diffNanos < 0) {
      diffSeconds = diffSeconds - 1;
      diffNanos = 1e9 + diffNanos;
    }
    return [diffSeconds, diffNanos];
  }
  return [seconds, nanos];
}, "hrtime2"), "hrtime"), { bigint: /* @__PURE__ */ __name2(/* @__PURE__ */ __name(function bigint2() {
  return BigInt(Date.now() * 1e6);
}, "bigint"), "bigint") });
var ReadStream2 = class {
  static {
    __name(this, "ReadStream");
  }
  static {
    __name2(this, "ReadStream");
  }
  fd;
  isRaw = false;
  isTTY = false;
  constructor(fd) {
    this.fd = fd;
  }
  setRawMode(mode) {
    this.isRaw = mode;
    return this;
  }
};
var WriteStream2 = class {
  static {
    __name(this, "WriteStream");
  }
  static {
    __name2(this, "WriteStream");
  }
  fd;
  columns = 80;
  rows = 24;
  isTTY = false;
  constructor(fd) {
    this.fd = fd;
  }
  clearLine(dir32, callback) {
    callback && callback();
    return false;
  }
  clearScreenDown(callback) {
    callback && callback();
    return false;
  }
  cursorTo(x, y, callback) {
    callback && typeof callback === "function" && callback();
    return false;
  }
  moveCursor(dx, dy, callback) {
    callback && callback();
    return false;
  }
  getColorDepth(env22) {
    return 1;
  }
  hasColors(count32, env22) {
    return false;
  }
  getWindowSize() {
    return [this.columns, this.rows];
  }
  write(str, encoding, cb) {
    if (str instanceof Uint8Array) {
      str = new TextDecoder().decode(str);
    }
    try {
      console.log(str);
    } catch {
    }
    cb && typeof cb === "function" && cb();
    return false;
  }
};
var NODE_VERSION2 = "22.14.0";
var Process2 = class _Process extends EventEmitter3 {
  static {
    __name(this, "_Process");
  }
  static {
    __name2(this, "Process");
  }
  env;
  hrtime;
  nextTick;
  constructor(impl) {
    super();
    this.env = impl.env;
    this.hrtime = impl.hrtime;
    this.nextTick = impl.nextTick;
    for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter3.prototype)]) {
      const value = this[prop];
      if (typeof value === "function") {
        this[prop] = value.bind(this);
      }
    }
  }
  // --- event emitter ---
  emitWarning(warning, type, code) {
    console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
  }
  emit(...args) {
    return super.emit(...args);
  }
  listeners(eventName) {
    return super.listeners(eventName);
  }
  // --- stdio (lazy initializers) ---
  #stdin;
  #stdout;
  #stderr;
  get stdin() {
    return this.#stdin ??= new ReadStream2(0);
  }
  get stdout() {
    return this.#stdout ??= new WriteStream2(1);
  }
  get stderr() {
    return this.#stderr ??= new WriteStream2(2);
  }
  // --- cwd ---
  #cwd = "/";
  chdir(cwd22) {
    this.#cwd = cwd22;
  }
  cwd() {
    return this.#cwd;
  }
  // --- dummy props and getters ---
  arch = "";
  platform = "";
  argv = [];
  argv0 = "";
  execArgv = [];
  execPath = "";
  title = "";
  pid = 200;
  ppid = 100;
  get version() {
    return `v${NODE_VERSION2}`;
  }
  get versions() {
    return { node: NODE_VERSION2 };
  }
  get allowedNodeEnvironmentFlags() {
    return /* @__PURE__ */ new Set();
  }
  get sourceMapsEnabled() {
    return false;
  }
  get debugPort() {
    return 0;
  }
  get throwDeprecation() {
    return false;
  }
  get traceDeprecation() {
    return false;
  }
  get features() {
    return {};
  }
  get release() {
    return {};
  }
  get connected() {
    return false;
  }
  get config() {
    return {};
  }
  get moduleLoadList() {
    return [];
  }
  constrainedMemory() {
    return 0;
  }
  availableMemory() {
    return 0;
  }
  uptime() {
    return 0;
  }
  resourceUsage() {
    return {};
  }
  // --- noop methods ---
  ref() {
  }
  unref() {
  }
  // --- unimplemented methods ---
  umask() {
    throw /* @__PURE__ */ createNotImplementedError2("process.umask");
  }
  getBuiltinModule() {
    return void 0;
  }
  getActiveResourcesInfo() {
    throw /* @__PURE__ */ createNotImplementedError2("process.getActiveResourcesInfo");
  }
  exit() {
    throw /* @__PURE__ */ createNotImplementedError2("process.exit");
  }
  reallyExit() {
    throw /* @__PURE__ */ createNotImplementedError2("process.reallyExit");
  }
  kill() {
    throw /* @__PURE__ */ createNotImplementedError2("process.kill");
  }
  abort() {
    throw /* @__PURE__ */ createNotImplementedError2("process.abort");
  }
  dlopen() {
    throw /* @__PURE__ */ createNotImplementedError2("process.dlopen");
  }
  setSourceMapsEnabled() {
    throw /* @__PURE__ */ createNotImplementedError2("process.setSourceMapsEnabled");
  }
  loadEnvFile() {
    throw /* @__PURE__ */ createNotImplementedError2("process.loadEnvFile");
  }
  disconnect() {
    throw /* @__PURE__ */ createNotImplementedError2("process.disconnect");
  }
  cpuUsage() {
    throw /* @__PURE__ */ createNotImplementedError2("process.cpuUsage");
  }
  setUncaughtExceptionCaptureCallback() {
    throw /* @__PURE__ */ createNotImplementedError2("process.setUncaughtExceptionCaptureCallback");
  }
  hasUncaughtExceptionCaptureCallback() {
    throw /* @__PURE__ */ createNotImplementedError2("process.hasUncaughtExceptionCaptureCallback");
  }
  initgroups() {
    throw /* @__PURE__ */ createNotImplementedError2("process.initgroups");
  }
  openStdin() {
    throw /* @__PURE__ */ createNotImplementedError2("process.openStdin");
  }
  assert() {
    throw /* @__PURE__ */ createNotImplementedError2("process.assert");
  }
  binding() {
    throw /* @__PURE__ */ createNotImplementedError2("process.binding");
  }
  // --- attached interfaces ---
  permission = { has: /* @__PURE__ */ notImplemented2("process.permission.has") };
  report = {
    directory: "",
    filename: "",
    signal: "SIGUSR2",
    compact: false,
    reportOnFatalError: false,
    reportOnSignal: false,
    reportOnUncaughtException: false,
    getReport: /* @__PURE__ */ notImplemented2("process.report.getReport"),
    writeReport: /* @__PURE__ */ notImplemented2("process.report.writeReport")
  };
  finalization = {
    register: /* @__PURE__ */ notImplemented2("process.finalization.register"),
    unregister: /* @__PURE__ */ notImplemented2("process.finalization.unregister"),
    registerBeforeExit: /* @__PURE__ */ notImplemented2("process.finalization.registerBeforeExit")
  };
  memoryUsage = Object.assign(() => ({
    arrayBuffers: 0,
    rss: 0,
    external: 0,
    heapTotal: 0,
    heapUsed: 0
  }), { rss: /* @__PURE__ */ __name2(() => 0, "rss") });
  // --- undefined props ---
  mainModule = void 0;
  domain = void 0;
  // optional
  send = void 0;
  exitCode = void 0;
  channel = void 0;
  getegid = void 0;
  geteuid = void 0;
  getgid = void 0;
  getgroups = void 0;
  getuid = void 0;
  setegid = void 0;
  seteuid = void 0;
  setgid = void 0;
  setgroups = void 0;
  setuid = void 0;
  // internals
  _events = void 0;
  _eventsCount = void 0;
  _exiting = void 0;
  _maxListeners = void 0;
  _debugEnd = void 0;
  _debugProcess = void 0;
  _fatalException = void 0;
  _getActiveHandles = void 0;
  _getActiveRequests = void 0;
  _kill = void 0;
  _preload_modules = void 0;
  _rawDebug = void 0;
  _startProfilerIdleNotifier = void 0;
  _stopProfilerIdleNotifier = void 0;
  _tickCallback = void 0;
  _disconnect = void 0;
  _handleQueue = void 0;
  _pendingMessage = void 0;
  _channel = void 0;
  _send = void 0;
  _linkedBinding = void 0;
};
var globalProcess2 = globalThis["process"];
var getBuiltinModule2 = globalProcess2.getBuiltinModule;
var workerdProcess2 = getBuiltinModule2("node:process");
var isWorkerdProcessV22 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
var unenvProcess2 = new Process2({
  env: globalProcess2.env,
  // `hrtime` is only available from workerd process v2
  hrtime: isWorkerdProcessV22 ? workerdProcess2.hrtime : hrtime4,
  // `nextTick` is available from workerd process v1
  nextTick: workerdProcess2.nextTick
});
var { exit: exit2, features: features2, platform: platform2 } = workerdProcess2;
var {
  // Always implemented by workerd
  env: env2,
  // Only implemented in workerd v2
  hrtime: hrtime32,
  // Always implemented by workerd
  nextTick: nextTick2
} = unenvProcess2;
var {
  _channel: _channel2,
  _disconnect: _disconnect2,
  _events: _events2,
  _eventsCount: _eventsCount2,
  _handleQueue: _handleQueue2,
  _maxListeners: _maxListeners2,
  _pendingMessage: _pendingMessage2,
  _send: _send2,
  assert: assert22,
  disconnect: disconnect2,
  mainModule: mainModule2
} = unenvProcess2;
var {
  // @ts-expect-error `_debugEnd` is missing typings
  _debugEnd: _debugEnd2,
  // @ts-expect-error `_debugProcess` is missing typings
  _debugProcess: _debugProcess2,
  // @ts-expect-error `_exiting` is missing typings
  _exiting: _exiting2,
  // @ts-expect-error `_fatalException` is missing typings
  _fatalException: _fatalException2,
  // @ts-expect-error `_getActiveHandles` is missing typings
  _getActiveHandles: _getActiveHandles2,
  // @ts-expect-error `_getActiveRequests` is missing typings
  _getActiveRequests: _getActiveRequests2,
  // @ts-expect-error `_kill` is missing typings
  _kill: _kill2,
  // @ts-expect-error `_linkedBinding` is missing typings
  _linkedBinding: _linkedBinding2,
  // @ts-expect-error `_preload_modules` is missing typings
  _preload_modules: _preload_modules2,
  // @ts-expect-error `_rawDebug` is missing typings
  _rawDebug: _rawDebug2,
  // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
  _startProfilerIdleNotifier: _startProfilerIdleNotifier2,
  // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
  _stopProfilerIdleNotifier: _stopProfilerIdleNotifier2,
  // @ts-expect-error `_tickCallback` is missing typings
  _tickCallback: _tickCallback2,
  abort: abort2,
  addListener: addListener2,
  allowedNodeEnvironmentFlags: allowedNodeEnvironmentFlags2,
  arch: arch2,
  argv: argv2,
  argv0: argv02,
  availableMemory: availableMemory2,
  // @ts-expect-error `binding` is missing typings
  binding: binding2,
  channel: channel2,
  chdir: chdir2,
  config: config2,
  connected: connected2,
  constrainedMemory: constrainedMemory2,
  cpuUsage: cpuUsage2,
  cwd: cwd2,
  debugPort: debugPort2,
  dlopen: dlopen2,
  // @ts-expect-error `domain` is missing typings
  domain: domain2,
  emit: emit2,
  emitWarning: emitWarning2,
  eventNames: eventNames2,
  execArgv: execArgv2,
  execPath: execPath2,
  exitCode: exitCode2,
  finalization: finalization2,
  getActiveResourcesInfo: getActiveResourcesInfo2,
  getegid: getegid2,
  geteuid: geteuid2,
  getgid: getgid2,
  getgroups: getgroups2,
  getMaxListeners: getMaxListeners2,
  getuid: getuid2,
  hasUncaughtExceptionCaptureCallback: hasUncaughtExceptionCaptureCallback2,
  // @ts-expect-error `initgroups` is missing typings
  initgroups: initgroups2,
  kill: kill2,
  listenerCount: listenerCount2,
  listeners: listeners2,
  loadEnvFile: loadEnvFile2,
  memoryUsage: memoryUsage2,
  // @ts-expect-error `moduleLoadList` is missing typings
  moduleLoadList: moduleLoadList2,
  off: off2,
  on: on2,
  once: once2,
  // @ts-expect-error `openStdin` is missing typings
  openStdin: openStdin2,
  permission: permission2,
  pid: pid2,
  ppid: ppid2,
  prependListener: prependListener2,
  prependOnceListener: prependOnceListener2,
  rawListeners: rawListeners2,
  // @ts-expect-error `reallyExit` is missing typings
  reallyExit: reallyExit2,
  ref: ref2,
  release: release2,
  removeAllListeners: removeAllListeners2,
  removeListener: removeListener2,
  report: report2,
  resourceUsage: resourceUsage2,
  send: send2,
  setegid: setegid2,
  seteuid: seteuid2,
  setgid: setgid2,
  setgroups: setgroups2,
  setMaxListeners: setMaxListeners2,
  setSourceMapsEnabled: setSourceMapsEnabled2,
  setuid: setuid2,
  setUncaughtExceptionCaptureCallback: setUncaughtExceptionCaptureCallback2,
  sourceMapsEnabled: sourceMapsEnabled2,
  stderr: stderr2,
  stdin: stdin2,
  stdout: stdout2,
  throwDeprecation: throwDeprecation2,
  title: title2,
  traceDeprecation: traceDeprecation2,
  umask: umask2,
  unref: unref2,
  uptime: uptime2,
  version: version2,
  versions: versions2
} = isWorkerdProcessV22 ? workerdProcess2 : unenvProcess2;
var _process2 = {
  abort: abort2,
  addListener: addListener2,
  allowedNodeEnvironmentFlags: allowedNodeEnvironmentFlags2,
  hasUncaughtExceptionCaptureCallback: hasUncaughtExceptionCaptureCallback2,
  setUncaughtExceptionCaptureCallback: setUncaughtExceptionCaptureCallback2,
  loadEnvFile: loadEnvFile2,
  sourceMapsEnabled: sourceMapsEnabled2,
  arch: arch2,
  argv: argv2,
  argv0: argv02,
  chdir: chdir2,
  config: config2,
  connected: connected2,
  constrainedMemory: constrainedMemory2,
  availableMemory: availableMemory2,
  cpuUsage: cpuUsage2,
  cwd: cwd2,
  debugPort: debugPort2,
  dlopen: dlopen2,
  disconnect: disconnect2,
  emit: emit2,
  emitWarning: emitWarning2,
  env: env2,
  eventNames: eventNames2,
  execArgv: execArgv2,
  execPath: execPath2,
  exit: exit2,
  finalization: finalization2,
  features: features2,
  getBuiltinModule: getBuiltinModule2,
  getActiveResourcesInfo: getActiveResourcesInfo2,
  getMaxListeners: getMaxListeners2,
  hrtime: hrtime32,
  kill: kill2,
  listeners: listeners2,
  listenerCount: listenerCount2,
  memoryUsage: memoryUsage2,
  nextTick: nextTick2,
  on: on2,
  off: off2,
  once: once2,
  pid: pid2,
  platform: platform2,
  ppid: ppid2,
  prependListener: prependListener2,
  prependOnceListener: prependOnceListener2,
  rawListeners: rawListeners2,
  release: release2,
  removeAllListeners: removeAllListeners2,
  removeListener: removeListener2,
  report: report2,
  resourceUsage: resourceUsage2,
  setMaxListeners: setMaxListeners2,
  setSourceMapsEnabled: setSourceMapsEnabled2,
  stderr: stderr2,
  stdin: stdin2,
  stdout: stdout2,
  title: title2,
  throwDeprecation: throwDeprecation2,
  traceDeprecation: traceDeprecation2,
  umask: umask2,
  uptime: uptime2,
  version: version2,
  versions: versions2,
  // @ts-expect-error old API
  domain: domain2,
  initgroups: initgroups2,
  moduleLoadList: moduleLoadList2,
  reallyExit: reallyExit2,
  openStdin: openStdin2,
  assert: assert22,
  binding: binding2,
  send: send2,
  exitCode: exitCode2,
  channel: channel2,
  getegid: getegid2,
  geteuid: geteuid2,
  getgid: getgid2,
  getgroups: getgroups2,
  getuid: getuid2,
  setegid: setegid2,
  seteuid: seteuid2,
  setgid: setgid2,
  setgroups: setgroups2,
  setuid: setuid2,
  permission: permission2,
  mainModule: mainModule2,
  _events: _events2,
  _eventsCount: _eventsCount2,
  _exiting: _exiting2,
  _maxListeners: _maxListeners2,
  _debugEnd: _debugEnd2,
  _debugProcess: _debugProcess2,
  _fatalException: _fatalException2,
  _getActiveHandles: _getActiveHandles2,
  _getActiveRequests: _getActiveRequests2,
  _kill: _kill2,
  _preload_modules: _preload_modules2,
  _rawDebug: _rawDebug2,
  _startProfilerIdleNotifier: _startProfilerIdleNotifier2,
  _stopProfilerIdleNotifier: _stopProfilerIdleNotifier2,
  _tickCallback: _tickCallback2,
  _disconnect: _disconnect2,
  _handleQueue: _handleQueue2,
  _pendingMessage: _pendingMessage2,
  _channel: _channel2,
  _send: _send2,
  _linkedBinding: _linkedBinding2
};
var process_default2 = _process2;
globalThis.process = process_default2;
if (typeof MessageChannel === "undefined") {
  let MessagePort3 = /* @__PURE__ */ __name(function() {
    this.onmessage = null;
    this._target = null;
  }, "MessagePort"), MessageChannelPolyfill = /* @__PURE__ */ __name(function() {
    this.port1 = new MessagePort3();
    this.port2 = new MessagePort3();
    this.port1._target = this.port2;
    this.port2._target = this.port1;
  }, "MessageChannelPolyfill");
  MessagePort2 = MessagePort3, MessageChannelPolyfill2 = MessageChannelPolyfill;
  __name2(MessagePort3, "MessagePort");
  __name2(MessageChannelPolyfill, "MessageChannelPolyfill");
  MessagePort3.prototype.postMessage = function(data) {
    var handler = this._target && this._target.onmessage;
    if (typeof handler === "function") {
      handler({ data });
    }
  };
  globalThis.MessageChannel = MessageChannelPolyfill;
}
var MessagePort2;
var MessageChannelPolyfill2;
var serverIslandMap = /* @__PURE__ */ new Map();
var _page0 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_image_astro(), image_astro_exports)), "_page0");
var _page1 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_about_astro(), about_astro_exports)), "_page1");
var _page210 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_path_astro(), path_astro_exports)), "_page2");
var _page310 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_id_astro(), id_astro_exports)), "_page3");
var _page410 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro(), slug_astro_exports)), "_page4");
var _page510 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_articles_astro(), articles_astro_exports)), "_page5");
var _page62 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_login_astro(), login_astro_exports)), "_page6");
var _page72 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_refresh_astro(), refresh_astro_exports)), "_page7");
var _page82 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_verify_astro(), verify_astro_exports)), "_page8");
var _page92 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro2(), slug_astro_exports2)), "_page9");
var _page102 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_authors_astro(), authors_astro_exports)), "_page10");
var _page112 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_authors_astro2(), authors_astro2_exports)), "_page11");
var _page122 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro3(), slug_astro_exports3)), "_page12");
var _page132 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro4(), slug_astro_exports4)), "_page13");
var _page142 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_categories_astro(), categories_astro_exports)), "_page14");
var _page152 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_content_astro(), content_astro_exports)), "_page15");
var _page162 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_path_astro2(), path_astro_exports2)), "_page16");
var _page172 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_bulk_delete_astro(), bulk_delete_astro_exports)), "_page17");
var _page182 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_confirm_astro(), confirm_astro_exports)), "_page18");
var _page192 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_urls_astro(), upload_urls_astro_exports)), "_page19");
var _page202 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_variant_astro(), upload_variant_astro_exports)), "_page20");
var _page212 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_id_astro2(), id_astro_exports2)), "_page21");
var _page222 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_media_astro(), media_astro_exports)), "_page22");
var _page232 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_pins_astro(), pins_astro_exports)), "_page23");
var _page242 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_pinterest_boards_astro(), pinterest_boards_astro_exports)), "_page24");
var _page252 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_proxy_image_astro(), proxy_image_astro_exports)), "_page25");
var _page262 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro5(), slug_astro_exports5)), "_page26");
var _page272 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_recipes_astro(), recipes_astro_exports)), "_page27");
var _page282 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_recipes_astro2(), recipes_astro2_exports)), "_page28");
var _page292 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro6(), slug_astro_exports6)), "_page29");
var _page302 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_roundups_astro(), roundups_astro_exports)), "_page30");
var _page312 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_seed_images_astro(), seed_images_astro_exports)), "_page31");
var _page322 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_image_upload_astro(), image_upload_astro_exports)), "_page32");
var _page332 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_dashboard_astro(), dashboard_astro_exports)), "_page33");
var _page342 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_popular_astro(), popular_astro_exports)), "_page34");
var _page352 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro7(), slug_astro_exports7)), "_page35");
var _page362 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_tags_astro(), tags_astro_exports)), "_page36");
var _page372 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro8(), slug_astro_exports8)), "_page37");
var _page382 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_templates_astro(), templates_astro_exports)), "_page38");
var _page392 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_font_astro(), upload_font_astro_exports)), "_page39");
var _page402 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_from_url_astro(), upload_from_url_astro_exports)), "_page40");
var _page412 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_image_astro(), upload_image_astro_exports)), "_page41");
var _page422 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_upload_thumbnail_astro(), upload_thumbnail_astro_exports)), "_page42");
var _page432 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro9(), slug_astro_exports9)), "_page43");
var _page442 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro10(), slug_astro_exports10)), "_page44");
var _page452 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_authors_astro3(), authors_astro_exports2)), "_page45");
var _page462 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro11(), slug_astro_exports11)), "_page46");
var _page472 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_categories_astro2(), categories_astro_exports2)), "_page47");
var _page482 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_contact_astro(), contact_astro_exports)), "_page48");
var _page492 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_faqs_astro(), faqs_astro_exports)), "_page49");
var _page502 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro12(), slug_astro_exports12)), "_page50");
var _page512 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_key_astro(), key_astro_exports)), "_page51");
var _page522 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro13(), slug_astro_exports13)), "_page52");
var _page532 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_recipes_astro3(), recipes_astro_exports2)), "_page53");
var _page542 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_board_xml_astro(), board_xml_astro_exports)), "_page54");
var _page552 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_pinterest_xml_astro(), pinterest_xml_astro_exports)), "_page55");
var _page562 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_recipes_xml_astro(), recipes_xml_astro_exports)), "_page56");
var _page572 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_sitemap_astro(), sitemap_astro_exports)), "_page57");
var _page582 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_slug_astro14(), slug_astro_exports14)), "_page58");
var _page592 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_tags_astro2(), tags_astro_exports2)), "_page59");
var _page602 = /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_index_astro(), index_astro_exports)), "_page60");
var pageMap = /* @__PURE__ */ new Map([
  ["node_modules/.pnpm/@astrojs+cloudflare@12.6.12_f9354d53bede48c7476e55e087cd9165/node_modules/@astrojs/cloudflare/dist/entrypoints/image-endpoint.js", _page0],
  ["src/pages/about.astro", _page1],
  ["src/pages/admin/[...path].astro", _page210],
  ["src/pages/api/admin/articles/[id].ts", _page310],
  ["src/pages/api/articles/[slug].ts", _page410],
  ["src/pages/api/articles.ts", _page510],
  ["src/pages/api/auth/login.ts", _page62],
  ["src/pages/api/auth/refresh.ts", _page72],
  ["src/pages/api/auth/verify.ts", _page82],
  ["src/pages/api/authors/[slug].ts", _page92],
  ["src/pages/api/authors/index.ts", _page102],
  ["src/pages/api/authors.ts", _page112],
  ["src/pages/api/branding/[...slug].ts", _page122],
  ["src/pages/api/categories/[slug].ts", _page132],
  ["src/pages/api/categories.ts", _page142],
  ["src/pages/api/content/index.ts", _page152],
  ["src/pages/api/images/[...path].ts", _page162],
  ["src/pages/api/media/bulk-delete.ts", _page172],
  ["src/pages/api/media/confirm.ts", _page182],
  ["src/pages/api/media/upload-urls.ts", _page192],
  ["src/pages/api/media/upload-variant.ts", _page202],
  ["src/pages/api/media/[id].ts", _page212],
  ["src/pages/api/media.ts", _page222],
  ["src/pages/api/pins.ts", _page232],
  ["src/pages/api/pinterest-boards.ts", _page242],
  ["src/pages/api/proxy-image.ts", _page252],
  ["src/pages/api/recipes/[slug].ts", _page262],
  ["src/pages/api/recipes/index.ts", _page272],
  ["src/pages/api/recipes.ts", _page282],
  ["src/pages/api/roundups/[slug].ts", _page292],
  ["src/pages/api/roundups/index.ts", _page302],
  ["src/pages/api/seed-images.ts", _page312],
  ["src/pages/api/settings/image-upload.ts", _page322],
  ["src/pages/api/stats/dashboard.ts", _page332],
  ["src/pages/api/stats/popular.ts", _page342],
  ["src/pages/api/tags/[slug].ts", _page352],
  ["src/pages/api/tags.ts", _page362],
  ["src/pages/api/templates/[slug].ts", _page372],
  ["src/pages/api/templates.ts", _page382],
  ["src/pages/api/upload-font.ts", _page392],
  ["src/pages/api/upload-from-url.ts", _page402],
  ["src/pages/api/upload-image.ts", _page412],
  ["src/pages/api/upload-thumbnail.ts", _page422],
  ["src/pages/api/views/[slug].ts", _page432],
  ["src/pages/authors/[slug].astro", _page442],
  ["src/pages/authors/index.astro", _page452],
  ["src/pages/categories/[slug].astro", _page462],
  ["src/pages/categories/index.astro", _page472],
  ["src/pages/contact.astro", _page482],
  ["src/pages/faqs.astro", _page492],
  ["src/pages/feed/[slug].ts", _page502],
  ["src/pages/images/[...key].ts", _page512],
  ["src/pages/recipes/[slug].astro", _page522],
  ["src/pages/recipes/index.astro", _page532],
  ["src/pages/rss/pinterest/[board].xml.ts", _page542],
  ["src/pages/rss/pinterest.xml.ts", _page552],
  ["src/pages/rss/recipes.xml.ts", _page562],
  ["src/pages/sitemap.ts", _page572],
  ["src/pages/tags/[slug].astro", _page582],
  ["src/pages/tags/index.astro", _page592],
  ["src/pages/index.astro", _page602]
]);
var _manifest = Object.assign(manifest, {
  pageMap,
  serverIslandMap,
  renderers,
  actions: /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_noop_entrypoint(), noop_entrypoint_exports)), "actions"),
  middleware: /* @__PURE__ */ __name2(() => Promise.resolve().then(() => (init_astro_internal_middleware(), astro_internal_middleware_exports)), "middleware")
});
var _args = void 0;
var _exports = createExports(_manifest);
var __astrojsSsrVirtualEntry = _exports.default;
var _start = "start";
if (Object.prototype.hasOwnProperty.call(serverEntrypointModule, _start)) {
  serverEntrypointModule[_start](_manifest, _args);
}

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/pages-dev-util.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isRoutingRuleMatch(pathname, routingRule) {
  if (!pathname) {
    throw new Error("Pathname is undefined.");
  }
  if (!routingRule) {
    throw new Error("Routing rule is undefined.");
  }
  const ruleRegExp = transformRoutingRuleToRegExp(routingRule);
  return pathname.match(ruleRegExp) !== null;
}
__name(isRoutingRuleMatch, "isRoutingRuleMatch");
function transformRoutingRuleToRegExp(rule) {
  let transformedRule;
  if (rule === "/" || rule === "/*") {
    transformedRule = rule;
  } else if (rule.endsWith("/*")) {
    transformedRule = `${rule.substring(0, rule.length - 2)}(/*)?`;
  } else if (rule.endsWith("/")) {
    transformedRule = `${rule.substring(0, rule.length - 1)}(/)?`;
  } else if (rule.endsWith("*")) {
    transformedRule = rule;
  } else {
    transformedRule = `${rule}(/)?`;
  }
  transformedRule = `^${transformedRule.replaceAll(/\./g, "\\.").replaceAll(/\*/g, ".*")}$`;
  return new RegExp(transformedRule);
}
__name(transformRoutingRuleToRegExp, "transformRoutingRuleToRegExp");

// .wrangler/tmp/pages-AQW1MV/zl5dey19hob.js
var define_ROUTES_default = {
  version: 1,
  include: [
    "/*"
  ],
  exclude: [
    "/_astro/*",
    "/favicon.svg",
    "/robots.txt",
    "/logos/android-chrome-192x192.png",
    "/logos/android-chrome-512x512.png",
    "/logos/apple-touch-icon.png",
    "/logos/favicon-16x16.png",
    "/logos/favicon-32x32.png",
    "/logos/favicon.svg",
    "/logos/logo-main.png",
    "/logos/logo-mobile.svg",
    "/logos/site.webmanifest"
  ]
};
var routes = define_ROUTES_default;
var pages_dev_pipeline_default = {
  fetch(request, env3, context3) {
    const { pathname } = new URL(request.url);
    for (const exclude of routes.exclude) {
      if (isRoutingRuleMatch(pathname, exclude)) {
        return env3.ASSETS.fetch(request);
      }
    }
    for (const include of routes.include) {
      if (isRoutingRuleMatch(pathname, include)) {
        const workerAsHandler = __astrojsSsrVirtualEntry;
        if (workerAsHandler.fetch === void 0) {
          throw new TypeError("Entry point missing `fetch` handler");
        }
        return workerAsHandler.fetch(request, env3, context3);
      }
    }
    return env3.ASSETS.fetch(request);
  }
};

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env3);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env3);
  } catch (e2) {
    const error5 = reduceError(e2);
    return Response.json(error5, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-1QI512/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = pages_dev_pipeline_default;

// node_modules/.pnpm/wrangler@4.56.0_@cloudflare+workers-types@4.20251217.0/node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env3, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env3, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env3, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env3, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-1QI512/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env3, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env3, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env3, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env3, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env3, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env3, ctx) => {
      this.env = env3;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default,
  pageMap
};
/**
 * shortdash - https://github.com/bibig/node-shorthash
 *
 * @license
 *
 * (The MIT License)
 *
 * Copyright (c) 2013 Bibig <bibig@me.com>
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server-legacy.browser.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server.browser.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license MIT <https://opensource.org/licenses/MIT>
 * @copyright Michael Hart 2024
 */
//# sourceMappingURL=zl5dey19hob.js.map
